<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<!-- Automatically generated file. Do not manually alter! -->

<head><title>Sparser - Architecture</title> <link href="https://sparser.io/docs-html/architecture.xhtml" rel="canonical" type="application/xhtml+xml"/> <meta content="width=device-width, initial-scale=1" name="viewport"/> <meta content="index, follow" name="robots"/> <meta content="Sparser - Universal Parser" name="DC.title"/> <meta content="#fff" name="theme-color"/> <meta content="Austin Cheney" name="author"/> <meta content="Sparser is a programming language parsing utility that can interpret many different languages using a single simple data model." name="description"/> <meta content="Global" name="distribution"/> <meta content="en" http-equiv="Content-Language"/> <meta content="application/xhtml+xml;charset=UTF-8" http-equiv="Content-Type"/> <meta content="blendTrans(Duration=0)" http-equiv="Page-Enter"/> <meta content="blendTrans(Duration=0)" http-equiv="Page-Exit"/> <meta content="text/css" http-equiv="content-style-type"/> <meta content="application/javascript" http-equiv="content-script-type"/> <meta content="google515f7751c9f8a155" name="google-site-verification"/> <meta content="#bbbbff" name="msapplication-TileColor"/> <link href="/website.css" media="all" rel="stylesheet" type="text/css"/> </head><body id="documentation"><div id="top_menu"><h1><a href="/">Sparser</a></h1>
<ul><li class="donate"><a href="https://liberapay.com/prettydiff/donate"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" height="16" width="16" x="7" y="7"><g transform="translate(-78.37-208.06)" fill="#111"><path d="m104.28 271.1c-3.571 0-6.373-.466-8.41-1.396-2.037-.93-3.495-2.199-4.375-3.809-.88-1.609-1.308-3.457-1.282-5.544.025-2.086.313-4.311.868-6.675l9.579-40.05 11.69-1.81-10.484 43.44c-.202.905-.314 1.735-.339 2.489-.026.754.113 1.421.415 1.999.302.579.817 1.044 1.546 1.395.729.353 1.747.579 3.055.679l-2.263 9.278"/><path d="m146.52 246.14c0 3.671-.604 7.03-1.811 10.07-1.207 3.043-2.879 5.669-5.01 7.881-2.138 2.213-4.702 3.935-7.693 5.167-2.992 1.231-6.248 1.848-9.767 1.848-1.71 0-3.42-.151-5.129-.453l-3.394 13.651h-11.162l12.52-52.19c2.01-.603 4.311-1.143 6.901-1.622 2.589-.477 5.393-.716 8.41-.716 2.815 0 5.242.428 7.278 1.282 2.037.855 3.708 2.024 5.02 3.507 1.307 1.484 2.274 3.219 2.904 5.205.627 1.987.942 4.11.942 6.373m-27.378 15.461c.854.202 1.91.302 3.167.302 1.961 0 3.746-.364 5.355-1.094 1.609-.728 2.979-1.747 4.111-3.055 1.131-1.307 2.01-2.877 2.64-4.714.628-1.835.943-3.858.943-6.071 0-2.161-.479-3.998-1.433-5.506-.956-1.508-2.615-2.263-4.978-2.263-1.61 0-3.118.151-4.525.453l-5.28 21.948"/></g></svg> Donate</a></li> <li><a href="/demo/?scrolldown">Demo</a></li> <li><a href="/docs-html/tech-documentation.xhtml">Documentation</a></li> <li><a href="https://github.com/unibeautify/sparser">Github</a></li> <li><a href="https://www.npmjs.com/package/sparser">NPM</a></li></ul><span class="clear"></span></div><div id="content"><h1><span>Sparser</span>Architecture</h1>
<div class="section"><h2 id="two-objects">Two Objects</h2>
<p>Sparser is arranged as two objects. An externally exposed object named <strong>sparser</strong> and an internally available object named <strong>parse</strong>. The <em>sparser</em> parent object provides the interface to the application while the <em>parse</em> provides a tiny framework.</p>
</div><div class="section"><h2 id="commonly-used-data-structures">Commonly Used Data Structures</h2>
<ul><li>data - An object containing arrays used as the primary parser output.</li><li>record - An object representing a single index of the <em>data</em> type.</li></ul><h3 id="data-example">data Example</h3>
<p><code><![CDATA[{begin: [], ender: [], lexer: [], lines: [], stack: [], token: [], types: []}]]></code></p>
<h3 id="record-example">record Example</h3>
<p><code><![CDATA[{begin: -1, ender: -1, lexer: "markup", lines: 0, stack: "global", token: "<!doctype html>", types: "SGML"}]]></code></p>
</div><div class="section"><h2 id="the-externally-available-object-sparser">The Externally Available object - sparser</h2>
<h3 id="sparser-keys">sparser keys</h3>
<ul><li><strong>lexers</strong> - <em>object</em> - An object containing each lexer file.</li><li><strong>libs</strong> - <em>object</em> - An object containing the utilities stored in the <em>libs</em> directory.</li><li><strong>options</strong> - <em>object</em> - An object containing all the configuration settings. Please see the <a href="options.xhtml">options documentation</a>
.</li><li><strong>parse</strong> - <em>object</em> - The internal data settings and control methods.</li><li><strong>parser</strong> - <em>function</em> - <strong>The function that performs the parsing.</strong></li><li><strong>parseerror</strong> - <em>string</em> - The default value is an empty string. If this value changes something has gone wrong, or the input is defective.</li><li><strong>version</strong> - <em>object</em> - An object containing two properties. The <em>data</em> property is a string indicating last git commit date and the <em>number</em> property is the current application version number.</li></ul><p>The sparser object is defined in the <em>parse.ts</em> file. It is available to Node from the <em>js/parse.js</em> file using <code><![CDATA[global.sparser]]></code> or to Windows in the <em>js/browser.js</em> file using <code><![CDATA[window.sparser]]></code>. Those files are actually identical except for two externally facing references.</p>
</div><div class="section"><h2 id="the-internally-facing-object-sparserparse">The Internally Facing object - sparser.parse</h2>
<h3 id="parse-keys">parse keys</h3>
<ul><li><strong>concat</strong> - <em>function</em> - Concats various data structures of type <em>data</em>. Use this only as a last resort, because it is slow. This method takes the following two arguments: <ol><li><em>data</em> - An object of type <em>data</em>.</li><li><em>array</em> - A second object also of type <em>data</em>.</li></ol></li><li><strong>count</strong> - <em>number</em> - Stores the last index number of the last populated token. There is never a need to check the length of the primary data arrays, because this value always available as <code><![CDATA[parse.count]]></code>.</li><li><strong>data</strong> - <em>data</em> - Contains the primary data arrays. For more information please see the <a href="tech-documentation.md#universal-parse-model">technical documentation</a>
.</li><li><strong>datanames</strong> - <em>string[]</em> - Contains the array names of the arrays comprising the data object. This is present to provided as a convenience to avoid use of <code><![CDATA[Object.keys(sparse.parse.data)]]></code>.</li><li><strong>lineNumber</strong> - <em>number</em> - The current line number of the input source string. This is helpful to populate the <code><![CDATA[sparser.parseerror]]></code> with specific information about where the error in the source string is detected.</li><li><strong>linesSpace</strong> - <em>number</em> - The white space preeceding the current token. Use this value to populate the current token's <code><![CDATA[lines]]></code> array value and is computed by the <code><![CDATA[parse.spacer]]></code> method.</li><li><strong>object_sort</strong> - <em>function</em> - Provides object sorting for the <em>style</em> and <em>script</em> lexers if their <em>object_sort</em> options are set to true. The sort is multidimensional. The <em>markup</em> lexer uses different internal functionality for its <em>tag_sort</em> option. This method takes only 1 argument of type <em>data</em>.</li><li><strong>pop</strong> - <em>function</em> - Similar to JavaScript's <code><![CDATA[Array.prototype.pop]]></code> method, but works on <em>data</em> typed data structures and returns the last record. This method takes only 1 argument of type <em>data</em>.</li><li><strong>push</strong> - <em>function</em> - Similar to JavaScript's <code><![CDATA[Array.prototype.push]]></code> method, but works on <em>data</em> typed data structures and populates the <em>ender</em> data value and <code><![CDATA[parse.structure]]></code>. This method takes the following three arguments. <ol><li><em>data</em> - An object of type <em>data</em> that you wish to increase.</li><li><em>record</em> - An object of type <em>record</em> that you wish to add to the end of the specified data.</li><li><em>structure</em> A string that describes the <em>stack</em> name of the current start type. Tokens of other types do not use this argument.</li></ol></li><li><strong>references</strong> - <em>string[][]</em> - An array of string arrays used for storing variables according to the structure where they are declared. This allows the <em>script</em> lexer to tell the difference between keyword and reference values when describing the <em>types</em> of a token. HTML and XML are lexically scoped as well, but they don't need this added bit of assistance because the scoping in markup languages is inherent to the language's tag structure.</li><li><strong>safeSort</strong> - <em>function</em> - Currently JavaScript's <code><![CDATA[Array.prototype.sort]]></code> is not stable cross browser. This function solves for that inconsistency and is multidimensional. This method takes the following three arguments: <ol><li><em>array</em> - Any type of array to sort.</li><li><em>operation</em> - A string value of: <em>ascend</em>, <em>descend</em>, or <em>normal</em>. The value <em>normal</em> will normalize an array by removing duplicate values.</li><li><em>recursive</em> - A boolean determine if the current array should be sorted only or if sort should be multidimensional.</li></ol></li><li><strong>sortCorrection</strong> - <em>function</em> - The object_sort function destroys the integrity of the <em>begin</em> and <em>ender</em> data values. This function provides the necessary correction and takes two arguments: <ol><li><em>start</em> - A number of which index to start the correction.</li><li><em>end</em> - A number of which index to end the correction.</li></ol></li><li><strong>spacer</strong> - <em>function</em> - Skips over consecutive white space tokens and updates <code><![CDATA[parse.linesSpace]]></code>. This function takes an object in the following format: <ul><li><strong>array</strong> - <em>string[]</em> - An array of single characters. The source sample input string split into an array.</li><li><strong>end</strong> - <em>number</em> - The length of the specified character array.</li><li><strong>index</strong> - <em>number</em> - The current index of the specified character array.</li></ul></li><li><strong>splice</strong> - <em>function</em> - Similar to JavaScript's <code><![CDATA[Array.prototype.splice]]></code> method, but works on <em>data</em> typed data structures. The splice method takes an object in this format: <ul><li><strong>data</strong> - <em>data</em> - Any object of data type <em>data</em>.</li><li><strong>howmany</strong> - <em>number</em> - How many indexes to remove. A value of 0 is acceptable if you wish to insert a record.</li><li><strong>index</strong> - <em>number</em> - Which index to start from.</li><li><strong>record</strong> - <em>record</em> - Data in record format to insert. This item is optional.</li></ul></li><li><strong>structure</strong> - <em>[[string, number]]</em> - Temporary storage to describe the current stack and begin values for the current structure of tokens.</li><li><strong>wrapCommentBlock</strong> - <em>function</em> - Parses block comments in <em>markup</em>, <em>script</em>, and <em>style</em> lexers. This function also accounts for <a href="tech-documentation.md#ignore-code">parse-ignore-start</a> 
and word wrapping. This method takes object as an argument in the following definition: <ul><li><strong>chars</strong> - <em>string[]</em> - The character array of the source input from the lexer.</li><li><strong>end</strong> - <em>number</em> - The length of the specififed character array.</li><li><strong>lexer</strong> - <em>string</em> - The name of the current lexer.</li><li><strong>opening</strong> - <em>string</em> - The opening sequence of the current comment, for example: <code><![CDATA[<!--]]></code> or <code><![CDATA[/*]]></code>. The markup lexer supports many different comment types.</li><li><strong>start</strong> - <em>number</em> - The current index of the specified character array.</li><li><strong>terminator</strong> - <em>string</em> - The termination sequence for the given comment, for example: <code><![CDATA[-->]]></code> or <code><![CDATA[*/]]></code>.</li></ul></li><li><strong>wrapCommentLine</strong> - <em>function</em> - Parses line comments in <em>script</em> and <em>style</em> lexers. It also word wraps and accounts for ignored blocks of code. This method takes the exact same object format as the <em>wrapCommentBlock</em> method.</li></ul></div></div><div id="blobs"><span id="svg_left"></span><span id="svg_right"></span><div></div></div><script src="/js/website.js" type="application/javascript"></script></body></html>