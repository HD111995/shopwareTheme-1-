<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<!-- Automatically generated file. Do not manually alter! -->

<head><title>Sparser - Options</title> <link href="https://sparser.io/docs-html/options.xhtml" rel="canonical" type="application/xhtml+xml"/> <meta content="width=device-width, initial-scale=1" name="viewport"/> <meta content="index, follow" name="robots"/> <meta content="Sparser - Universal Parser" name="DC.title"/> <meta content="#fff" name="theme-color"/> <meta content="Austin Cheney" name="author"/> <meta content="Sparser is a programming language parsing utility that can interpret many different languages using a single simple data model." name="description"/> <meta content="Global" name="distribution"/> <meta content="en" http-equiv="Content-Language"/> <meta content="application/xhtml+xml;charset=UTF-8" http-equiv="Content-Type"/> <meta content="blendTrans(Duration=0)" http-equiv="Page-Enter"/> <meta content="blendTrans(Duration=0)" http-equiv="Page-Exit"/> <meta content="text/css" http-equiv="content-style-type"/> <meta content="application/javascript" http-equiv="content-script-type"/> <meta content="google515f7751c9f8a155" name="google-site-verification"/> <meta content="#bbbbff" name="msapplication-TileColor"/> <link href="/website.css" media="all" rel="stylesheet" type="text/css"/> </head><body id="documentation"><div id="top_menu"><h1><a href="/">Sparser</a></h1>
<ul><li class="donate"><a href="https://liberapay.com/prettydiff/donate"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" height="16" width="16" x="7" y="7"><g transform="translate(-78.37-208.06)" fill="#111"><path d="m104.28 271.1c-3.571 0-6.373-.466-8.41-1.396-2.037-.93-3.495-2.199-4.375-3.809-.88-1.609-1.308-3.457-1.282-5.544.025-2.086.313-4.311.868-6.675l9.579-40.05 11.69-1.81-10.484 43.44c-.202.905-.314 1.735-.339 2.489-.026.754.113 1.421.415 1.999.302.579.817 1.044 1.546 1.395.729.353 1.747.579 3.055.679l-2.263 9.278"/><path d="m146.52 246.14c0 3.671-.604 7.03-1.811 10.07-1.207 3.043-2.879 5.669-5.01 7.881-2.138 2.213-4.702 3.935-7.693 5.167-2.992 1.231-6.248 1.848-9.767 1.848-1.71 0-3.42-.151-5.129-.453l-3.394 13.651h-11.162l12.52-52.19c2.01-.603 4.311-1.143 6.901-1.622 2.589-.477 5.393-.716 8.41-.716 2.815 0 5.242.428 7.278 1.282 2.037.855 3.708 2.024 5.02 3.507 1.307 1.484 2.274 3.219 2.904 5.205.627 1.987.942 4.11.942 6.373m-27.378 15.461c.854.202 1.91.302 3.167.302 1.961 0 3.746-.364 5.355-1.094 1.609-.728 2.979-1.747 4.111-3.055 1.131-1.307 2.01-2.877 2.64-4.714.628-1.835.943-3.858.943-6.071 0-2.161-.479-3.998-1.433-5.506-.956-1.508-2.615-2.263-4.978-2.263-1.61 0-3.118.151-4.525.453l-5.28 21.948"/></g></svg> Donate</a></li> <li><a href="/demo/?scrolldown">Demo</a></li> <li><a href="/docs-html/tech-documentation.xhtml">Documentation</a></li> <li><a href="https://github.com/unibeautify/sparser">Github</a></li> <li><a href="https://www.npmjs.com/package/sparser">NPM</a></li></ul><span class="clear"></span></div><div id="content"><h1><span>Sparser</span>Options</h1>
<div class="section"><h2 id="conventions">Conventions</h2>
<p>Options with a lexer value of <em>all</em> are assigned directly to the options object, such as <code><![CDATA[options.format]]></code>. All other options are assigned to an object named after the respective lexer under the <code><![CDATA[lexer_options]]></code> object, example: <code><![CDATA[options.lexer_options.style.no_lead_zero]]></code>.</p>
<p>All option names are lowercase complete English words. An option name comprising multiple words contains a single underscore between each word, example: <code><![CDATA[end_comma]]></code>.</p>
<p>The options object is directly available from the <em>sparser</em> object. This means the options are centrally stored and externally available. Here is an example in the browser, <code><![CDATA[window.sparser.options]]></code>. The means to externally adjust options are by assigning directly to that object, such as <code><![CDATA[window.sparser.options.format = "objects"]]></code>.</p>
</div><div class="section" id="option_list"><h2 id="option-list">Option List</h2>
<h3 id="attribute_sort">attribute_sort</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Alphanumerically sort markup attributes. Sorting is ignored if a given tag contains an attribute with instructions for a different language such as a template scheme, child markup tag, or start of a code structure.</td></tr><tr><th>label</th><td>Sort Attributes</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.attribute_sort</td></tr></tbody></table><h3 id="attribute_sort_list">attribute_sort_list</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td></td></tr><tr><th>definition</th><td>A comma separated list of attribute names. Attributes will be sorted according to this list and then alphanumerically. This option requires 'attribute_sort' have a value of true.</td></tr><tr><th>label</th><td>Sort Attribute List</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.attribute_sort_list</td></tr></tbody></table><h3 id="correct">correct</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Automatically correct sloppiness in code. If false missing syntax will be included starting with 'x', such as 'x;' for missing simicolons.</td></tr><tr><th>label</th><td>Correct</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.correct</td></tr></tbody></table><h3 id="crlf">crlf</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>If line termination should be crlf (Windows) otherwise line termination is lf (Unix).</td></tr><tr><th>label</th><td>CRLF</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.crlf</td></tr></tbody></table><h3 id="end_comma">end_comma</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>none</td></tr><tr><th>definition</th><td>Whether terminal commas in objects and arrays should be added or eliminated.</td></tr><tr><th>label</th><td>End Comma</td></tr><tr><th>lexer</th><td>script</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.lexer_options.**script**.end_comma</td></tr><tr><th>values</th><td>always, never, none</td></tr></tbody></table><h4 id="value-definitions">Value Definitions</h4>
<ul><li><strong>always</strong> - Adds terminal commas if they are missing.</li><li><strong>never</strong> - Removes terminal commas if they are present.</li><li><strong>none</strong> - Ignores this option.</li></ul><h3 id="format">format</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>arrays</td></tr><tr><th>definition</th><td>Defines the output format of the parser.</td></tr><tr><th>label</th><td>Output Format</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.format</td></tr><tr><th>values</th><td>arrays, csv, markdown, minimal, objects</td></tr></tbody></table><h4 id="value-definitions">Value Definitions</h4>
<ul><li><strong>arrays</strong> - The output format is an object of arrays such that the same index of all the arrays represents one data record, for example: <code><![CDATA[{begin:[],ender:[],lexer:[],lines[],stack:[],token:[],types:[]}]]></code>.</li><li><strong>csv</strong> - The output format is comma separated value format.</li><li><strong>markdown</strong> - Generates the output in a markdown table.</li><li><strong>minimal</strong> - The output format is an array of arrays which is structurally similar to the objects format but without key names, for example: <code><![CDATA[[[-1,-1,"script",0,"global","const","word"]]]]></code>.</li><li><strong>objects</strong> - The output format is an array of objects such that each array index is one data record, for example: <code><![CDATA[[{begin:-1,ender:-1,lexer:"script",lines:0,stack:"global",token:"const",types:"word"}]]]></code>.</li></ul><h3 id="language">language</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>auto</td></tr><tr><th>definition</th><td>The language to parse.  The value auto will result in language auto detection.</td></tr><tr><th>label</th><td>Language</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.language</td></tr></tbody></table><h3 id="lexer">lexer</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>auto</td></tr><tr><th>definition</th><td>The lexer used to perform the parsing.  The value auto will result in language auto detection.</td></tr><tr><th>label</th><td>Lexer</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.lexer</td></tr></tbody></table><h3 id="no_lead_zero">no_lead_zero</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Whether the zero to the left of the decimal point should be removed from numbers between 0 and 1.</td></tr><tr><th>label</th><td>No Lead Zero</td></tr><tr><th>lexer</th><td>style</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**style**.no_lead_zero</td></tr></tbody></table><h3 id="object_sort">object_sort</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Where style properties should be sorted by type and then alphabetically and whether script object properties should be sorted alphabetically.</td></tr><tr><th>label</th><td>Object Sort</td></tr><tr><th>lexer</th><td>script, style</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**script**.object_sort, options.lexer_options.**style**.object_sort</td></tr></tbody></table><h3 id="parse_space">parse_space</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Whether white space should be parsed as content tokens.</td></tr><tr><th>label</th><td>Parse Markup White Space</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.parse_space</td></tr></tbody></table><h3 id="preserve_comment">preserve_comment</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Whether comments should be ignored from manipulation, such as word wrap.</td></tr><tr><th>label</th><td>Preserve Comment</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.preserve_comment</td></tr></tbody></table><h3 id="preserve_text">preserve_text</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Whether text content should be preserved from manipulation, such as word wrap.</td></tr><tr><th>label</th><td>Preserve Text</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.preserve_text</td></tr></tbody></table><h3 id="quote_convert">quote_convert</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>none</td></tr><tr><th>definition</th><td>If quote characters should be converted from single quotes to double quotes or the opposite. This option does take into account escaped quote characters.</td></tr><tr><th>label</th><td>Quote Convert</td></tr><tr><th>lexer</th><td>markup, script, style</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.quote_convert, options.lexer_options.**script**.quote_convert, options.lexer_options.**style**.quote_convert</td></tr><tr><th>values</th><td>double, none, single</td></tr></tbody></table><h4 id="value-definitions">Value Definitions</h4>
<ul><li><strong>double</strong> - Converts single quote characters to double quote characters.</li><li><strong>none</strong> - Ignores this option.</li><li><strong>single</strong> - Converts double quote characters to single quote characters.</li></ul><h3 id="source">source</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td></td></tr><tr><th>definition</th><td>The source code to parse.</td></tr><tr><th>label</th><td>Source</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.source</td></tr></tbody></table><h3 id="tag_merge">tag_merge</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>If adjacent start and end tags in markup should be merged into one singleton tag.</td></tr><tr><th>label</th><td>Tag Merge</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.tag_merge</td></tr></tbody></table><h3 id="tag_sort">tag_sort</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>Whether markup tags should be alphabetically sorted amonst their siblings.</td></tr><tr><th>label</th><td>Tag Sort</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.tag_sort</td></tr></tbody></table><h3 id="unformatted">unformatted</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>false</td></tr><tr><th>definition</th><td>If tags in markup code should be preserved from any manner of alteration.</td></tr><tr><th>label</th><td>Tag Unformatted</td></tr><tr><th>lexer</th><td>markup</td></tr><tr><th>type</th><td>boolean</td></tr><tr><th>use</th><td>options.lexer_options.**markup**.unformatted</td></tr></tbody></table><h3 id="variable_list">variable_list</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>none</td></tr><tr><th>definition</th><td>Whether consecutive variable declarations should be separate statements or a comma separated list. Use of this option respects the different types of declarations: var, const, let.</td></tr><tr><th>label</th><td>Variable List</td></tr><tr><th>lexer</th><td>script</td></tr><tr><th>type</th><td>string</td></tr><tr><th>use</th><td>options.lexer_options.**script**.variable_list</td></tr><tr><th>values</th><td>each, list, none</td></tr></tbody></table><h4 id="value-definitions">Value Definitions</h4>
<ul><li><strong>each</strong> - Separates variable declarations into separate statements.</li><li><strong>list</strong> - Combines consecutive variable declaration statements into a single comma separated list.</li><li><strong>none</strong> - Ignores this option.</li></ul><h3 id="wrap">wrap</h3>
<table><thead><tr><th>property</th><th>value</th></tr></thead><tbody><tr><th>default</th><td>0</td></tr><tr><th>definition</th><td>The character distance in which to apply word wrap. A value of less than 1 eliminates word wrap.</td></tr><tr><th>label</th><td>Wrap</td></tr><tr><th>lexer</th><td>all</td></tr><tr><th>type</th><td>number</td></tr><tr><th>use</th><td>options.wrap</td></tr></tbody></table></div></div><div id="blobs"><span id="svg_left"></span><span id="svg_right"></span><div></div></div><script src="/js/website.js" type="application/javascript"></script></body></html>