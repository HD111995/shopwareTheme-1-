<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html><html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">

<!-- Automatically generated file. Do not manually alter! -->

<head><title>Sparser - Intoduction To Parsers</title> <link href="https://sparser.io/docs-html/parsers.xhtml" rel="canonical" type="application/xhtml+xml"/> <meta content="width=device-width, initial-scale=1" name="viewport"/> <meta content="index, follow" name="robots"/> <meta content="Sparser - Universal Parser" name="DC.title"/> <meta content="#fff" name="theme-color"/> <meta content="Austin Cheney" name="author"/> <meta content="Sparser is a programming language parsing utility that can interpret many different languages using a single simple data model." name="description"/> <meta content="Global" name="distribution"/> <meta content="en" http-equiv="Content-Language"/> <meta content="application/xhtml+xml;charset=UTF-8" http-equiv="Content-Type"/> <meta content="blendTrans(Duration=0)" http-equiv="Page-Enter"/> <meta content="blendTrans(Duration=0)" http-equiv="Page-Exit"/> <meta content="text/css" http-equiv="content-style-type"/> <meta content="application/javascript" http-equiv="content-script-type"/> <meta content="google515f7751c9f8a155" name="google-site-verification"/> <meta content="#bbbbff" name="msapplication-TileColor"/> <link href="/website.css" media="all" rel="stylesheet" type="text/css"/> </head><body id="documentation"><div id="top_menu"><h1><a href="/">Sparser</a></h1>
<ul><li class="donate"><a href="https://liberapay.com/prettydiff/donate"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 80 80" height="16" width="16" x="7" y="7"><g transform="translate(-78.37-208.06)" fill="#111"><path d="m104.28 271.1c-3.571 0-6.373-.466-8.41-1.396-2.037-.93-3.495-2.199-4.375-3.809-.88-1.609-1.308-3.457-1.282-5.544.025-2.086.313-4.311.868-6.675l9.579-40.05 11.69-1.81-10.484 43.44c-.202.905-.314 1.735-.339 2.489-.026.754.113 1.421.415 1.999.302.579.817 1.044 1.546 1.395.729.353 1.747.579 3.055.679l-2.263 9.278"/><path d="m146.52 246.14c0 3.671-.604 7.03-1.811 10.07-1.207 3.043-2.879 5.669-5.01 7.881-2.138 2.213-4.702 3.935-7.693 5.167-2.992 1.231-6.248 1.848-9.767 1.848-1.71 0-3.42-.151-5.129-.453l-3.394 13.651h-11.162l12.52-52.19c2.01-.603 4.311-1.143 6.901-1.622 2.589-.477 5.393-.716 8.41-.716 2.815 0 5.242.428 7.278 1.282 2.037.855 3.708 2.024 5.02 3.507 1.307 1.484 2.274 3.219 2.904 5.205.627 1.987.942 4.11.942 6.373m-27.378 15.461c.854.202 1.91.302 3.167.302 1.961 0 3.746-.364 5.355-1.094 1.609-.728 2.979-1.747 4.111-3.055 1.131-1.307 2.01-2.877 2.64-4.714.628-1.835.943-3.858.943-6.071 0-2.161-.479-3.998-1.433-5.506-.956-1.508-2.615-2.263-4.978-2.263-1.61 0-3.118.151-4.525.453l-5.28 21.948"/></g></svg> Donate</a></li> <li><a href="/demo/?scrolldown">Demo</a></li> <li><a href="/docs-html/tech-documentation.xhtml">Documentation</a></li> <li><a href="https://github.com/unibeautify/sparser">Github</a></li> <li><a href="https://www.npmjs.com/package/sparser">NPM</a></li></ul><span class="clear"></span></div><div id="content"><h1><span>Sparser</span>Intoduction To Parsers</h1>
<div class="section"><h2 id="terminology">Terminology</h2>
<p>Let's define the niche terms so that the wordy paragraphs further down make sense to normal people.  It is important to note that these terms come from the linguistic sciences of human spoken and written language, but they are adapted to apply to computer programming languages in nearly identical ways.</p>
<ul><li><strong>lexer</strong> - A lexer is simply a scanner. This means it is a small utlity that analyzes language as atomic fragments. With spoken language humans use lexical analysis to break down collections of sounds and form them into words. With written language humans use lexical analysis against letters, space, and punctuation to form words, statements, and sections. In computer programming lexers are utilities that analyze atomic units of input, typically characters from text strings, and form larger pieces with more precise meaning like keywords, comments, and numbers.</li><li><strong>lexeme</strong> - A language rule necessary to make use of the given language. In some spoken languages tone is an important rule that imposes unique meaning and context upon words. In various other spoken languages rhythm, social context, speed of delivery, gender, and other rules impose qualities upon language that influences how the language is deciphered. The necessary rules often change from language to language. This concept applies very directly to programming languages. As an example, a language like XML makes use of concepts and structures not available or relevant to a language like JavaScript.</li><li><strong>lexicon</strong> - An inventory of various language rules, <em>lexemes</em>, necessary to make sense of a communication. The list of such rules for a given language is a language's lexicon. Lexicon's influence how a language is used and how thoughts are expressed in the given language.</li><li><strong>parser</strong> - A parser is a higher order utility that typically uses a lexer to gather pieces of a language and puts those pieces into categories and structures to form knowledge. In spoken language a lexer may put sounds together to form words, but a parser puts those words together to form a thought. A parser has to account for the order, structure, and context of its language pieces in accordance with a langauge's lexicon for that langauge to make sense. Consider these two statements as examples: <em>My dog house is rough.</em> against <em>My house dog is rough.</em> The only difference is the order of two words, which provides very different meaning. The lexical analysis for those two statements would be identical, but they are parsed differently.</li><li><strong>syntax</strong> - Syntax is a collection of rules that impose constraints on parsing. As an analogy syntax is to a parser as lexeme is to a lexer. Syntax helps keep the expressiveness of a language regular so that a receiver may better understand the communication of a transmitter or so that a transmitter may have higher confidence their message is properly interpreted by a receiver. For programming languages syntax determines if an instance of code makes sense to a computer's parser as it determines how the parser interprets the code, throws an error, or if the computer is allowed to guess at instructions.</li><li><strong>grammar</strong> - Grammars are higher order rules that define structure and context. In written language grammar typically refers to word order, conjugation</li><li><strong>compiler</strong> - A compiler transforms an artifact expressed in one language into a different language. Compilers are higher order utilities that frequently use parsers, but otherwise have nothing to do with parsing. This term is only included because many software developers uses these terms interchangeably, incorrectly, and cannot tell the difference. <strong>A compiler is not a parser and is not related to parsing.</strong></li></ul></div><div class="section"><h2 id="lexical-scope">Lexical Scope</h2>
<p>A well known computer science term, <em>lexical scope</em>, was not included in the definitions above. This is intentional. Scope is the area of availability for a given reference or code unit. That has everything to do with where things are declared in code, how they are declarared, and from where they are referenced. Scope resolution, even if similarly named, has nothing to do with parsing or lexical analysis. The names are similar because they come from similar sources in linguistics research.</p>
<p>Lexical scope is a type of scope mechanism in language design where by a scope is a structure that could be referenced as though it were an atomic unit. The benefit of that is that the very boundaries that define the availability of a reference can be passed between code units like any other reference and it can contain child scopes no different than a structure containing child references. This feature is called <em>lexical scope</em> similar to <em>lexical analysis</em>, because the idea is to analyze the code in a lexical manner and compose certain structures as though they were semi-atomic word units much like phrases in a spoken statement whereby context is extended to the represented collection of pieces. This feature is not unique programming as evidenced by languages like Swahili whose grammars emphasize extensible semantics.</p>
</div><div class="section"><h2 id="blurry-boundaries">Blurry Boundaries</h2>
<p>Don't get too married to the definitions above.  The boundaries of different levels in the process of parsing and compiling vary wildly by application.  In the case of this application the lexers actually complete all the lexical analysis and half the parsing step, according the definitions above.  The lexer files analyze, describe, and in some cases even modify the produced tokens.  The remainder of the parsing step, structure and context, is abstracted away and fully automated by the application logic as determined by the identified types for a given parsed token.</p>
</div><div class="section"><h2 id="what-parsing-gets-you">What Parsing Gets You</h2>
<p>Parsing decomposes a large substance into small usable pieces another system can use whether it is reading written language, understanding speech, or making use of computer programming code.  Common applications that immediately benefit from parsers are applications dedicated to analyzing code: compilers (translators), linters, code beautifiers, minifiers, and so forth.</p>
</div></div><div id="blobs"><span id="svg_left"></span><span id="svg_right"></span><div></div></div><script src="/js/website.js" type="application/javascript"></script></body></html>