/*global ace*/
/*jshint laxbreak: true*/
/*jslint for: true*/
/*****************************************************************************
 This is written by Austin Cheney on 3 Mar 2009.

 Please see the license.txt file associated with the Pretty Diff
 application for license information.
 ****************************************************************************/
if ((/^http:\/\/((\w|-)+\.)*prettydiff\.com/).test(location.href) === true || location.href.indexOf("www.prettydiff.com") > -1) {
    let loc = location.href.replace("http", "https").replace("https://www.", "https://");
    location.replace(loc);
}
(function dom_init() {
    "use strict";
    const id = function dom_id(x) {
        if (document.getElementById === undefined) {
            return;
        }
        return document.getElementById(x);
    }, page = (function dom__dataPage() {
        const divs = document.getElementsByTagName("div");
        if (divs.length === 0) {
            return null;
        }
        return divs[0];
    }()), textarea = {
        codeIn: id("input"),
        codeOut: id("output"),
    }, aceStore = {
        codeIn: {},
        codeOut: {},
        height: 0
    }, method = {
        app: {},
        event: {}
    }, data = {
        commentString: [],
        langvalue: ["javascript", "javascript", "JavaScript"],
        mode: "diff",
        settings: {
            report: {
                code: {},
                feed: {},
                stat: {}
            }
        },
        tabtrue: false,
        zIndex: 0
    }, report = {
        code: {
            body: null,
            box: id("codereport")
        },
        feed: {
            body: null,
            box: id("feedreport")
        },
        stat: {
            body: null,
            box: id("statreport")
        }
    }, test = {
        // delect if Ace Code Editor is supported
        ace: (location.href.toLowerCase().indexOf("ace=false") < 0 && typeof ace === "object"),
        // get the lowercase useragent string
        agent: (typeof navigator === "object")
            ? navigator
                .userAgent
                .toLowerCase()
            : "",
        // test for standard web audio support
        audio: ((typeof AudioContext === "function" || typeof AudioContext === "object") && AudioContext !== null)
            ? new AudioContext()
            : null,
        // delays the toggling of test.load to false for asynchronous code sources
        delayExecution: false,
        // am I served from the Pretty Diff domain
        domain: (location.href.indexOf("prettydiff.com") < 15 && location.href.indexOf("prettydiff.com") > -1),
        // If the output is too large the report must open and minimize in a single step
        filled: {
            code: false,
            feed: false,
            stat: false
        },
        // test for support of the file api
        fs: (typeof FileReader === "function"),
        // stores keypress state to avoid execution of event.execute from certain key
        // combinations
        keypress: false,
        keysequence: [],
        // supplement to ensure keypress is returned to false only after other keys
        // other than ctrl are released
        keystore: [],
        // some operations should not occur as the page is initially loading
        load: true,
        // whether to save things locally
        store: (id("localStorage-no") !== null && id("localStorage-no").checked === true)
            ? false
            : true,
        // supplies alternate keyboard navigation to editable text areas
        tabesc: []
    }, load = function dom_load() {
        const pages = (page === null || page === undefined || page.getAttribute("id") === null)
            ? ""
            : page.getAttribute("id"), security = function dom_load_security() {
            const scripts = document.getElementsByTagName("script"), exclusions = [
                "js/webtool.js",
                "browser-demo.js",
                "node_modules/ace-builds"
            ], len = scripts.length, exlen = exclusions.length;
            let a = 0, b = 0, src = "";
            // this prevents errors, but it also means you are executing too early.
            if (len > 0) {
                do {
                    src = scripts[a].getAttribute("src");
                    if (src === null) {
                        break;
                    }
                    if (src.indexOf("?") > 0) {
                        src = src.slice(0, src.indexOf("?"));
                    }
                    b = 0;
                    do {
                        if (src.indexOf(exclusions[b]) > -1) {
                            break;
                        }
                        b = b + 1;
                    } while (b < exlen);
                    if (b === exlen) {
                        break;
                    }
                    a = a + 1;
                } while (a < len);
                if (a < len) {
                    let warning = document.createElement("div");
                    warning.setAttribute("id", "security-warning");
                    warning.innerHTML = `<h1>Warning</h1><h2>This page contains unauthorized script and may be a security risk.</h2><code>${(src === null) ? scripts[a].innerHTML : src}</code>`;
                    document.getElementsByTagName("body")[0].insertBefore(warning, document.getElementsByTagName("body")[0].firstChild);
                }
            }
        };
        if (pages === "webtool") {
            let a = 0, x, inputs, selects, buttons, inputsLen = 0, idval = "", name = "", type = "", parent;
            const aceApply = function dom_load_aceApply(nodeName, maxWidth) {
                const div = document.createElement("div"), node = textarea[nodeName], parent = node.parentNode.parentNode, labels = parent.getElementsByTagName("label"), label = labels[labels.length - 1], attributes = node.attributes, p = document.createElement("p"), dollar = "$", len = attributes.length;
                let a = 0, edit = {};
                do {
                    if (attributes[a].name !== "rows" && attributes[a].name !== "cols" && attributes[a].name !== "wrap") {
                        div.setAttribute(attributes[a].name, attributes[a].value);
                    }
                    a = a + 1;
                } while (a < len);
                label.parentNode.removeChild(label);
                p.appendChild(label);
                p.setAttribute("class", "inputLabel");
                parent.appendChild(p);
                parent.appendChild(div);
                parent.removeChild(node.parentNode);
                if (maxWidth === true) {
                    div.style.width = "100%";
                }
                div.style.fontSize = "1.4em";
                edit = ace.edit(div);
                textarea[nodeName] = div.getElementsByTagName("textarea")[0];
                edit[`${dollar}blockScrolling`] = Infinity;
                if (nodeName === "codeIn") {
                    const slider = document.createElement("span"), span = document.createElement("span"), p = document.createElement("p"), description = "Slide this control left and right to adjust the 'options.wrap' value for word wrapping the code.";
                    p.innerHTML = description;
                    p.setAttribute("id", "ace-slider-description");
                    p.style.display = "none";
                    span.innerHTML = `<button title="${description}" aria-describedby="ace-slider-description">\u25bc</button>`;
                    slider.appendChild(span);
                    slider.appendChild(p);
                    slider.setAttribute("id", "slider");
                    span.onmousedown = method.event.aceSlider;
                    parent.insertBefore(slider, div);
                }
                return edit;
            }, aces = function dom_load_aces(event) {
                const el = event.srcElement || event.target, elId = el.getAttribute("id"), acedisable = function dom_load_aces_acedisable() {
                    let addy = "", loc = location
                        .href
                        .indexOf("ace=false"), place = [], symbol = "?";
                    method.app.options(event);
                    if (elId === "ace-yes" && loc > 0) {
                        place = location
                            .href
                            .split("ace=false");
                        if (place[1].indexOf("&") < 0 && place[1].indexOf("%26") < 0) {
                            place[0] = place[0].slice(0, place[0].length - 1);
                        }
                        location.replace(place.join(""));
                    }
                    else if (elId === "ace-no" && loc < 0) {
                        addy = location.href;
                        addy = addy.slice(0, addy.indexOf("#") + 1);
                        if (location.href.indexOf("?") < location.href.length - 1 && location.href.indexOf("?") > 0) {
                            symbol = "&";
                        }
                        location.replace(`${addy + symbol}ace=false`);
                    }
                };
                if (el.checked === true) {
                    acedisable();
                }
            }, areaShiftUp = function dom_load_areaShiftUp(event) {
                if (event.keyCode === 16 && test.tabesc.length > 0) {
                    test.tabesc = [];
                }
                if (event.keyCode === 17 || event.keyCode === 224) {
                    data.tabtrue = true;
                }
            }, areaTabOut = function dom_load_areaTabOut(event) {
                const node = event.srcElement || event.target;
                let len = test.tabesc.length, esc = false, key = 0;
                key = event.keyCode;
                if (key === 17 || key === 224) {
                    if (data.tabtrue === false && (test.tabesc[0] === 17 || test.tabesc[0] === 224 || len > 1)) {
                        return;
                    }
                    data.tabtrue = false;
                }
                if (node.nodeName.toLowerCase() === "textarea") {
                    if (test.ace === true) {
                        if (node === textarea.codeOut) {
                            esc = true;
                        }
                    }
                    if (node === textarea.codeIn) {
                        esc = true;
                    }
                }
                if (esc === true) {
                    esc = false;
                    data.tabtrue = false;
                    if ((len === 1 && test.tabesc[0] !== 16 && key !== test.tabesc[0]) || (len === 2 && key !== test.tabesc[1])) {
                        test.tabesc = [];
                        return;
                    }
                    if (len === 0 && (key === 16 || key === 17 || key === 224)) {
                        test
                            .tabesc
                            .push(key);
                        return;
                    }
                    if (len === 1 && (key === 17 || key === 224)) {
                        if (test.tabesc[0] === 17 || test.tabesc[0] === 224) {
                            esc = true;
                        }
                        else {
                            test
                                .tabesc
                                .push(key);
                            return;
                        }
                    }
                    else if (len === 2 && (key === 17 || key === 224)) {
                        esc = true;
                    }
                    else if (len > 0) {
                        test.tabesc = [];
                    }
                    if (esc === true) {
                        if (len === 2) {
                            //back tab
                            if (node === textarea.codeIn) {
                                id("inputfile").focus();
                            }
                            else if (node === textarea.codeOut) {
                                textarea
                                    .codeIn
                                    .focus();
                            }
                        }
                        else {
                            //forward tab
                            if (node === textarea.codeOut) {
                                id("button-primary")
                                    .getElementsByTagName("button")[0]
                                    .focus();
                            }
                            else if (node === textarea.codeIn) {
                                textarea
                                    .codeOut
                                    .focus();
                            }
                        }
                        if (test.tabesc[0] === 16) {
                            test.tabesc = [16];
                        }
                        else {
                            test.tabesc = [];
                        }
                    }
                }
                method
                    .event
                    .sequence(event);
            }, backspace = function dom_load_backspace(event) {
                const bb = event.srcElement || event.target;
                if (event.keyCode === 8) {
                    if (bb.nodeName === "textarea" || (bb.nodeName === "input" && (bb.getAttribute("type") === "text" || bb.getAttribute("type") === "password"))) {
                        return true;
                    }
                    return false;
                }
                if (event.type === "keydown") {
                    method.event.sequence(event);
                }
                return true;
            }, clearComment = function dom_load_clearComment() {
                const comment = id("commentString");
                localStorage.setItem("commentString", "[]");
                data.commentString = [];
                if (comment !== null) {
                    comment.innerHTML = "/*prettydiff.com \u002a/";
                }
            }, feeds = function dom_load_feeds(el) {
                const feedradio = function dom_load_feeds_feedradio(event) {
                    let parent, aa, radios;
                    const elly = event.srcElement || event.target, item = elly.parentNode, radio = item.getElementsByTagName("input")[0];
                    parent = item.parentNode;
                    radios = parent.getElementsByTagName("input");
                    aa = radios.length - 1;
                    do {
                        parent = radios[aa].parentNode;
                        parent.removeAttribute("class");
                        radios[aa].checked = false;
                        aa = aa - 1;
                    } while (aa > -1);
                    radio.checked = true;
                    radio.focus();
                    item.setAttribute("class", "active-focus");
                    method.app.options(event);
                    event.preventDefault();
                    return false;
                };
                el.onfocus = feedradio;
                el.onblur = function dom_load_feeds_feedblur() {
                    const item = el.parentNode;
                    item.setAttribute("class", "active");
                },
                    el.onclick = feedradio;
                parent = x.parentNode;
                parent = parent.getElementsByTagName("label")[0];
                parent.onclick = feedradio;
            }, feedsubmit = function dom_load_feedsubmit() {
                let a = 0;
                const datapack = {}, namecheck = (localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null)
                    ? JSON.parse(localStorage.getItem("settings"))
                    : {}, radios = id("feedradio1")
                    .parentNode
                    .parentNode
                    .getElementsByTagName("input"), text = (id("feedtextarea") === null)
                    ? ""
                    : id("feedtextarea")
                        .value, email = (id("feedemail") === null)
                    ? ""
                    : id("feedemail")
                        .value, xhr = new XMLHttpRequest(), sendit = function dom_load_feedsubmit_sendit() {
                    const node = id("feedintro");
                    xhr.withCredentials = true;
                    xhr.open("POST", "https://prettydiff.com:8000/feedback/", true);
                    xhr.setRequestHeader("Content-type", "application/json; charset=utf-8");
                    xhr.send(JSON.stringify(datapack));
                    report
                        .feed
                        .box
                        .getElementsByTagName("button")[1]
                        .click();
                    if (node !== null) {
                        node.innerHTML = "Please feel free to submit feedback about Pretty Diff at any time by answering t" +
                            "he following questions.";
                    }
                };
                if (id("feedradio1") === null || namecheck.knownname !== data.settings.knownname) {
                    return;
                }
                a = radios.length - 1;
                if (a > 0) {
                    do {
                        if (radios[a].checked === true) {
                            break;
                        }
                        a = a - 1;
                    } while (a > -1);
                }
                if (a < 0) {
                    return;
                }
                datapack.comment = text;
                datapack.email = email;
                datapack.name = data.settings.knownname;
                datapack.rating = a + 1;
                datapack.settings = data.settings;
                datapack.type = "feedback";
                sendit();
            }, file = function dom_load_file(event) {
                const input = event.srcElement || event.target;
                let a = 0, id = "", files, textareaEl, parent, reader, fileStore = [], fileCount = 0;
                id = input.getAttribute("id");
                files = input.files;
                if (test.fs === true && files[0] !== null && typeof files[0] === "object") {
                    if (input.nodeName === "input") {
                        parent = input.parentNode.parentNode;
                        textareaEl = parent.getElementsByTagName("textarea")[0];
                    }
                    const fileLoad = function dom_event_file_onload(event) {
                        const tscheat = "result";
                        fileStore.push(event.target[tscheat]);
                        if (a === fileCount) {
                            if (test.ace === true) {
                                if (id === "outputfile") {
                                    aceStore
                                        .codeOut
                                        .setValue(fileStore.join("\n\n"));
                                    aceStore
                                        .codeOut
                                        .clearSelection();
                                }
                                else {
                                    aceStore
                                        .codeIn
                                        .setValue(fileStore.join("\n\n"));
                                    aceStore
                                        .codeIn
                                        .clearSelection();
                                }
                            }
                            else {
                                textarea.codeIn.value = fileStore.join("\n\n");
                            }
                            if (options.mode !== "diff") {
                                method
                                    .event
                                    .execute();
                            }
                        }
                    };
                    fileCount = files.length;
                    do {
                        reader = new FileReader();
                        reader.onload = fileLoad;
                        reader.onerror = function dom_event_file_onerror(event) {
                            if (textareaEl !== undefined) {
                                textareaEl.value = `Error reading file:\n\nThis is the browser's description: ${event.error.name}`;
                            }
                            fileCount = -1;
                        };
                        if (files[a] !== undefined) {
                            reader.readAsText(files[a], "UTF-8");
                        }
                        a = a + 1;
                    } while (a < fileCount);
                    if (options.mode !== "diff") {
                        method
                            .event
                            .execute();
                    }
                }
            }, fixHeight = function dom_load_fixHeight() {
                const input = id("input"), output = id("output"), headlineNode = id("headline"), height = window.innerHeight || document.getElementsByTagName("body")[0].clientHeight;
                let math = 0, headline = 0;
                if (headlineNode !== null && headlineNode.style.display === "block") {
                    headline = 3.8;
                }
                if (test.ace === true) {
                    math = (height / 14) - (15.81 + headline);
                    aceStore.height = math;
                    if (input !== null) {
                        input.style.height = `${math}em`;
                        aceStore
                            .codeIn
                            .setStyle(`height:${math}em`);
                        aceStore
                            .codeIn
                            .resize();
                    }
                    if (output !== null) {
                        output.style.height = `${math}em`;
                        aceStore
                            .codeOut
                            .setStyle(`height:${math}em`);
                        aceStore
                            .codeOut
                            .resize();
                    }
                }
                else {
                    math = (height / 14.4) - (15.425 + headline);
                    if (input !== null) {
                        input.style.height = `${math}em`;
                    }
                    if (output !== null) {
                        output.style.height = `${math}em`;
                    }
                }
            }, indentchar = function dom_load_indentchar() {
                const insize = id("option-indent_size"), inchar = id("option-indent_char"), tabSizeNumber = (insize === null || isNaN(Number(insize.value)) === true)
                    ? 4
                    : Number(insize.value), tabSize = (tabSizeNumber < 1)
                    ? 4
                    : tabSizeNumber;
                if (test.ace === true) {
                    if (inchar !== null && inchar.value === " ") {
                        aceStore
                            .codeIn
                            .getSession()
                            .setUseSoftTabs(true);
                        aceStore
                            .codeOut
                            .getSession()
                            .setUseSoftTabs(true);
                        aceStore
                            .codeIn
                            .getSession()
                            .setTabSize(tabSize);
                        aceStore
                            .codeOut
                            .getSession()
                            .setTabSize(tabSize);
                    }
                    else {
                        aceStore
                            .codeIn
                            .getSession()
                            .setUseSoftTabs(false);
                        aceStore
                            .codeOut
                            .getSession()
                            .setUseSoftTabs(false);
                    }
                }
            }, insize = function dom_load_insize() {
                const insize = id("option-indent_size"), tabSizeNumber = (insize === null || isNaN(Number(insize.value)) === true)
                    ? 4
                    : Number(insize.value), tabSize = (tabSizeNumber < 1)
                    ? 4
                    : tabSizeNumber;
                if (test.ace === true) {
                    aceStore
                        .codeIn
                        .getSession()
                        .setTabSize(tabSize);
                    aceStore
                        .codeOut
                        .getSession()
                        .setTabSize(tabSize);
                }
            }, modes = function dom_load_modes(event) {
                const elly = event.target || event.srcElement, mode = elly.getAttribute("id").replace("mode", "");
                method.event.modeToggle(mode);
                method.app.options(event);
            }, numeric = function dom_load_numeric(event) {
                const el = event.srcElement || event.target;
                let val = el.value, negative = (/^(\s*-)/).test(val), split = val.replace(/\s|-/g, "").split(".");
                if (split.length > 1) {
                    val = `${split[0].replace(/\D/g, "")}.${split[1].replace(/\D/, "")}`;
                }
                else {
                    val = split[0].replace(/\D/g, "");
                }
                if (negative === true) {
                    val = `-${val}`;
                }
                el.value = val;
                if (el === id("option-indent_char")) {
                    indentchar();
                }
                else if (el === id("option-indent_size")) {
                    insize();
                }
                if (test.load === false) {
                    method.app.options(event);
                }
            }, prepBox = function dom_load_prepBox(boxName) {
                if (report[boxName].box === null || (test.domain === false && boxName === "feed")) {
                    return;
                }
                const jsscope = id("option-jsscope"), buttonGroup = report[boxName]
                    .box
                    .getElementsByTagName("p")[0], title = report[boxName]
                    .box
                    .getElementsByTagName("h3")[0]
                    .getElementsByTagName("button")[0], filedrop = function dom_load_prepBox_filedrop(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    file(event);
                }, filenull = function dom_load_prepBox_filenull(event) {
                    event.stopPropagation();
                    event.preventDefault();
                };
                if (test.fs === true) {
                    report[boxName].box.ondragover = filenull;
                    report[boxName].box.ondragleave = filenull;
                    report[boxName].box.ondrop = filedrop;
                }
                report[boxName].body.onmousedown = function dom_load_prepBox_top() {
                    method.app.zTop(report[boxName].body.parentNode);
                };
                parent = title.parentNode;
                title.onmousedown = method.event.grab;
                title.ontouchstart = method.event.grab;
                title.onfocus = method.event.minimize;
                title.onblur = function dom_load_prepBox_blur() {
                    title.onclick = null;
                };
                if (data.settings.report[boxName] === undefined) {
                    data.settings.report[boxName] = {};
                }
                if (boxName === "code" && jsscope !== null && jsscope[jsscope.selectedIndex].value === "report" && buttonGroup.innerHTML.indexOf("save") < 0) {
                    if (test.agent.indexOf("firefox") > 0 || test.agent.indexOf("presto") > 0) {
                        let saveNode = document.createElement("a");
                        saveNode.setAttribute("href", "#");
                        saveNode.onclick = method.event.save;
                        saveNode.innerHTML = "<button class='save' title='Convert report to text that can be saved.' tabindex=" +
                            "'-1'>S</button>";
                        buttonGroup.insertBefore(saveNode, buttonGroup.firstChild);
                    }
                    else {
                        let saveNode = document.createElement("button");
                        saveNode.setAttribute("class", "save");
                        saveNode.setAttribute("title", "Convert report to text that can be saved.");
                        saveNode.innerHTML = "S";
                        buttonGroup.insertBefore(saveNode, buttonGroup.firstChild);
                    }
                }
                if (data.settings.report[boxName].min === false) {
                    buttonGroup.style.display = "block";
                    title.style.cursor = "move";
                    if (buttonGroup.innerHTML.indexOf("save") > 0) {
                        buttonGroup.getElementsByTagName("button")[1].innerHTML = "\u035f";
                        if (test.agent.indexOf("macintosh") > 0) {
                            parent.style.width = `${(data.settings.report[boxName].width / 10) - 8.15}em`;
                        }
                        else {
                            parent.style.width = `${(data.settings.report[boxName].width / 10) - 9.75}em`;
                        }
                    }
                    else {
                        buttonGroup.getElementsByTagName("button")[0].innerHTML = "\u035f";
                        if (test.agent.indexOf("macintosh") > 0) {
                            parent.style.width = `${(data.settings.report[boxName].width / 10) - 5.15}em`;
                        }
                        else {
                            parent.style.width = `${(data.settings.report[boxName].width / 10) - 6.75}em`;
                        }
                    }
                    if (data.settings.report[boxName].top < 15) {
                        data.settings.report[boxName].top = 15;
                    }
                    report[boxName].box.style.right = "auto";
                    report[boxName].box.style.left = `${data.settings.report[boxName].left / 10}em`;
                    report[boxName].box.style.top = `${data.settings.report[boxName].top / 10}em`;
                    report[boxName].body.style.width = `${data.settings.report[boxName].width / 10}em`;
                    report[boxName].body.style.height = `${data.settings.report[boxName].height / 10}em`;
                    report[boxName].body.style.display = "block";
                }
                if (boxName === "feed") {
                    id("feedsubmit").onclick = feedsubmit;
                }
            }, select = function dom_load_select(event) {
                const elly = event.target || event.srcElement;
                selectDescription(elly);
                method.app.options(event);
                if (elly.getAttribute("id") === "option-color") {
                    method.event.colorScheme(event);
                }
            }, selectDescription = function dom_load_selectDescription(el) {
                const opts = el.getElementsByTagName("option"), desc = opts[el.selectedIndex].getAttribute("data-description"), opt = el[el.selectedIndex], value = opt.value, parent = el.parentNode, span = parent.getElementsByTagName("span")[0];
                span.innerHTML = ` <strong>${value}</strong> \u2014 ${desc}`;
            }, textareablur = function dom_load_textareablur(event) {
                const el = event.srcElement || event.target, tabkey = id("textareaTabKey");
                if (tabkey === null) {
                    return;
                }
                tabkey.style.display = "none";
                if (test.ace === true) {
                    const item = el.parentNode;
                    item.setAttribute("class", item.getAttribute("class").replace(" filefocus", ""));
                }
            }, textareafocus = function dom_load_textareafocus(event) {
                const el = event.srcElement || event.target, tabkey = id("textareaTabKey"), aria = id("arialive");
                if (tabkey === null) {
                    return;
                }
                tabkey.style.zIndex = String(data.zIndex + 10);
                if (aria !== null) {
                    aria.innerHTML = tabkey.innerHTML;
                }
                if (options.mode === "diff") {
                    tabkey.style.right = "51%";
                    tabkey.style.left = "auto";
                }
                else {
                    tabkey.style.left = "51%";
                    tabkey.style.right = "auto";
                }
                tabkey.style.display = "block";
                if (test.ace === true) {
                    let item = el.parentNode;
                    item.setAttribute("class", `${item.getAttribute("class")} filefocus`);
                }
            };
            // prep default announcement text
            {
                const headline = id("headline"), headtext = (headline === null)
                    ? null
                    : headline.getElementsByTagName("p")[0], x = Math.random(), circulation = [
                    "Available in your editor with <a href=\"https://unibeautify.com/\">Unibeautify</a>",
                    "Updated to <a href=\"https://www.npmjs.com/package/prettydiff\">NPM</a>.",
                    "Check out the <a href=\"https://sparser.io/demo/\">parsing utility</a> that makes this possible.",
                    "Supporting <a href=\"documentation.xhtml#languages\">45 languages</a> as of version 101.0.11"
                ];
                if (headline !== null) {
                    headtext.innerHTML = circulation[Math.floor(x * circulation.length)];
                    if (location.href.indexOf("ignore") > 0) {
                        headline.innerHTML = "<h2>BETA TEST SITE.</h2> <p>Official Pretty Diff is at <a href=\"https://prettydiff.com/\">https://prettydiff.com/</a></p> <span class=\"clear\"></span>";
                    }
                }
            }
            // changing the default value of diff_format and complete_document for the browser tool
            {
                let el = document.getElementById("option-diff_format"), ops = el.getElementsByTagName("option"), sel, a = 0;
                options.diff_format = "html";
                sel = el;
                if (ops[0].innerHTML !== "html") {
                    do {
                        a = a + 1;
                    } while (a < ops.length && ops[a].innerHTML !== "html");
                }
                if (a < ops.length) {
                    sel.selectedIndex = a;
                }
            }
            // build the Ace editors
            if (test.ace === true) {
                const insize = id("option-indent_size"), tabSizeNumber = (insize === null || isNaN(Number(insize.value)) === true)
                    ? 4
                    : Number(insize.value), tabSize = (tabSizeNumber < 1)
                    ? 4
                    : tabSizeNumber;
                if (textarea.codeIn !== null) {
                    aceStore.codeIn = aceApply("codeIn", true);
                }
                if (textarea.codeOut !== null) {
                    aceStore.codeOut = aceApply("codeOut", true);
                }
                aceStore
                    .codeIn
                    .getSession()
                    .setTabSize(tabSize);
                aceStore
                    .codeOut
                    .getSession()
                    .setTabSize(tabSize);
            }
            x = id("ace-no");
            if (test.ace === false && x !== null && x.checked === false) {
                x.checked = true;
            }
            // preps stored settings
            // should come after events are assigned
            if (localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null) {
                if (localStorage.getItem("settings").indexOf(":undefined") > 0 && test.store === true) {
                    localStorage.setItem("settings", localStorage.getItem("settings").replace(/:undefined/g, ":false"));
                }
                data.settings = JSON.parse(localStorage.getItem("settings"));
                const keys = Object.keys(data.settings), keylen = keys.length;
                let a = 0, el, sel, name, opt, numb;
                do {
                    if (keys[a] !== "report" && keys[a] !== "knownname" && keys[a] !== "feedback") {
                        el = id(keys[a]) || id(data.settings[keys[a]]);
                        if (el !== null) {
                            name = el.nodeName.toLowerCase();
                            if (name === "select") {
                                sel = el;
                                sel.selectedIndex = data.settings[keys[a]];
                                opt = sel[sel.selectedIndex];
                                options[keys[a].replace("option-", "")] = opt.value;
                                if (keys[a] === "option-color") {
                                    method.event.colorScheme(null);
                                }
                            }
                            else {
                                if (keys[a] === "mode") {
                                    id(data.settings[keys[a]]).checked = true;
                                    options.mode = data.settings[keys[a]].replace("mode", "");
                                    method.event.modeToggle(options.mode);
                                }
                                else if (typeof data.settings[keys[a]] === "string" && data.settings[keys[a]].indexOf("option-true-") === 0) {
                                    id(data.settings[keys[a]]).checked = true;
                                    options[keys[a].replace("option-", "")] = true;
                                }
                                else if (typeof data.settings[keys[a]] === "string" && data.settings[keys[a]].indexOf("option-false-") === 0) {
                                    id(data.settings[keys[a]]).checked = true;
                                }
                                else if (keys[a].indexOf("option-") === 0) {
                                    if (id(keys[a]).getAttribute("data-type") === "number") {
                                        numb = Number(data.settings[keys[a]]);
                                        if (isNaN(numb) === false) {
                                            id(keys[a]).value = data.settings[keys[a]];
                                            options[keys[a].replace("option-", "")] = numb;
                                            if (test.ace === true && keys[a] === "option-wrap") {
                                                if (numb < 1) {
                                                    numb = 80;
                                                }
                                                aceStore.codeIn.setPrintMarginColumn(numb);
                                                aceStore.codeOut.setPrintMarginColumn(numb);
                                            }
                                        }
                                    }
                                    else {
                                        id(keys[a]).value = data.settings[keys[a]];
                                        options[keys[a].replace("option-", "")] = data.settings[keys[a]];
                                    }
                                    if (keys[a] === "option-indent_size") {
                                        insize();
                                    }
                                    else if (keys[a] === "option-indent_char") {
                                        indentchar();
                                    }
                                }
                                else if (id(data.settings[keys[a]]) !== null) {
                                    id(data.settings[keys[a]]).checked = true;
                                }
                            }
                        }
                    }
                    a = a + 1;
                } while (a < keylen);
                if (data.settings.report === undefined) {
                    data.settings.report = {
                        code: {},
                        feed: {},
                        stat: {}
                    };
                }
                if (data.settings.knownname === undefined && test.store === true) {
                    data.settings.knownname = `${Math
                        .random()
                        .toString()
                        .slice(2) + Math
                        .random()
                        .toString()
                        .slice(2)}`;
                    localStorage.setItem("settings", JSON.stringify(data.settings));
                }
            }
            else {
                data.settings.knownname = `${Math
                    .random()
                    .toString()
                    .slice(2) + Math
                    .random()
                    .toString()
                    .slice(2)}`;
            }
            if (options.diff === undefined) {
                options.diff = "";
            }
            if (localStorage.getItem("source") !== undefined && localStorage.getItem("source") !== null) {
                options.source = localStorage.getItem("source");
                if (test.ace === true) {
                    aceStore.codeIn.setValue(options.source);
                }
                else {
                    textarea.codeIn.value = options.source;
                }
            }
            if (localStorage.getItem("diff") !== undefined && localStorage.getItem("diff") !== null) {
                options.diff = localStorage.getItem("diff");
                if (options.mode === "diff") {
                    if (test.ace === true) {
                        aceStore.codeOut.setValue(options.diff);
                    }
                    else {
                        textarea.codeOut.value = options.diff;
                    }
                }
            }
            //  feedback dialogue config data (current disabled)
            if (data.settings.feedback === undefined) {
                data.settings.feedback = {};
                data.settings.feedback.newb = false;
                data.settings.feedback.veteran = false;
            }
            x = id("feedsubmit");
            if (x !== null) {
                x.onclick = feedsubmit;
            }
            // assigns event handlers to input elements
            inputs = document.getElementsByTagName("input");
            inputsLen = inputs.length;
            a = 0;
            do {
                x = inputs[a];
                type = x.getAttribute("type");
                idval = x.getAttribute("id");
                if (type === "radio") {
                    name = x.getAttribute("name");
                    if (id === data.settings[name]) {
                        x.checked = true;
                    }
                    if (idval.indexOf("feedradio") === 0) {
                        feeds(x);
                    }
                    else if (name === "mode") {
                        x.onclick = modes;
                    }
                    else if (name === "ace-radio") {
                        x.onclick = aces;
                    }
                    else {
                        x.onclick = method.app.options;
                    }
                }
                else if (type === "text") {
                    if (x.getAttribute("data-type") === "number") {
                        x.onkeyup = numeric;
                    }
                    else {
                        x.onkeyup = method.app.options;
                    }
                    if (data.settings[idval] !== undefined) {
                        x.value = data.settings[idval];
                    }
                    if (idval === "option-language" && options.mode !== "diff" && x.value === "text") {
                        x.value = "auto";
                    }
                }
                else if (type === "file") {
                    x.onchange = file;
                    x.onfocus = function dom_load_filefocus() {
                        x.setAttribute("class", "filefocus");
                    };
                    x.onblur = function dom_load_fileblur() {
                        x.removeAttribute("class");
                    };
                }
                a = a + 1;
            } while (a < inputsLen);
            // assigns event handlers to select elements
            selects = document.getElementsByTagName("select");
            inputsLen = selects.length;
            a = 0;
            if (inputsLen > 0) {
                do {
                    idval = selects[a].getAttribute("id");
                    if (idval === "option-color") {
                        if (data.settings["option-color"] !== undefined) {
                            selects[a].selectedIndex = Number(data.settings["option-color"]);
                            selectDescription(selects[a]);
                        }
                    }
                    else {
                        if (typeof data.settings[idval] === "number") {
                            selects[a].selectedIndex = data.settings[idval];
                            selectDescription(selects[a]);
                        }
                    }
                    selects[a].onchange = select;
                    a = a + 1;
                } while (a < inputsLen);
            }
            // assigns event handlers to buttons
            buttons = document.getElementsByTagName("button");
            inputsLen = buttons.length;
            a = 0;
            do {
                name = buttons[a].getAttribute("class");
                idval = buttons[a].getAttribute("id");
                if (name === null) {
                    if (buttons[a].value === "Execute") {
                        buttons[a].onclick = method.event.execute;
                    }
                    else if (idval === "resetOptions") {
                        buttons[a].onclick = method.event.reset;
                    }
                }
                else if (name === "minimize") {
                    buttons[a].onclick = method.event.minimize;
                }
                else if (name === "maximize") {
                    buttons[a].onclick = method.event.maximize;
                    parent = buttons[a].parentNode.parentNode;
                    if (data.settings[parent.getAttribute("id")] !== undefined && data.settings[parent.getAttribute("id")].max === true) {
                        buttons[a].click();
                    }
                }
                else if (name === "resize") {
                    buttons[a].onmousedown = method.event.resize;
                }
                else if (name === "save") {
                    buttons[a].onclick = method.event.save;
                }
                a = a + 1;
            } while (a < inputsLen);
            // preps the file inputs
            if (test.fs === false) {
                x = id("inputfile");
                if (x !== null) {
                    x.disabled = true;
                }
                x = id("outputfile");
                if (x !== null) {
                    x.disabled = true;
                }
            }
            // prep the floating GUI windows
            // should come after store settings are processed
            report.feed.body = (report.feed.box === null)
                ? null
                : report
                    .feed
                    .box
                    .getElementsByTagName("div")[0];
            report.code.body = (report.code.box === null)
                ? null
                : report
                    .code
                    .box
                    .getElementsByTagName("div")[0];
            report.stat.body = (report.stat.box === null)
                ? null
                : report
                    .stat
                    .box
                    .getElementsByTagName("div")[0];
            prepBox("feed");
            prepBox("code");
            prepBox("stat");
            // sets default configurations from URI query string
            // should come after all configurations are processed, so as to override
            if (typeof location === "object" && typeof location.href === "string" && location.href.indexOf("?") > -1) {
                let b = 0, c = 0, paramLen = 0, param = [], colors, lang = id("option-language"), source = "", diff = "";
                const color = id("option-color"), params = location
                    .href
                    .split("?")[1]
                    .split("&");
                if (color !== null) {
                    colors = color.getElementsByTagName("option");
                }
                paramLen = params.length;
                b = 0;
                do {
                    param = params[b].split("=");
                    if (param.length > 1) {
                        param[1] = param[1].toLowerCase();
                    }
                    else {
                        param.push("");
                    }
                    if (param[0] === "m" || param[0] === "mode") {
                        param[0] = "mode";
                        if (param[1] === "analysis" && id("modeanalysis") !== null) {
                            method
                                .event
                                .modeToggle("analysis");
                            id("modeanalysis").checked = true;
                        }
                        else if (param[1] === "beautify" && id("modebeautify") !== null) {
                            method
                                .event
                                .modeToggle("beautify");
                            id("modebeautify").checked = true;
                        }
                        else if (param[1] === "diff" && id("modediff") !== null) {
                            method
                                .event
                                .modeToggle("diff");
                            id("modediff").checked = true;
                        }
                        else if (param[1] === "minify" && id("modeminify") !== null) {
                            method
                                .event
                                .modeToggle("minify");
                            id("modeminify").checked = true;
                        }
                        else if (param[1] === "parse" && id("modeparse") !== null) {
                            method
                                .event
                                .modeToggle("parse");
                            id("modeparse").checked = true;
                        }
                        else {
                            params.splice(b, 1);
                            b = b - 1;
                            paramLen = paramLen - 1;
                        }
                    }
                    else if (param[0] === "s" || param[0] === "source") {
                        param[0] = "source";
                        source = param[1];
                    }
                    else if ((param[0] === "d" || param[0] === "diff") && textarea.codeOut !== null) {
                        param[0] = "diff";
                        diff = param[1];
                        if (test.ace === true && diff !== undefined) {
                            aceStore
                                .codeOut
                                .setValue(diff);
                            aceStore
                                .codeOut
                                .clearSelection();
                        }
                        else {
                            textarea.codeOut.value = diff;
                        }
                    }
                    else if ((param[0] === "l" || param[0] === "lang" || param[0] === "language") && lang !== null) {
                        param[0] = "lang";
                        if (param[1] === "text" || param[1] === "plain" || param[1] === "plaintext") {
                            param[1] = "text";
                            method
                                .event
                                .modeToggle("diff");
                        }
                        else if (param[1] === "js" || param[1] === "") {
                            param[1] = "javascript";
                        }
                        else if (param[1] === "markup") {
                            param[1] = "xml";
                        }
                        else if (param[1] === "jstl") {
                            param[1] = "jsp";
                        }
                        else if (param[1] === "erb" || param[1] === "ejs") {
                            param[1] = "html_ruby";
                        }
                        else if (param[1] === "tss" || param[1] === "titanium") {
                            param[1] = "tss";
                        }
                        lang.value = param[1];
                        if (test.ace === true && c > -1) {
                            if (param[1] === "vapor") {
                                aceStore
                                    .codeIn
                                    .getSession()
                                    .setMode("ace/mode/html");
                                aceStore
                                    .codeOut
                                    .getSession()
                                    .setMode("ace/mode/html");
                            }
                            else {
                                aceStore
                                    .codeIn
                                    .getSession()
                                    .setMode(`ace/mode/${param[1]}`);
                                aceStore
                                    .codeOut
                                    .getSession()
                                    .setMode(`ace/mode/${param[1]}`);
                            }
                        }
                        method.app.langkey({
                            sample: aceStore.codeIn.getValue(),
                            name: param[1]
                        });
                    }
                    else if (param[0] === "c" || param[0] === "color") {
                        param[0] = "color";
                        c = colors.length - 1;
                        do {
                            if (colors[c].innerHTML.toLowerCase() === param[1]) {
                                color.selectedIndex = c;
                                method
                                    .event
                                    .colorScheme(null);
                                break;
                            }
                            c = c - 1;
                        } while (c > -1);
                        if (c < 0) {
                            params.splice(b, 1);
                            b = b - 1;
                            paramLen = paramLen - 1;
                        }
                    }
                    else if (param[0] === "jsscope") {
                        param[1] = "report";
                        method
                            .app
                            .hideOutput(id("option-jsscope"));
                    }
                    else if (param[0] === "jscorrect" || param[0] === "correct" || param[0] === "fix") {
                        param[0] = "correct";
                        param[1] = "true";
                        x = id("option-true-correct");
                        if (x !== null) {
                            x.checked = true;
                        }
                    }
                    else if (param[0] === "html" || param[0] === "vapor") {
                        param[1] = "true";
                        if (lang !== null) {
                            lang.value = "html";
                        }
                        if (test.ace === true) {
                            aceStore
                                .codeIn
                                .getSession()
                                .setMode("ace/mode/html");
                            aceStore
                                .codeOut
                                .getSession()
                                .setMode("ace/mode/html");
                        }
                    }
                    else if (param[0] === "localstorage") {
                        if (param[1] === "false" || param[1] === "" || param[1] === undefined) {
                            test.store = false;
                            if (id("localStorage-no") !== null) {
                                id("localStorage-no").checked = true;
                            }
                        }
                        else {
                            test.store = true;
                            if (id("localStorage-yes") !== null) {
                                id("localStorage-yes").checked = true;
                            }
                        }
                    }
                    else if (options[param[0]] !== undefined) {
                        options[param[0]] = param[1];
                        if (id(`option-true-${param[0]}`) !== null) {
                            id(`option-true-${param[0]}`).checked = true;
                        }
                    }
                    b = b + 1;
                } while (b < paramLen);
                if (source !== "" && source !== undefined && source !== null) {
                    if (textarea.codeIn !== null) {
                        if (test.ace === true) {
                            aceStore
                                .codeIn
                                .setValue(source);
                            aceStore
                                .codeIn
                                .clearSelection();
                        }
                        else {
                            textarea.codeIn.value = source;
                        }
                        method
                            .event
                            .execute();
                    }
                }
            }
            // sets audio configuration
            if (test.audio !== null) {
                const audioString = [
                    "SUQzBAAAAAAAFlRFTkMAAAAMAAADTGF2ZjUyLjMxLjD/+9RkAA/wAABpAAAACAAADSAAAAEAAAGkAAAA",
                    "IAAANIAAAARMQU1FMy45OSAoYWxwaGEpVQA9wAChVSyrkSX4folg8BYiJjMKc1SuX4pepo4ETrVZqIv8",
                    "yVbycShK30LFEUoSgZEwWmjGlgnGrAwdrjrvkt5GpJlQtbjNmCpnFAUz040+FdsMdODIjEn9bVbUD/GH",
                    "rmrGxrYmFXK1CjhKYXw2h5lgR6aPs1CbmOaiPWFtYVaoVa0yq5QqI4TGK0iyKIgm5wLaygjEJOXtCFGr",
                    "IcBrUyhOE1jwVbirkaa5YDIOs/EmijlMokozg3hERLk0NcxSuGYIGOsmhxqBzcGdWKdhcnCPp8yrSaSq",
                    "XRijeP7/+9RkbgD3z2gkMfh7cAAADSAAAAEnEdL1rGsNwAAANIAAAAQkd04uTi7mduDmyRH7yWE9cnTt",
                    "acXJ6rlCjjaL2fYACDje3+kRAWpAcNLEell9dc63jCNp8rZuBKHoRk6Z9/I+ONSZSccFukZeBP02rMFH",
                    "jQkyEEYgYZYwDgpmUpp1ZqzJCKOXHKJ4CICIQayIcRgDiI0PIAJsFAKCmTJlmjKDkxUF4XEEMzDkTIh0",
                    "14eL+LFMCFMKHDhKP8rZejYv1CW5z8RBcimlFUpLETl9d0BlJ5eMiNQHlTITxMQHyYAwSUw3LlyLEf5U",
                    "juIYKtLLsfooAWupQ1Z+1KE6IphKH/h+maQsR1IDZ2u9alXudPK7TsQ5DcXsPvFnIglicqgeGJSztr7/",
                    "xu5YqUMPxxyKKn79eN2rG+wxRSuWSiMXrdSWYyt/JZdp7kYsVKR/3Lh+1KLG5XL6S9K43brv/TP5RyiW",
                    "blb/0fJXDmPZRjG7dSxUsTcbp60MTkMJiCmopmXHJyQFDC2ODQwlKqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqiqqqqqqVU11qbBQICDUy9HDGIzoqMNJThqI5pIM5jzj0cEMRxEMfY4tcErDTkDF",
                    "BAMdOPXB1o1ywxBU0J8wo43KcAjDQGE8FUwEHUm5q0jDmTMhQMPpjBmzTwzq3xLuap8euaZkCY1ibset",
                    "Bo8DKrxp/4LcpgCcjhpj3Gwkg0BI0v4HVuTFSHL3hAtscMoPtStTK938AQQxYsxJs06cwEQ4SoYFhcMZ",
                    "48GBWSPIsO/7KHE7AEMOVYABAyg4OAjpE2JMGEjLBkW0f0109JE3kNxDHGXo9oVrOAhAFNH/+9RkbgD6",
                    "UHTBy3rTcAAADSAAAAEpsYUZjm9twAAANIAAAAQOaV6/UeGoUDOIpMMnfx+qJm6PkPr/LQGKCOiYoUg6",
                    "y+H371VdeR7jdvOcsUsrrVYIzmd1ok/FFOS61qmppnGnuSCcsyK1EHUnX/3djmWGEstztfn0lPyfld6j",
                    "xz7Yyq53r163/1blLyvRZYdv2RAAgAxJGuGulUaOOBvI1GrYiZnRZqt0m+YWeR+J2sRH6dedvEZyaFGm",
                    "GEacZBnoSGYAKCMysvM+PjOiomSDWjACIBloWDDcwkkM6FAq9n22ZlZkbIUm9qoFFjEgZvAIHGDiZlKK",
                    "Z2OmMgpgZKYOPmAhosvGekJmQMabEmukZhyMa0xGpEyAlKJJBllInI9a12kBQQMSADGjQ1ElMDNzdXEx",
                    "0GMEEgceFo5e7C1J2miEoxWEW+3QiBBIbYOY/BHGMQZemWhRhQeYSMlBQ28skLiSzC9VfdJYwwKCpCBi",
                    "Y0Y0M0PDBAZfr8IjsueBYR5JTIWGNvEHjaSYqOgk4NKFk2BgACAtMhJB97/Lcjt08aYCLEQOJTGxA0pQ",
                    "MIHxCDhwSEBjB2dRWHH81R8y7Y5Uwwwp+/y7WdiZge7hvv7//3/73+Ws9y/Kx9Uo3k+vtrTEFNRTMuOT",
                    "kgKGFscGhhKaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qoEA4VA/MGQGMwdgfzB2BVMFYIcwcgczBgAhHAIjBPEKNPAvQxGQpjCXAsMBgBEwKABwQCWZeGZhIRmA",
                    "A6YADQFD5QDQoAy8oEB5MJjDwOYIY+VJx7EAo1mJSMYLHJkcECAKmBhAJAd9REATAAJMGA0w4HTCwZDA",
                    "ikCYXARiINmEGia9RhgMLR0eC4jAyIgJAKMtNLITDLUygGl9izxgYJmFgSYQTZw8HlUJjQVRUtLpcpcN",
                    "G685i/8VvrvUwBwJKpENEgstxFHbgCQxuVYRubl8ca64AoDEUSUHmFH/+9RkbgT6c2BIk9zjcgAADSAA",
                    "AAEnVYEdL3eNwAAANIAAAARYKB0xMD1M26RB9OP/GWSxt9HuZNFGgKLIiGCzsCmIAAA3VYk9MPJn3djO",
                    "KtIvEgRVrEIZNdhI14LzD4IFhIYOCgCEjXUfJa0td9Spfjl7X3L2rVeelfYAXEHAlKOQ2d59w//33djd",
                    "G7Cihg4BNYdxz8emAAAAbigYAYCgGBYA5QEKABGAUAAYBwCphsivmyOmCYl4HpgbAemCoAUYE4Ayz50w",
                    "RBwBBEhyLfKmLLFtgcCUcMNwfMBw9MA0OOVGvMThyMJxxDgwWHXrBTWn0dZ4b0hmn5JgMMAwAMBAbMYj",
                    "nOXiMMSgZIAfBQHmAQApQv+70apZZXdVOQs014wMBEwQEDBr9NopAwWGkdS8qhDpSVrT9SyE35yA2xqq",
                    "rMWCMWkgDn9fEEBwCksW1JrvIfjM5MMFghEkKgUxNMjCwCAoAa2wWOymNS54pZqNQS1pU0XlJgcGGRRU",
                    "amBJctCBosw6V7jA7OW6asnstYABAgCZiCJhQGiMCJ0Lef9+ZqeVCgfzGr3vf/+/+p7Wc8YMJhZYtKgN",
                    "cWxlu9F888s/uxmAQoEAMa1NVFoWzX0fa+pMQU1FMy45OSAoYWxwaGEpqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgCAAtSPpWqmHQBU",
                    "UiAAUwWgHTGeC+NlyGgwNAYTADB3MFoCNJ4aBJIACk4miqKrma+/jbIKCEC0wCANDAvASMIcA41uxLTB",
                    "XA1MDAAMKgDhgAik1ms3npyHKZrrLDAFANDARwsAOYEYCxgVCPGUsI+NBSmBWBCEAGA0CVoErkr21nVj",
                    "UMpMo9LAGBEAaNBYxtWT7B4MPD8s0mPFZVZymQuC5Tcj94UAjixYwKDDII5P+heVA4EqFXtOC+NKYMA0",
                    "FO0/0llrdFSlyDEegNqA4oCbiO1NupnKC/ze56z/+9RkbgP5zWBFq97jdAAADSAAAAEm/YUUr3utwAAA",
                    "NIAAAARpZVKX6MDA8xrdTLRRBIGHRC5LsuVa2yVx8vxzXwW0TsKoSNMCw0mDgQABYEFUBsxoK7wEAyWC",
                    "p87178f/us///6z0wCEZHqHv/9doZP+//94RgIDsp1Tcqy5VuUCSAFMlVnGQYTkQdBICZg6ATmNuLqZ0",
                    "NcJg5ghmDMEWGA2KUAYD0wEAAWvSwWAHa3DzAR4AdS0GgFGFADKYSAG5gZCemhkcMYJgLpgGgBGAIACs",
                    "MylpUWleEaraVtMAUAgwHQDkVTAcAXMF0S40LxQRIQIoARCABzAMA1GgJ45DkNrKXBcqKNvBClTK7MUA",
                    "bO7ALMMASZLDD90mGNcs6xexE3BLdp+tuwAAFicigQXDAwVKusXLvp2A0CHvf5/qe3HpADAXMD0MNCgU",
                    "bKySmn8844Oguvy//LtSA2kLZMgmXCF/MAAiBQWsNpmZ19LSbF/KtZVBkZWDghEIGKoYlgYHAzG1wUMH",
                    "7uAUByIDbeNBW/L7m95c/+7gMwUARvpuO6//40ak/n//9gAwDAZ3qazX+mGFKOC7Ly6UxBTUUzLjk5IC",
                    "hhbHBoYSmqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqhQAVpJeBWpuAyAGAAJDBfAnMk4Moyn7",
                    "tjCdDDMFoGACgPIWAEABfygL7GAAIiQPUjXw4ITAkADBwEDKEJzIMNDAZoDxr9zHIRhEDo6ATLY0/cCQ",
                    "5T3OyxiZEGAKGASBoLhYYdsGc3x0YUgeYGAEpuYFCIRCm7kYaOVAATDsT40AbTJGm4MhCYDNkceGSYhh",
                    "k57sQHNSyvoVABzqKu4pgkBBAAoGDwUAQw3U84zDYLgOGC099TDPEkAgRAgi1vdLnJE+2tmCiUG1APNO",
                    "fiX54fUEYQpY4XdU1SBmkAb/+9Rkbgn552BEg93rcAAADSAAAAElXYMXD3uNwAAANIAAAAQGjBQVTXMP",
                    "2/EIAP03ZJfHY4BSEPPywZ0raDgAMFAuM8xuMnhVEgLVXQKVUm6kBhYJV10F6nz/9RDLn563hdbgFw4G",
                    "gIiExb5vu0y7P5f/749BgEC8P02ZyzIOYKnlHUMQaECgA9MhlKFabwQAQYC4CpgaAZGLeDmavUgJgag0",
                    "BgVJgDAUmASAgYCgAqq7V1ASy6C0XgxfxZgRAImBIDAFAFjBXCJNR8WIwiwDRIERSafD5zlPd3Vpplny",
                    "EkwBACUARgEgEGCgEmZiQYRg3AOkwCTahcDxZ0P7svUTAL9n0mmWsGEYAwEEIzcjaKLKoELgtKjtrlvG",
                    "O4TldWYwAC1gzAANDgWYLn4LYQODaj12k53EqAAVBUsz5+pKLBdBEYxKQ+9U7b2ef/5IF4d1vK1Sy50U",
                    "NjP0WNpj4QCMLgWIzzAa9wgCD2dyuVaQZBbChQCmFK6ZBCI0DodYO/Uh7XL0FAPw1Q7/9Nyvf//ruoLM",
                    "Dh9dOoe5//udn94///psANAEK1lf95VCBeBKWmkxBTUUzLjk5IChhbHBoYSmqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqgEAAVgHSBlxdNJIwBwCzAAAeMFUCcxmgKzhzhIMR0CUeClM",
                    "BQCxuIqAYrAyuGDAEAEDgJKSkKgAzFiEAowUgPzBCBfMNIOM00h4jBkBhAwBQGAJTCZa60syxv0FO0ge",
                    "APMDMA2EJ9GD8PcZDQq4GAJDgH06DADAKatDcvoHLHgFqOVpxO4+zzmDIbmDpVHXIXmB4FhgBw1O3N5b",
                    "yxorDwGDoFEIBhYBgaA5gmx5lKGQsSpQAHO715YAICgAqDtLTRpVUEAgDQNMiRZNagZMHAQbWeu007aI",
                    "AXTjwx//+9Rkbg355WDFK97rdAAADSAAAAEl7YMUL3et0AAANIAAAATKvEFgwYBBhu1xjKBpUBAZBDkN",
                    "4VNF1pfPcxrVSEHREDYyERpoNRk2HTTqRDFUtq7EB0Gk4s88cN/tmfP//538wMFBQA0zDP/r9w9B+9f/",
                    "/7YgsC8tyt3ox6UpvIMcxbTEEJZQAAgNIgBExwYA0TARAgIgxeQzjouQ9MJwB4weALzAeA3MBUCYwAgA",
                    "4NFQAZuWuAID0iAsQAK9osEhj+C5iuEBkqyhuFa5iOLRgcDoMA4LAGsA3OWUlPhymeEmAIwvBADACYBA",
                    "mZOx4cknWZGisDgRXssKrX/+m+kFuCazP8KcxEB4xxIg7VIswSBUoDuXVL/NdzzpaRRdF1cokMIOFkwi",
                    "RM1bEEAAyUAhzPmsUpg4HiYBLd2mjTWDAoFzCwQTCh7zBIGTA8C35rbyznxwBygE+d3ZnpazdB0x5KEI",
                    "CgaGNP18InKJVVIQFSj7zeErHAPLLjoPGdI5DQol85t/GAS/9g0G1a8s92v11mML/973/xAoBd3uTXf/",
                    "e52FZ/ruvwtgoJm8v9v65yoD6anJTEFNRTMuOTkgKGFscGhhKaqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq",
                    "qqqqqqqqqqqqqqqqqiqAUYAAAqHAwAQA1KDADAfMBwB4wKwOzDiItPpsY4FGrGACCAYO4GY6BKpk4LDW",
                    "GLAmAMAtDZe1EdWwkAlMEQIgwGAVDB9CRNw0iAwpQKQ4HFPJKBxoEv51LlA+ih5gAAFGAQAwo2CgGTBv",
                    "EFNDMQQwVQNQwCwoAGLwEwBbySi2WAB6ahh0MAAZszIlAAMHQMMOUhOyywKgVBwzNffyG5+QV69Dcjzd",
                    "1kL4FQYMBgbMDWRNdRgMMQVHgAp7mHeN2HhLJgVgizLqZKowdCYWHMwmgkBOmYmgs5cUpKf/+9Rkbgf6",
                    "a2jEA97rcgAADSAAAAEoAZUSr3uNyAAANIAAAASWytsxWDN6pZ3NR+4VAbMHFNHjPTeGgQeOEUtyOF8S",
                    "IAoco61XpYAUiCowhC8hZEiKtEJtFdsXkOqYSBUoBrmFDd/GstiBu5Y//4U4kDrz0M3r9/phE1MXv5l+",
                    "o+EBLBdixZ///9d5e1/N5YWEO/Or7IhLmNIS0PTABAFAoAUVGAVDB4G2PAI7owXANzC5AlKALzAdAYgV",
                    "tl3MeTHR5LaAwAZoSb4qBYYNQK5gZADmDALGaqRPhhTAQmAuAYEAAq6ZbFoE52pGmPUxa0wLgAwEAsTA",
                    "PmBkLaZRg4RgHAgmAmAMoC1qDaS7aTJFgCLqlAkAg4aNJgIAAiECGAeSYiPxjcEmFQEzOGJXnYv3o4oQ",
                    "nunOsOw5OwoI5h/PmiwkJFOrhSd1hQg4RhwMT4byAGBgYJggDkQtMaWkTNaJUTjH27OY4DCsFxuV4V87",
                    "bgiMDmKmeazG4kWCgPSeUTcEt2GAk1Nqsjop+zLAqBDAI8NEIQMr6eD6EoDWzTSx4BUWWoH3d/X+zKWU",
                    "NJRc3916CwFIcpKT+fvb7OJKef+/7KDBIIZNqi1++/937mPviFn99V9LCYgpqKZlxyckBQwtjg0MJTVV",
                    "VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV",
                    "VUAAAQAEMBAIBBgEgALZMB8CclAbMCQG8xPx2TtdbFMUUGgwZAKQEAiYJgAokAwnUDQCwCAsicAgHjAO",
                    "AKMCgCBQAv2YEACBhVgqmDiCKYBgzBgEojmFIEAYAgCJf5kL/N3ormMy3cwCQCbo8AuYB4DYjABMCMBE",
                    "wwhIjQ6EJMCID4IBLQVaG2kjjdWbGgGZgcAEV0iqYFYBJgKAKmAYAGFCwnmxqGDIMiwfNNkVeYneQAma",
                    "RAIAAAEgCBgJkQYo/onmI71jIOI4OlDuH41JQYOgiYBAAmMuVlLLTBD/+9Rkbgf7aGlEK97rdgAADSAA",
                    "AAEt+akSD3utwAAANIAAAAQBULyAJjCJUzcUNQMCj+0Vzcdl4qBCebOVdLEgqMzw4B5IEhk4kBlmHQIA",
                    "UOAWUxKC0rxgBiwDkCgYE3fWS9zPC6IBAQGBwCWoMBgQRXTTyhwKAUyV/RCBAGACOoiSi5v9unOR9pTe",
                    "fr/4YAg7e+Rf/dVWZt3aBl//z4bMBglgWYxw/n/+G8sefhze7GjNac8EBgCaWIVAQBwD6toOBNMAQDYw",
                    "MQkDFiFMN1B9Aw6AUzA4CGCwEpCA0QgFjQCoUAMMCMAMDALFgCMtsYDAA4OAoBgAQKAMMJACAlAQMGkQ",
                    "E0xyljCrBxMEICRR9DR4+PNF68wkuWjS7ihECcQgMiwUBgKCsGR+IWYTYKgcBiDAGoTDUNy7B6mC0BIA",
                    "MYCADYkAODgJjAQAeMFBHMMSMOlh/MHAkHgP+H3IhyZ2wgUAAHACAQKAwOGAwPAQBTAABwMDxgozplwC",
                    "4oAojAGjpNbyaIFQnQEiIFGcKSFAMMDwVGgeJAdMGh3NewOC4D0+f7icbnnGXaNAOrGLABGYaV6YAAQY",
                    "AskYKBAPAKrFAlMvEoCJQIYAILgSEBeW+Tvb9O4UAcwVAgOAAxrD0WMgWAdkAXABR5EUmBRcxVCFENJ9",
                    "tML//9n2RsPq9/vKYAAQ89eZ///UCsEZflj/799AqB1Xsxe5/P7vm8//vP3zVvyibq1AADT7QzEACwGB",
                    "BMAUAQvSYFIFxgLACmLuGWZfLZJiLAsAkCkwTwCw4EUwLwGQQHBg8B4YAYFBUiBEVAowqA0wXAtxDBwQ",
                    "jDAdzFADjEw0T/gwDMIODEgQR4PC75IAaB+EU3ImNiICEU0IjDILAICgCAoxTNE5BJQxFAdMomIlzUH4",
                    "GlbbtvIqVBEW/MGwCMAQfMHQoMSgYKww0QWSsNwlWylicohtrcvEILS9BwMCAuYBA4GARbMDEcwzETZg",
                    "WFQCXSTrjbiUjkNkU1L+pqw6qun8nSDACUB8xWD/+9RkbYT7PWBFk93jcAAADSAAAAEuCX8czvNtwAAA",
                    "NIAAAASg7zCwLR0TUYnIoQ0tMcOA6NagAIA4NBYQA25kwLV2YXPRmoCtVZonRYbu3yGCpQMDFXqUGDQA",
                    "oJICYDjwHHQaYkcJg0chgOHgcxJlCOIcH2EvtNQwsXHnf5zSyVjSf5RFFzqzGEQ4sRuDkQ3bp5fHmxiE",
                    "BBwGpOcu9fxoQ6JwcBGvtfMEFxRx3epqnVQAAARhWFBQBRKApguA5g2EJjSH5gCHJmagIOUcx55oxfHs",
                    "w5C8Kg6YHgIYYg+DgkYLD5i8LmDAoYCDA4CDFwcMbEwxkGDAAoMoPo0YBDUVeNI4EVB4GUQNAZgMCo/o",
                    "HOulujzB6MqHNmYhE5j0qgIxmaUuaNZZsJFEI6MEhYWBCvFmOWytQdp6eiIheAw4IjJQeMFhEy0TDMBw",
                    "xh4OxESJTagveXQxD9WKrBmDkaqhhZiZqImJGhiYOYacg4vMRaxeUgoeJE23Cc+PJlqZMQEhAywiMUFz",
                    "JwEyowMOCmzAYkMmeg1CMbB30XksZ9GqgUNMLATBwEvmYQWGhEQOFi8CR7UkizKT0DVBEDTrqwtE8IBF",
                    "NR0DrovmIhZMCKwTAEHDGgYuWTQAshhwOkIwEwsNBoAYOKmNg4iCjICAxwMBwuruXOw5Egf993eCANwI",
                    "DdftyUhQVVgnZBR9s3KWsKAJEGS+v3GrL3bSWb3pn4r7lpiCmhAAqYAwAwOBNTWMBQEUhABMBUCUwQBK",
                    "TKuR+M+gXUwOgGgAAfAAKAVBgBxgCBIgA8wIAEwjBowIAIGgCVAuMFwwEQimEIkGQ4yGfd/mNBPGGo7G",
                    "CICGJgFJ5JtBQAoOeDILAqrEwIBEALBGYLDSKj+Z+oUYDAgBgTMNgVi6txgqCxZR5oEi7cxICyUBgaD6",
                    "Uxh0HhhYKBrQMhh6AiyzATgzsoQ2fJYGG25QSra1wGgZgokDg9aZl2YbuOmGE4hEUmTFj0iTU5kG4CTc",
                    "i7M2rCyUHCBjRewAxb9LJjz/+9Rkbg/7WWPHg93bcgAADSAAAAEuuZMcD3eNwAAANIAAAATAYKFCAKSM",
                    "MBDhoCSAf6JKxQQr0yoQAwGYoUA0xOtPjSicIIkVXJl7NQsBgIVlENMNT1HSYYAQqKlUTMJBzoiwLhRg",
                    "oG0BXhf0IDWWofDxE08EhZVCw4YEi4xQLMVKArOFAEUIhCCKOriklSXRlsKbQFAnpl8ov6r8nv//z/DK",
                    "WFYFTWL/ddxx////+pepEY0AEYAwBZKAKpWAQDTBeAcCgDJgshKGCu+QYrAwJg8gMDwQZgZAiggAAkAN",
                    "MEAEMMgiMAAHMAQQX0BQlEYSDwhGGwDmGwGGGgIG/D1GbANiQ/M9MSwHfNOMwUBYuixYKA8YGguUCuKA",
                    "MYUigBggMEwkMVQuOYi3MYQBGAtSKQbGgOMCQUMCASf1T6AwRAEwckA4eBMwWBYoGcZRYz8JUw9AIcC7",
                    "+xIiAkYEQAceAyYCPxSCgZMPDBOwxABTBFQNDhAODQKJxhcEgYTEQVDgAilZIAI2dsBgMGGEAYYYAQhB",
                    "RCKjNSEMrgxzAKUTEgKDgSXWGhIKgBvE3k47JCCiwIAuDEjRUHG9gqZcBphYPA4FxOlehoCV1LuehtCF",
                    "lYWDRgcGmRCAZwEZigGgYODQTbOoMVgSlhtQNQIAAJbpkURmBgs7ZhYShdRAYvEIZCAK1dqdn9Ze7xQD",
                    "IR2z//EaPf///9xJwmBtLrV////////047ZrG/fRJgRAUBmDgMwoAuIQJBIMACAQmAMBIYWc1BqIhomB",
                    "2CwDgXCqEMAgDCqAYLAsYIgKPAaggBwzxYwICAaH8MNAxaKcxMJA7HpwzfFox2CIeDswqCBX4IAcMAx5",
                    "4GHRGBQjDwtJvgUdwwGRwTRoKzuM0zF4HgMNhgkEJjOAip0jDBAHFMFThcLBGCSTAiAowdG0eEcwDBgw",
                    "vTg3NLEgDMxWGGZg4RlYAZWs5oMdEh0phCwIEjKRDJhCGFYY6yQwYOTJ4kEJoBIGWyCQGvaEiMCAYNph",
                    "rWMlggz/+9Rka437vGRGA93jcAAADSAAAAEuFZEaL3eNwAAANIAAAASgCjDglMIio2fNAEuRYylUTmAg",
                    "MVgowMLAUKiUU+FwGpKqVAELGIxUAgwlGEC4c5CotEQqDhUFY9bIHAZpNvBu7higlMciMwSB0dTEpkOK",
                    "kEx2LjAgCHg+v5BKmq+Kt7ZGnFQHpzgwWiICF4C04AXRmMDIjgIDP+1P//PiLpZm9jrn/QSfe///zqF/",
                    "yIM4/c1//v//693VdQ1Qiywp7XteoKToIAWEQB4QAwKgBGBIAYLBNGE4FcZIp8RsmgOGC4AsBgEjAXAB",
                    "FgPCAAEwLB5IgtmWABMOwRMHAWFgXCovjQuGAobmG4hmZXBgJlQ4EEwjAIAWnCAECEDxIQrxCEEGCwTQ",
                    "WYQAuNAeYAgUHAIcRMYY5haFQVMAAtAoDQyQAGBgUW5BIqHJYAUeABdRhCCAQJpIDxgWQZymPAkDJgsD",
                    "GDAwAQG44KB5CE6R9CYUkQEhANGA8JwMKhgAGO8AZuIBgIJGIwQYnDC5UsQuCiIQQcvAWI4sCk7DAQRI",
                    "kAYVEhIMzLMZMPCUDCIwEJAsI3sBIICoBMRgpm5CG3YfisDUSKAMVAxg0UG6AiChesgvLJr/qVl+s6RZ",
                    "bBhkRmNhMQAkCAwQFE4KRggROKTBF1HKfqqHAF24FCwEZ8YDFZhEFrNFQIYCUA8h2sp0vq5/7/CvOlBC",
                    "nuVuf/5f////sgB7a9/t7//f//1YVzQiAz81HfR1qjALAIJACSsDkwDgBTAvAkDgljBdAbMBABMxg2MT",
                    "aPF2MMYBUwNQHDA+B9MC8CIqAKmEwKCgKlYBGEAAGIIMgIERYNioMIUBMGAcYpiMbzcIYvFWYahgYPAC",
                    "IAAiYFAoRBmPEFFRCBRhQGw0G6jg6OFcCBKYYD0aQ2iYFggYVhcYFCaELQvEGheYIAgNAgCAWHhBMAw/",
                    "b9DkY2BeYGgWYBAkYurOZ0l0YaAALGQwqOgwCI1IGmIgRGodMPjdF+GTBYvM9iNn6zQpLjj/+9RkZQf7",
                    "8mRFg93jcAAADSAAAAEtLZEYr3eNwAAANIAAAASwAHSAJFccMYgC7HVWGCwfQIdA4UGDgInWFyOHNEYA",
                    "zemukCaRE4XEJk8EmISEuARgIwiJQ4OPqMB8FBQoBCXxjIoAo1oARUIHJySYXBz1iIAVMY+MAEiAM7dQ",
                    "GLeTtLQoXGAAiYUBYK8AcLUOYYDVey6zNKVs2dth8aERJMakAMALgGL20PH5MJMaMt93D9V0tBQARXKz",
                    "//z/3///6IAKkB/0P//7//+gWfnKAaCGz07+t/oQQEmAeAklQglCAJA4KowGwBTAsBlMQmdsyIRLDCyB",
                    "PMDUC4lBeMBkBUEANGEoJhcCAQDYwAYCCgMDBVgWFEDB2FgFMOAeOXTCNHSYMGALSkMEgsTggodBdTNz",
                    "2vmCQhKqQCYOhymSBAAMKRJNRZAMFQOCAxIAAAR+RoKBSRAORCgDQOMFwqMDgqdZVMDG8MgIqIwkOM2+",
                    "FoBC4YgAYqBofdYwaRxAAa78FYaMQAqSAwnmQxcyZUpiFfHNAASiQBAYwsGkzpAwYwWBosouPHAWOKXo",
                    "gFZjAFgQHiEVGBrMYfDhhYFCwTMXCEmCKyhwCFYUnBUQmLAE3rPTGYyKBOuosA82gVgcNUUgcDZDlVdm",
                    "hjE2KgpoC+RIDrHGhWYAMRoAklABgRXzb4fdUwrM9IgA+wABpkYKiQNpjASCT7duDZBB//+6jIhoayHv",
                    "////6///+DINVDh2p3/////p02e1RGB2nYu6zfPpTSoAIHAghACpKAEYAQBZgVgIiAEQwSQeTDInrNBo",
                    "PIwWgN3wEIJ5gTgJGAuAUBgRIgJMCwFMDwHDBsLWyswMAsmHsFAoYPiubGcqZvAyjAlEYSje/UsJAHGh",
                    "JXGKgyogPBjCjBoCRYDgqAI6IxzAtIyBqWogDQwgB16BAAZgCGJWDAJBEwFB8DBex1G0MNwrCwwLBMw0",
                    "Gw3WFkt0iuCBdEKgQMV0N9D6YQEBr1CAKjS9cVBGYfAp0AGBUUKHGCz/+9RkXw764WRGA93jcAAADSAA",
                    "AAEufZEWT3uNwAAANIAAAARIPAS2tkmGF4Rg1VZN2cFAewRUQgApoMxgpmGGgYYnFRisDOom4CgKXxoB",
                    "kbmIgBNEADMCBcSAVoqAc0W0QEQfLpWsfu0tSaZOli6YiPpQHx4IGBygaNEavpSutm1nLBu958RYTx0l",
                    "DxkAJ2qAYPBgYAjQDqw22f//8F9pTyLH/3r/1zPv/q6QAV1cvy/Wvz//+CW25NoevxkO6CuhlYBgIBEH",
                    "A5gIE8wAADjAKA1MB0AcwHgXDBRBTMuhns3NgODBFANMDIAYwCgKBYCIOAgMBEAAwGwEx4AQcAkQdQcm",
                    "BYDASBuC4BZYBcMR5IowfwfzAzASMAIBUwJwZlB3+fIwGACpGYBgFJgRAWpipSBcGIvQpqYDYHpmSiFC",
                    "gAJZIlBMEIGCaj/mAACKIgAQYAqYCwAosB66cBGCuA2BgU1RmAoJUYGwQ4KBXGi0FCkxWkHgeRFUoAc0",
                    "YBAhEGVXigcASp8vaYNS51wHjA0ZKFSqtXjM0t4iOAAxmBBI7yIGkkHC2YMHi8yxaTS4qMOi0woHwMKG",
                    "StyEiuGFPIqDkwEBpYkoYcFJEA35AoNNVOwHFB+wEBdc/e/rCgFYi3IwIgkOhZktObnGC02xtReS/jWj",
                    "WL0A4AM5HQ4PKZNJnJglTBiiDAFILrU9fv9uyBgFPcw1ZpdZXLFjv8+CRgSoiX+Svlabz1hh/4yPl15V",
                    "+2y+SXVujQBMAUAwwJgEAqAkxMlAxKAdTAmAuMG0AMxxEbjgUDBDhdwwG0wMQFDAuAfL8lAIGHoLGAgG",
                    "mA4CGE4FAID0dDDISAwNi04cBB3TEZomcBh8EaNRjMGb+R8gAZCxoJhCGYYFiczNTEUgQwKQCARhgIZ2",
                    "wVBhqGhg0BYsExjWNtV1QQArDGuAAPjBsFntj5i8HghCYwqB0xnMQ5rKkwFDkwuCAaFDEwAZGBBgXKIg",
                    "tA4WIJVAFYhDhlsJrGUzMH006sDwYIAMCBIipZT/+9RkZQ77wm/FC93jdAAADSAAAAEpJZEaD3eNwAAA",
                    "NIAAAAS4ZBoQOJK2ABEYBE6nGUyYcCCToAIRnyvGoQIEBcoHYGKcystDiPIaRlgamHg0mmWBMYPLw0Ap",
                    "SBhCb5a5jsXtWBQmm9cy3T0sqfBBgwaDQ4mmAwcCSeaEGCadGkAt2ex1YycJHuQGBxWZhBBZd3zBy2Mv",
                    "kdFpw2Butj//caIFAA5vbud6/rdTtDn/51CAAg4B39y238u+hjF7f1tb0k48uXf/9/rmH/+u///h//WB",
                    "wBgBALJgJSUAcCgHA4H0CAJmBGCAYiTjhmmBvmDyAEDARyoBG6EPEgDkQSGAoAtIGhSQvjRggHzcQYAh",
                    "hWE5vtCJo8EqnkpDAICGSdKgAPOmo0UvxSOEYWBCJAWMgCYBhEamrOYNA+XCCgJmBYQJxyth79soAQFm",
                    "BwCrAJSGAYZgYFQCAgwS5saMxhYCqsAyDR4g5lqQKHUSmuGAwUpexcvGCis4WZgWJmjgClcAgQMh5MRr",
                    "JUBaRdOIg4EFgHDSHCA1mKAC74iEhn9HFZKMDAYFEAwoEGCPwXVSeqjgPRxWALAMMIiKVvQIwIYyMxjU",
                    "IQSJAGQd5vP7cqVcjoYKB11dpgQGE2IZJAj/RvD93qq/h4AUgMDYsSEfVJGBB4ZHDyTbD4JhqWc/7krL",
                    "wyHvP//3/a2ff/SL6tXfrf//ukvf///G5T2vpSmIKaimZccnKk+zANAAMB0A8wCwBjAWAmMAYAgMBAME",
                    "gLAw7YbjJVEFMEkGYwTAMzAbBcMA4A8iA7DgRMGwXYaCgZMNQBMDQEHAhMCQOC4HDQ2GDI3GBf6GHgdm",
                    "FYBDQCCQXFAYQIoaLAkQgCYEBGn8oKKAAYJi0hyAgBmA5QmGTNGDAWDQOOQg5IEEbKmKEIBmAQNjISML",
                    "BoOmEYZDQtGBAMGEKPmGQ8GCgQBwxHRqYaAKcxggIggVAoNpvGDgcGAVf4hB4IASywsATDFjAx1BAWDg",
                    "4ABK2IIDYjCqIjAzCYpEiqD/+9Rkbg77mWTGA93jcAAADSAAAAEtYZMaL3ON0AAANIAAAAThwmCFCul2",
                    "ocKgMVkZg4ACQrDBsYND7d4gKAkSGqlBgAFiQVFgiooFQ8wR6EvTIqTMOglTseA89vv25W7CmbfFgHGN",
                    "SGEAYwOCRgoGAyGnpinmp+9344xRGhlceFQel2YMCRe8wEXAUGhIHK2Mla1Eef+bZQCB4P/v//4fqZge",
                    "//+i+hff+r//92J3v///BmcOTvdYC6V1BRDEgPC8hgDAJEgFxgKgJGCWA6YLwLRirqSGkSFSYHQLhgqg",
                    "Sg4GtvTATAJDiKJEEwADzAgjEQSIQyYVE4kcTEAyMBDUQhU/PnzFqAAxtLJKLjQkaoBQmDgsBgwEAN3w",
                    "gXEACEAJAABQHmShOdgq5goJoPhUJGFgIuAUBKeag4gDQ6HjA4MFACgMMQAcvSYfBJjIkneBGYKDRgQM",
                    "gUUkxBYgDQgFwsFgMp0MA4ChVS8VA4sYRwViADmKIaZjBoECIVDIkJkZjDgMTVGg+j6YCA6PQBALMxEO",
                    "QCAjAAACwGMmAoMT6HcsiYKEDKWBESBlCnRgEIllQggEgGU2WilcYQDRhhfA4lQEjDXzv0liG2VKIgEI",
                    "AYHA0hFzzBAGQ7DT+ySqRwhqWXrcQgZIiBGJkghMVhGAnLMKGwITSOyQadLbK15c+vGV9Qr+8/f1OV6V",
                    "ZsL1hgVQaJAaL6w/f5xNC+9z+Z99AtTi93u1VTAQAJDAHhQAkQANEoC48DsYIAHaSpiXh2mmqFItMwaQ",
                    "KzACAJAQDw8DyNBsyAC1zmAgaCg6AQaYBCKtYFDphgsGLz2eKhZsJJsoRnRyGhwIwKYEAAKBSWg8DDAw",
                    "kMGBsxOCwEMSENlmAwBnd14YeFUbAAHMPA2TJ6FYGCwIMAAMw2CwCDTCoaQUHjGGE8RCgGGA38ZwxOGK",
                    "k5hiSODZh4eOkIFFyqBvyJGo8IrTEh4SRFBBARmDfZuoWGBxkgYYWPGKhQkQphmLBjJAUJjJcCj8aESA",
                    "jCwcIR3/+9RkbI/7YmRGg9zbcAAADSAAAAEuHY8eD3NNyAAANIAAAAQwYkMP2A50AQAFhZfqGwAAkuy1",
                    "YcGhcAMIADCAFIpXpMcLaALMaI6mEB4cMJRudFJJB7caSYIQxGsgBjFlG0q4BApl5AYAIiACEhGXNPcx",
                    "nDSF2BgE4b9kpCAA4iE2HhR2MlEFrtIKA1TaAK1nHt2m7/9/HvKfWpJa7KK6io8BzF/Hv7wnJJdw32it",
                    "SJShTjpvK/oVvEgADA1A9MFEDswWwWzBtAdMG8Msx0SJzKdSDMssK0wIQPDAjANDAmzAPADMEsCUxKGT",
                    "BILGjKYhEpjEwmQSWZnUJu+CmwU+Mn8xuQTe/CMbgEDFhfLLCYODgOIhCDRAY+ERllHmtU+ZrKo8Swgz",
                    "gANmIwcCA8cYOYYUVwGAR8HCaNCooMgGwywYBZIjoXMBiMxCGTDoRHhCOgIIChkZZGbwyNDEAhwEwM9c",
                    "N0CAJkxBYgIMwNWREQ1NMDLE1CoYMAmNRLPq7NcGNgLOKzBKArGJ1DUUFXBIABkAsFMIeAxxzwwcZs+c",
                    "WCcJgJOwMfBAwGFkNS1BhRC0xkeELAUgTbAhQLDTJgQ5WfmkKCkE7LJ6W0kngtL8VAAkcZ4soIpkJEyq",
                    "GDh55JYyBLspEOHD8U2FR5sVo06MGNKAY8JVXlrOATsFkYMEln27wuTRicvZ93///f7y9nQKIZV6leHU",
                    "gq+FbWuS2PSHG9zm8dLyloCqAEwGwGjAiAnkoKBBMDcD0ABDkwqhtCGZGK6BEYSAMpgRgkmBeAyRAvmA",
                    "GCMYBIExhIBoWCoxeDgwOCgw1C0w6Hsw+Hk6WdAzRAooBMxWD0xuEkQAGMAHBTES1gMDIKAAYJAcVgyZ",
                    "BEuadM0Y4jYIwTcMwPB8x6A5FMhEAmBxawAA4mA13jAwKAqIhjqn5g0GqRIsHQoFZQNBhQG6XDsFtjAM",
                    "Fm7jAJBBhqMa5+gwHEAkDhkGBQODDNBFr4sUjokAkwAiw8pF+CVyOwsQ4wMAHTEgUlNBofD/+9Rka4z7",
                    "a2NHi93bdgAADSAAAAEswX8eL3dtwAAANIAAAARwGgcXBL7uIWmIgJfBi5ecyyGWC66xYNEAU3ZNdDNc",
                    "phoyRHZeJNEYBEbDgRJCaysWNYQqaK2I1flLssrS4IgAnA1TjgA0gs6LJZgIQmsianTN37EBAQWN8bBG",
                    "CGCCztmFhsNv6/KYxh4EWuZC/bC3mQNWpnh+8f/8rXflWadyANp2dndlWiW0tLj/8okYZFPf+PK0qBNi",
                    "APAwmAeCGAAUQIASAgZTAlApAoPhtxkWmECAIYIANhgYhbGCECSWxDATQKAMYHgyYHgEYcC8YQg+YCAg",
                    "YQEkYLCQccu2JA2GF6YKAuYJg4Ypg+FgAp3jJQJBIIKRMIQWS7MVw8MxW5BAPmBwWqVGFoJA4fTAcCQw",
                    "I1wwwYCgAngrIsODAcC6rGCwMjoKmKQCGBQXAocTAIJUgSECCoATrEQBCMQMIAjPSI824ByMMCYkWIPG",
                    "bDJgwwxlOtdhfYWDgcYBUIMHBj6WwwUUAgNBJhAwaaBEQk7KAEABQqRBgorcYuDokAeBEQsYcCL7MAHg",
                    "hGS4L8tZBxCYSGjgEChItEECxwBAYkEDQ+XYAoSJCjZsuZc6FANKIEDZsy8TCsNpSGCD4CLl0q3P7AEH",
                    "PrEi64FCAu0iMWEACRA5gwKLH+GDNF6zyOsojJEupXp4w7///////6uRdGq///Xt/////AcBz3Z9aYgp",
                    "tQSAUFwGDACBJMDkBgZAZMGIC0wPQrTmwJoMBMC0wZQWTB6FPMFoFMwZABgwCUKALDwLGDQemC4liwnD",
                    "REAkSh0jjozODCUAjCoDzCgQwuGhh+LSRN12zAoIzBcbVhQMQBhKAA8LJldQgOFsxFBQDB2YLjEYKBmg",
                    "HMEAPUiiCDQlDgRa+AhnMHiGNHovMXAuAwmGH4HmA4dGJwBkoAuNOGDoWGBgqFADioOAo2MkA88UvxkF",
                    "DgRUFSFMWCgLgEYCcOAkPmCxkyIwsEUNmmHeg+YeJBMBzBAHBxOMoh3/+9RkbgD71GTGA93jcAAADSAA",
                    "AAEvPYEa73eNwAAANIAAAAQeIZEDIYJiMYAARMfFMgSCDJIAOan9ohMPBYbmVzkYZEaAsMCbaBceGEAI",
                    "VhCwlOBDEbNJ5dILAGBxU1gIUybPn7lCCwcBzCoEEKBHhIk6qJd5hgFpHWYJdCXxp7hIArsNYi4qh0aA",
                    "4sBTEwsEidZbIsWcjS3mWocDAoKEgmiq/WeH//////0yT7Et6/6u////DbwkQan6L////t3nVrggAEAA",
                    "IYAQBJgHgPGASA8YF4AYJAAMDkDgwJwFDe9LVMDYG0qAUGEGF8AAIgEFqYDgAJABEIQGBoEGAIUmCwAJ",
                    "CiIMQgFDiOmTCwKigaDBUDBGHxhODJMBrXXuKoJGBghhwrmFINDxLmBwTAGJzAgDzD8BTBMASQNDCcEj",
                    "A0AQsAAIAd4woBr3oumAQBGHIPGu6zGQI2gIMzEQODAIjELh4ikLFZSAHTBUBQUMy2S/gBAB382CAHqy",
                    "NcStMvAwIHQgApENzAgZMXjcEAMGhQAgIAgg6OfSYIMSbiYaBACebJC97xmAAKYHHIGCtgwGFzCA7NCK",
                    "gwMGQwCmCgOYwBAcRxYtooUhgsNhYePo/zxlYHMjlIxIE3+UwLMo/w9O2t4RMQARxBCKzOo+DAeFgI8a",
                    "iAjAbMIr+/ehvUA2zeAIMAgVl0BGCQ4PBafjzkyKPQI01rq1YF8vRZ//5j37N/GrdSNCDRGcudxtf+tf",
                    "UiYoBjBICgNze3V1MSoABgAAdAGgHmAAC40gwCAAwcAynucHSBxgyBagoMcwrgvTADAqIgHRoC9I0wYB",
                    "kLAsYEh0TDY2IEAiCAnORsqMYgSLrmAgQiAJjBkAluBAKqWBcDDCIRh4hgcMhMJRg+H5jvNgEBwLBQRB",
                    "uAQOMWwhTRZQNAaDQYCwUN87BgsB4gCA3OQUxADLhgCEJgKFBiiAJhqDEFtzEAgmAIryR/R0AAwAnnhA",
                    "YUAw8GQ4EGAguPGEDF51ExAoVhkRhAjXS6AgGZv/+9RkYYv68F/GQ93jcAAADSAAAAEtUYEUD3eNwAAA",
                    "NIAAAATpfPwsMpMwYFTK4BKAyGDKKUZeUmIbPAwVLGMQPF9WaGBweFS4ZXCwqCEpXTEA3HQGk0+SUpgg",
                    "fGpkKZJAiZIcAYeBwGnuZ6rxxGdko6NTcBCaUjnLGd1WxWMM8Vg2WrxHQgbHIK929LTIJlTW7rlT1ppF",
                    "KulzWYLBA4E2M9/3v/rD/p0TyIM4f//+////BsQkBI2juU9lxpqGlTARAOEAGJgZgVGCEBSYE4EwWAvF",
                    "QbTpZYnMBgBIwNghTCxEKHALDBDAZBwKQwAitpBEYEBwNBykWXRKowG1v6mLQNIBjAMAkbgULIgAAHAS",
                    "UCQIwZMECAMJQGMTQtAwBgomTXy4TEoBkZQEBQ6Bpi2CYFAoFAQYABgWWCgVCwYI9MiMKASOiT4MNxHX",
                    "2YHBEn4AhuMFQUrt3HRSMAgPCAtiCHgkGz37PBQFIAqCAQYMI5kkOBCibkRAUwqEjGwYCB2AiEpssgzH",
                    "cQUSWGlgOmPCOGJcyUFQMMIdRsMFEwcAEwuQGBU23FiQFshBwgUQIoGYeAKGUXAgpMIEFVkthJCYDwaQ",
                    "Fk+mq8SEBbezreGUtEgcoMXNNpmdCpFSHiwFxkANYo9XINSpfdPYRjMzc2gUFH5Dgal4gbIL0C003BLW",
                    "2wwlyyQGEQGtc/f//7//Z6AgI2HDfP5rv//58ZGYAAL39c/iJVCxj3zxegCAQAJgOADGBMACYBoJ5gLA",
                    "HhUA8OAnCoMZ0tOCGCCE8YCgI5hnCKiACgwZQEx4D4mAXi4jAFMAAFBTN42GA0DUwuEIDByAPYZARgJA",
                    "JEwPghAGGgFgcAqIQSzADAqFgBDA2AkBABpgtgRmUKSULATK+YoKgamECA8YCAAIQBiAQBDAQA/AIBJg",
                    "OADOa+xgdgmGWUAaYFAJhgJABCoJZewwvQSzAYBBGgBy9hggAHCgTUEw8jcGA08FTDBgODC0OgYkGpm8",
                    "siROg8SJb9mDi8WsFg4rkGD/+9Rkawn7o2BFM97jcAAADSAAAAEvDZkUL3uN0AAANIAAAAQMxRXCzUmJ",
                    "AiYSHphsJDRlBwdqJLGFQwRGVuTVyUEHZFmNAhrAKCYXE4KRwcC3zpUEYMDySN5hAFBRqIDAZKQxKE5y",
                    "INQfv+8nh4CpEooGMXAoG60tWiwRtcv7UCwOYYpWCAYDoKAlIW4JgMp9o0CRSJbqyhbmqeWOM31vD//X",
                    "6y5+V0IBQ0F7XP/////X4EoDBoOa1m/LqTRcUe9zwwJCIoAoMA0HEt2YBYBRZ0wLgOzpRbfMJEEMwHAY",
                    "jE3EMMAsAkwSwCTAwAUL8OGOAGmAGCMJAvzDRxgBIwFkAyYIxndoeBzKwLJcYDIBCA8CAYmA6B6TAcGB",
                    "SCeFgCjANA0Mqwd0BAeOG3QqAdmDUA4YGQHoCBIC4E4YBiYBIKY4BLPJemAEBKZQIaYsEeIwCzAbBYMA",
                    "cEswWQQTCGBOnioAQYFIK4MB0CAq3Kf0wKQjiujMJBFHBVIQBUzOQwMElVU9CA0mBR+UEAwyCR4BFQvH",
                    "GImYmDqu5CYCGpjoMEQpSumHjMKkdDF3n5ZsA4UTCdeZABhQomHxEYuBUHRMYBphkYDQLtMRMDlU0+0T",
                    "LIDSgf8LCIoF79ayw7SAoDq6HDcbGMYQHJLGFKyEHtnsYbrJXwHLEAZvEOhxJcphQVE4qD5VFafDOJp1",
                    "Xt6YW/3f5v//8McqxKA05CI3yLCtLZ7P99/85ggBoCH66aDv61z/1v/s0C7o+4wuMAEBwwAwEDAAAfMC",
                    "0AgCgAAYCIAgxnOYyoYPwPZhTABmGQHmYBwBBgSgHGBIA6PAaQpPEwjCsFCs3FSodCkzt/gRAW4D7mJQ",
                    "lAEE2tqZEQFGAAHGBoilnzBITh0FjBwPzyFeo22r5iIDxYtAoB4jBFCSYCgkQBqXbU+VAEMEAxObFEWF",
                    "mDCAFQgETBMDjBABV6PM5BhaD4QIywq2hGSzBnEXiUASAiEJGgwajQ6qrTBgkMCFcDAMCBRpwNDx71JG",
                    "MwlB8iD/+9RkYoz67WBFA93jcAAADSAAAAEuwY8ST3uNyAAANIAAAASwRHmgzipt/zEA/IjHJnCAgDOQ",
                    "IwaBMQDgKMlUwUIjEgVjEPp8CEOjQKay/RgQ2mKI0HKey6AULBlsHv1Zy3cgscBihxh0Km90k0uEy4cD",
                    "JiYVRXPdyWMRga0VB+a4HQcJYKQkhYfmQQJGrMUz5DScu/ybiNAS9++a//wx5uZIAKtLPXZLR7/8f/WZ",
                    "CAw4FxjZ/bTroHPeaLgIARagwJwHDAiBEMGsBpnBgHglmDQFgdBLw5g3BMmDgDoYj4hwFBHMGgDYwBwD",
                    "0HXCc8KhOg4BhS0v+MASGO4jCKgBAEAsvkYLIOBgFgRK0NWixgGgkCQNJECsIQWwgBAwBgNTL+D7GgaH",
                    "K03pgeABGBuACYEoBCiiAswEAPjAVBgDAAFNzA9AsMa0akEgKMlMFMDIwHwJRgBcwCwJWLx0EAXAQLMI",
                    "A4cxY5goeHRuyNJFb80MkYaX4kLXYXiYfAZkAADxmCwhXKoCeKBAYFXWqvyPLEOKbKM1BjAxqHjM+jPy",
                    "AXGuYCXehkWGwNQJoAKCwueaGBEMiExjwgsNbMJFQ0cjyoCmtuoYhApoUQP7as1rskBIRaYYSQJwgoEw",
                    "keasDAsZYE7HLffcIgBDxNHFAea5U7U6UaCxILSsJWIcjOFyGVZt/mvgvzru+fjlnn+OLpmCASPDF8rc",
                    "cCgUimqvd63UjaIoOBDawJ3//9XcDNfx9D727YAAQAKagMAXMAoHAwGgElVDAsAeEgljk0cWMBQNAwCw",
                    "zzEEEBMA0FgwiAEwEBMJATDIAZf8wLAWzA6AXEAA40BOh2Mh1QYwJAVxABAvAwHgaTCEAMS5JgDEDVbj",
                    "AkBuEACwIBsThAQBZl1hqDQDLeQGSgXGDQAWBgWgcAylWvMLgxMiHgOQqBOCgKTE0HWMA0BVQcwZgGTB",
                    "QADMH4E0HAxmA+AOwcwJQAjBUAbAQRrTnkMEg487RBpZLcXcMkwwMPBCAWyP+ABOBTkXqC7/+9RkZoT7",
                    "z2ZEs97jcgAADSAAAAErlYEWD3eNwAAANIAAAAQWiyZx3k+pXRmRiAMBypGicwhIRK4wSBkW2fFUEGAg",
                    "+YzjgsA0vwwMmDgiAmir2JwgwOHCULAoWr2RDBpeHx0X7TgcswYES8MRnsfzokOTXjAxGNnjtBSOzRCN",
                    "DGQec3+ZSxONAko4QD0zynggRvuNBERBElA7luZPd5WS1/WKUgOBcn5+8//ef/yZIBEumx9hNljkxc5/",
                    "db03IMIMMxb////f4Z2/P+XUwrT34joBJgEgMmAOBYLAol5wSBCRAwG16tqYMAHhgHAXGH6EMYFwGAVA",
                    "1JgY0WyqDrTzBYRAgTSgARICyQFDYrz2kGBIIkIEGBAfDxkmAgAqXjQLkALmDINGHgUFULyYXjCEVjkA",
                    "YR4pH2ZSBAoAIXwADhbl5aUwRAswMCdIF3C5hiytJgkCTskwxGA4ABg4GCIQN1THLymBglL3ctqQoADn",
                    "R9Gg63yCoNEBgoHDwWtS5I0wWIBoaDgLQkmCAub0SBQHZJbEQeMNANGpNwtenUBgg1wIApgESigGNcMs",
                    "wQCg4EmDwCSCgaIgyBF/RNdhkMhDwDyEQHCoeNXAYwOF4EZeKgwIL7Quf3kBLpgUdBxjM1AwAuNDJUER",
                    "j4Hzmf/K26g4COYhgaKEZg4APQ/4yHSYvrvbN+e2yrYzrVJoSBUn5+e/3+t/qyqsknf5koDj+f//7wZ/",
                    "SzVZ3SeOaiKbXKVkpgGADgUAcwSARTAhAXFQbBkHg33HwjBUA5BQJxhZBchwEJgggWmA4A6gyQBGCgXM",
                    "DhwMChJBQRkQzGJIonT/sGApgmIwLjQ9qDCROGEgJBgtgoICACDBkTzEICzBwSgwpzCAoj3E0TJUSTCM",
                    "ByAIgMABQZZg4CZg2BESAgTAgVSEGV+OIY2DWZXwUEDYHB8YRAEYlAIDhpJQNiYVBpGkwnE4oDqCQEJE",
                    "jD0I2BQ+DAeWSV8Z0KjOpXEioCjG5lGiKWzAwLMTDg3HNTDYTBQXUFD/+9RkaQT7rGBEg93jcAAADSAA",
                    "AAEvIYEWz3eNwAAANIAAAARAuMFgVYgUBTCgwTJbAECGBQQPGQxaMzmrIJgbDAkGCYYGMgQjoDAozVAM",
                    "ZHIaAYwUAlOCUrGuxyJJpKGWCIYGKhhCNY4bU6V6CQCSkQ2QoygJJN3iqBAqAIP/VWCxwAMkUPRuNUms",
                    "wCAYbWcOkEwEJmcxXB79QAp2zSGY41VVbHL9c/7t3v6rwWHA7vM0kst4b//1tKcaAcioXRyZR6XlDvKB",
                    "yACADMF4HABA2GBmByYCwRZgsgymAoAWYUQZRqSqlmG0DAChDTCrCuMDcB8wQQBTA8AMAQGsDpzkAfJ1",
                    "F1TCcMwoOJu5XIkHhhOJQYHq7AoEYUBpAEEAOYNBQDQnMEBPMDg1AAORU4iPYxwE8yhB0qgIECqBgiMG",
                    "gJgVuA6BAMAcwDCeJFgbDDIODLpazK0JzG4gDGkHQUAxgOAhgUDYVBUwrAMweCQwdEswFAZUpZsRDc6Q",
                    "CjGguJAAWtAIJMDAdLhc8HsWAgLdoiEAGCBicKGWXY7gsMp8gDQkHmGJkGBxeZZEIoDCYKmDwqEFcoHZ",
                    "swMmEA2gEJASQi4xgHQUHjAgRfddsTWBMGhdxQgRGHjoDiUFwGkASgJBK1btSxchx2y06qhqELIrJBs4",
                    "XuxOGKKk1HV5MiYixMwEek0VWKIAgDmHAK/M9YkfZW6V2HpqHXplnP1/co7SUeFaaaipxefRuJa1h8HR",
                    "vLDeU2761SgdsGoSAg7bfxiFAEwuCIHDMYSgOYnDwYSD2ZShEYsAMeLWYEDEYViOYpAqChwcoiFQwmCw",
                    "kEpjcRqCmJSGYPGhgcKGHQidpxxgISBZFjyMMMDkyYMiQOmAQW65gUFJMAoCmCwgYpDyipuVYmICEncF",
                    "wIYgFZg0CIgg4KEQaDAARBQxCCwuChEAkqTPKgCA4h6YGAgOA6hZiYWCETmAwWKBoWApcRiJcgeGzlzc",
                    "wEEHgUvWCQebVw1yW+/JctYYyAfFRg1RRIgViY7/+9RkX4/6kWDHi7zbdAAADSAAAAEtDZMgDvdt2AAA",
                    "NIAAAASAoLLQQVIQUuyYOFmFkQ0iJKGDB46DG8naPhg4wDgcCBxhgyCQVDZ614tupuWlXkYMNGTF7MRA",
                    "AxSmlc9agtU8WnHtRvV2BlAEB6p1Lx0LSLjidEPRx9HoepB8xAQNOJyITMMBHpRrnIvjtaa62imBhZEB",
                    "piQLFn8hzGxvuP///llKo1b1hGqaz+X85uzTM6xsfwwFw/MQgdMVxiMiy+McrvMm8iMGDTM1gDAwNGEI",
                    "RGGIoGD4emGAPGDYLhQVDF+KzX8qDEkMDCkWDDEPjC8OTHAXzIwrTI4ezCgIjHkdjJ4szIQWwMTAOGlW",
                    "4wJAJgYcAJegRAeYUnCZrhEYFgiW5WcnoXraUGAsYEhMYEhQYjDaYXhMYiiEDQ7MHg7MTAPMBgzTdLAB",
                    "gIEzAkpDMABgwEQEFyfaKYQCTKTCh0KDxZg1cKDH0xgPFgtO5yoMIAFKsHEZlyGdabmEkphZcZ+UGHgC",
                    "QwJBku0o2oi0KNaCmhiIASgxCJrRFiwlAzBAowwRNnMQKQsCX85TIYZQ5I2CIGNAQBo+BRdLk60nJ+GK",
                    "SOkIUaEkIDH+Yi9d1/oJUxyEJqCgpwlH3JfOck8wjaWqMhJR4OElxCSsBC5dUfGiMIIBEDEosmaxtFlc",
                    "rixnHu/y59u3r///1SxeKY4d/98xzleev//w5gw9r9lUxBTUVS8ZgogzGCQDqYDwUJi6B0HrUFKYmwDY",
                    "OBIMFYMEwFQCC9RgBgDGA2BMYAIKBhPgcmm1Wn258mOhFGOQzDBfmAQMqgAQRBUFTAoRDAIHT21ajBEC",
                    "TFQSwUJKgTXoFLoGAgFhQUzKZizekhTDIFh4Fh0CVrCIBl/FQBlymB4nGhrRGFgcGAIBIRICRQADAEAS",
                    "2RQCQWBMwrUY00DMwaBIwyEQuUl+0d+AsDUMTGofNeakwOSzCAAbkmC4AVABhMNAgImHgoZMjZjE3GTh",
                    "MukWGpQALsqcoQBMxIYzF8v/+9Rkbgb7vmTFg93jcAAADSAAAAEuEZUUz3uNwAAANIAAAAQMsolKEDAV",
                    "ORSTu0IkETBQvMDiU0cqDDIvIifepWJQ90cAicxgc/GXxQk8zp8XlcKQM6SmAJhNCkMyEFUKC9E/aqTU",
                    "EkgrMUOEMPIGKsIVWSgf6lgpfZhMDGRl4CQGDA+DgbuVV7lp+TJYBNqC0Rl1mr9Q+3Key3//vJuAYALH",
                    "/+GvwzaYn3N3////UyX8pMf/98vVkTULu5NTj6QQCFQAAcAYYLYRxgCBymF2pgbR7cpkagwGCgByFQEU",
                    "ERgWgTGBgA6YE4ABgAALGBuGOZKyWRlkhoGCyCECgByQF0wBwAxwAZro0AyEALGDqEAZ1QuBhagcmBwA",
                    "a0VgrXuIfA0EcwTgTTAwC3MscH8OAlcd2IMLdpjO2vkwGQKTE8IzMGgCNM+RSVu0Cp0t3BgCpgYDAGEa",
                    "BWYIwCBgsAItMSanp1gBcUxMSTUVoMIhaLkoAeVymcAkDKqqmMEH8+oTDYQlMUDNCpK2NV5xTIxYFDco",
                    "MNnoEw4DlEmvzDR4EJg2W2HimakQph4ijyOhFPI62TKi65kKSEgzS1pO7+1OrDGEC+awKhlIFKGiwF7+",
                    "VNJV4mMB2auFCw8DwAYbBDXJ2oy6GTV41DgqmIgih2tdqRNgJg4Tmmh0ZED5EDrKZcuw7/6+tNl9goEX",
                    "4z7Ut3/5EhAHBIpQXF8v5z8lFwSH3gr6/WPOTS8pVZNPTcUriFWACAgEQgEGBEBEYJ4CZhoBGGNCiufJ",
                    "5cBmVgumFkBYYFIG5gYgUmA4BsFQIw4DUwMQXQqEQYFLtBhtCUDwdwKD+MCYCYFALGBqAORAKGAqAIYA",
                    "gIJg6iLGaOXSCgpAEAUTAAtOkuciMAQI8wIgRTAKCRMwcHUqgRNMSNjICAES/3HjBWBoMQEjgwWgHB4C",
                    "KmaxOTD8xpvDAOHMMg0GIwXwEAUBarFRXqgqBgUgjLB4O8so2gcgw4JgN0gVF4uEkMDRWFF4dGVIc3wA",
                    "UjFYET7/+9RkZ4X7mGVEs97jcAAADSAAAAEuqZUQr3uNyAAANIAAAATjGMPpCESaHMqZ5LRiMts1lFuo",
                    "6KWwoAjCI1O4h0zmVFBoblDJqeWMxf8sNAxkUCYVQ5L6m6uUyQjYzetRpaLufrP/1JU9DEZ3NkD0wQGn",
                    "tfABCVnHewYBRqauNY0S0NRkAw5vtI6Y4CjH7FMSA40mHmsUZZiRY63+vzsoyDSzk9jCvnvWMGEhQaFI",
                    "e38f3hXTkMChy7bz//pu6Smhuw/PSdcKjAQLOMDECYwOAPzA3EkMgpmM8cIljCSC5BwPZgMANmBmBuYD",
                    "QJo0A8YMAFydJgLBHGUGe4ahAihhIgZGBMBKYGQVAFAsCgK67jAgA9AABZiBB8mRAb8YJAFiVqtS4Y1N",
                    "tKGAZxEAAIwAyZ38wagAEwYYiyV6wDfpaGCiEMYchhpgygQJyN87sB2b0NggAowMxXDKPDTMIoFppjQp",
                    "z4gpmJI40ORzgHdM8nMWWrB3fZg6ztsqBAVMQjw5GvzHaEAgtEgGJAp/ZqJv4YsZJlCUmmiUPQcaCTFb",
                    "c6+YYITBAHMnKc1Y7jER3CBE/Ldog/85HyYQmF2MaYIUZikvsX8pmOLzMcsgHLmGK9TmVWODIPMwlM3A",
                    "LTGQtex9lCm5S2YbmMDk1+qAoKBoCFvKe9+7jRzFSLNfgUSE5fl0jAYeW5X1/eZXYIEIPMIhaO1L0/O2",
                    "fzjBgUJBgkaRGq/919RjxgoNyqBb//2fntlUAEQD/feMegOb2LYVgAAABGBABsGALmAkC4YMYD5juIyH",
                    "bkq+YnAbxMJWYGAHwiAEMAsCEvGDgOzAnAKMC4JcxSUOzN6CVMB8DYwRQHTAVBmFQDDASAaJgHzADAgC",
                    "4ChglB2GKkV+YHAGI8B9LYer0kBDAI6apgSAJGTmBYDgSVyclSNDHnlQLQUMHomIEgQuTHo3HrM+74MA",
                    "KMHMC0yKQTjBKAHREd+GI9HR0CrsMWHoxhiDF5jCoBeqkg+UvbRpOmPUWdBJRkoMiIDIqtf/+9RkYQb7",
                    "CGVFM97jcAAADSAAAAEwFbEOD/uNyAAANIAAAAQoblCvoRIgzJYgQIwoHk14tYja5C9YhC4NGhrpSmHS",
                    "EJAt5Jc0iUxpwnRMos820FVuVe7xxpn1RuMzJcmJMVtc53dMlqZWJ4dbTF4FVdTu262FeCAsLTALBMLA",
                    "wHB9JODr9i3DDthYEmpQgSAZJiGx0HynL//X/k3UWLMHdz/f87YQbKwg+FjHWWeErcQHHKTtrr/uz29J",
                    "2Le/HNoBh2gwBAAqAwByYDOAwGBJABphRYpEaXCKtmDCgYhgawFGYCKAMjoBYYAeAmFAEgYAuAOiMANM",
                    "AmAazEQefMHQRMCBJGEgDUNA5hgHBVBmDgDDAOBBJQPjDVDdNEcu4wmgqgMAQxeMSiieAqg6iQFZgZCU",
                    "A5mcFBghALDUW7GASAFAMEs+MAYFowpTizAcAyEgAoJcprj/Ok0cGgLmDuKGZFoZhg0AOsAf+BIS6wMB",
                    "4OLhik8nS02GgQoWSXDWFtu43JxQSNREtTZT4MJCEMKYYLA4Ou1BLdEnTG5+NA4I1uWjGIgLeQqljys5",
                    "IBBQDmMwOd1KJmoDlAEe+WMtfKRNyKgJMpYEwIZUxoZmquVarTFUPnO70YFCLTqXv6wmywEkjDNx0NBj",
                    "J+rDIW7crSkuUZQjxmMggoPGCADD1Lclb+AkGgw0G2QyYXN7yLLLlQNe3z+71dbEDhHW3vV/LeqEQiVS",
                    "OVTn/+ekCgMVJNKbP/V/dIWAgp/eX71vXf7z7e6zBfkqAEmA9MA4CgYBVMA8KwxaUvTXXY0MS0RcwXwZ",
                    "DBpAiMAMBMSAsBQFxekwIANDBxAtM+P1OwxPMIgoMMAnMCRPFANGACKwSCocCEETCosD/QozCMRTAQC0",
                    "tn9eqOvsQiCECGYcK0cahAYtA0EADIZeWxUCmYyGAWZqQcYgguIgeTwjsCVn+Z6IgLACOmAI5JVNYlc5",
                    "SwY6IsLDEQWNLXMw+MC8jE37ZZKI27AJJ5lQ2HejKZDCA0FFLpXMRh//+9RkXg76mmVFC93jcAAADSAA",
                    "AAEsxZMQD/eNwAAANIAAAATLhiQpmZ16ZvJhk4BkwUhykvQEkCYMExErjYCSMYh9d0Ryg6kv0zMTDbVB",
                    "TSYNM3Lty5Zf8EAo2gu0JzQ5y3nrfGZMrNWA4yqJ1fxO0+nb0iCgJNElUx0LXKTSpdbuR9uIyQhAUBaH",
                    "kQKZyjY8vcf/+dwUXGhvC8Ob3z8KcGAdScfq65v+YNbBIFpod7z/v74lNB/+5MwJgqALmARgIhgJQCCY",
                    "EmAImETBCJoHgGMYM4AcGAfgEJgCYB6BgGEwAcAjbQHADCEQGARjbDDj9cGjDABDDUXhGQpgEDaRQYIp",
                    "gOIpgACpgsgR+2+5icJRiCBxbVTB5aNGokEExHCUyCt46XFoaHooE6IyoGgYt2WI5GAQCGrskhBkmJoL",
                    "kwQqfgVpDfpVuCYVquamCoIQBaxGZc+jLF2BYCmUxoY08hl8nCxNeaslopYSAuAgIYzP0eNBGk0QME+i",
                    "IPkQehLlJYBQHCAvDmlDo6Z8Dj9vI0yONdKAmYbJxk5AG7GCY6FD7xCA21lnaQVBYMe5tEJsEi+Hf5bd",
                    "wUKhwcIixPFgJbww1nUWwYcFJq4MmRhsNAph7DYCtTcALLNWAExkGjHoHLZyGm3MQG3pYHAGMgBHC1nE",
                    "GA3Vy53//eiQDohW+Yfz9byIAkv7HHL+b/cgEYCrxLDX/ai/kgEhXD6AdYMeSUmINQAAMssAgQTAFBGM",
                    "AYM0wQleDDTarMJsNIwEgbzA8BKHADjABAjMAkA8wPQEDAGArIQjDCOTAMbkO4GANhAcJgTARiQDZgDg",
                    "PmAgAeCAAQaBEMAAGP0T0jMBgQR4EJOVdypSEAAYBBMEsAcwbyyDGNA2MCMCcSCHdu4oq4CgC8AoBUYs",
                    "Q3xgGg0AgD1d8kY2kWlY18qADAEJsWPlFgJHzk0NrITkaarYZABJwVrmLjPK4o8Bc4kBBAFQwHmBgIYS",
                    "PR6sqmQye0cSBaa1IqigJAQnMVhoyItDSidAhcj/+9RkbgT7r2TEk97jcgAADSAAAAEtlZUUz3eNwAAA",
                    "NIAAAAQuNK9cpHwUAAGBYECxu8FCR/VzDUmeSKy+QA0KmHhWLVJbtPG3fw5alJhkjm9iyYBAg8AIrD+H",
                    "NbJQIYDHRoAcGEh0yOLt2hjLHJjRmUNGjRaUJ9KbDHvJUrYYDGpr5JgUeDwwlybKnNjvMP5YiQWEpENY",
                    "r3dz93OwyJCJCB9IKpe447mHKMGBWy4H/h/Z7IsATD4L5vxUcdPVAgABNJHAASUA8wSgWjFFEpO0cboy",
                    "GwAQwRgwGwKQ4EsHAHGA6AeYDQA4hAYMAICA1p+I2OLoUD8wJBcwMCxQIKhOLBaYChMYCAIFxoNoI9ME",
                    "whJhDMAAKTcZiYBg9FzCcKCgyjAh2DIUKDDcDDAEAqfBIJmyh9wwFDo1zTEAhKNDaTA9IHbBgEA4BBIX",
                    "wKDZEA4lxACKiNyjMVAAwECgUJBI4GHQua+U4FEZEEpmDQCIQqHxGGxYBjgyMRos2WmjGI8XWJB1XKt4",
                    "qCX+MMBZSwwrEDNo5MNBABCNykKEBAsAU4QoHzBozMuD4FJCemUgkhAQBL/qqmQEUajCreXlbE4/q0zo",
                    "gAKg6nmJAEjgwWCLljuD/mIRkVo4y0O0yEU17Q939MbMPIcwaWxURgoRyD/xrOGKGsWE5i4ZgYIu+IwB",
                    "B////+uoT1H5FvPG/+tR0KBNjurG8dfrN0CYXT05//rLek7p3tMILcQNXpVAsEGAUQjhoJQwDgqEJhOJ",
                    "hi5RZ/NphiwHphCIxh4JJb0wuA4wxAoSEAaA4wqDU1GmT1g8MGBdXIhIRKBETRQOMtJQUYDFp7OcCIUI",
                    "8EwcBALWiYCJ5gMimkiCabLJh2kGbRUCQaxeF2xEESsGioAL3MsNsHoVCZgcaNpT8GQgYADRg0OAoamI",
                    "T4cqDY0qIrcfpNMwcCDCguBoJMOCchtxkg7CQLgSUmGAgFAsYYF6Y4BDxgNBm7AQZmA6XymhWEhkQhAD",
                    "S8MEi9aRjkDGfQMBRKDi0MD/+9RkaoD7SmTG07zjcAAADSAAAAEtpZUWL3dtwAAANIAAAARgmELD4DTr",
                    "biQg0xcUSABy56wSERYXx697PjDhAMXi5ZrgJlhxbnvtx8QkczkljDgCCAwkiiKoJO0GBKCyEXGRgUkm",
                    "X4QFuVDXdTKsxgoqGLyEW9LZvnjzKrGyqFQdFjKYFLpSkqAF57/4f/1YIHBCYrDEooLWN6zli6YwIV15",
                    "xGB/vaxjxVAQGTCXqnP/+tf9HZPagBBAB5gUgdGBkC4YLYKZgWktG9EdOYMQDhgfgChAQhgOAZDoHoFA",
                    "EEgYwSA+YDgNJjjv5oEGJiMCb/mCIHO+j6YMg6BAaMUBMMKSZOoDbMLwRQkmF4CgIi3WBgFAkETDoOzE",
                    "cQjCdmDE8LiYHzDQAGuWiqARg2JAKDMDCmYBgYapkyYEBYKhKTADLngLnhAnAUCgcCZgKbRkcDQWAOtW",
                    "9EEzslMEBBooEIoa6zmlBBeivmYSEKGmbByyGRmDjh+RqiwwhIoMCgAAApaL0jhMneY7ktgM/CHQMNBU",
                    "b0zkxmsLUMQEzr0QzkEjq+zCi8lGjAQxQiHSUUMa8jCg0vSIwYACoYTb1GemEABto+Z+Ahh6ugvyPEFm",
                    "tUKoKDVw0okCosIhQvcPAFJfwrvgZKLq1lgWFBCf//+MggUOZDDQQ5pNEi60L8MsN/vJRsWMHt08msP/",
                    "8lMHulbv0fPw39ORBdO5///8/2ezlvStVXJqAAAAFBwQxgEAAGB0DQYHgC5ibjKGpaOuYRIOSA8wIABi",
                    "ABwwHAECIEACAFDQJBguiImQcfhDPmKgCmAwPDIHjgOhYDhINAIHRgkKJjaERsGTojAMaB5CSAgmzEQO",
                    "gAJEEhgeIoMU4waDAvEBQTb+MMJMCQJMJAOAwdmNQKBiGGFoHl+X/f1k6aJgCGINCkWBEwwKIIBYeBJx",
                    "lYIZBgFAgCI5ZoxIXAH4VlUqmbueMgeN4OMgPAy9cohcGlYoLzK/2BGQRAwis9hrtm8PnAOJIl7RAFQf",
                    "MqGIlj3/+9RkbQD7RWXGm93TcAAADSAAAAEtKZcfT3dtwAAANIAAAARqYAwmdZYPgHyXwYIkYgcKoYbn",
                    "1VDe2g+6562zFjxYvM1JLWRONk0MMFCCI8vFAKi7/Tt92TEHgCVa+a0aapUTIIP13CC1ijUUSvoaxmtv",
                    "tSDSoOL3Argtd/5AnnzJwbP/9G0k0iNZiR40Fpsu1c5gwpZ1CQKHMoI7bp71mHChKvtp3///+mFw7FN1",
                    "Pve3WAECQQAAAgNBAMC0DYwTQEzBmCjMNIx82UwfDBtA7MAcAkwHATSwAsNAfgYAEwAQB0AhgLEfnCpf",
                    "FCjGEAHmBIBiIBzAYDhEChgOBBggHxgq6JjOKRlKHRiOEqGphMEalrSTAMLBgKjIE4zL4EDI8NzBsNlw",
                    "mA4IKbu4qMwOBQyFCsyhEgwZE0wTCZR67RxgRgKWAKMADDMbQWMBwMMAxWAwrJxSmatgQNCTlN/CgE1I",
                    "cgiGTvltNAQBDjZ5sKDpMvPQFQkwsgEhKC7heg7NpMKPyIbqsaCp4ZQIzsBGCCRoIiaYajyQ+1x+TDiQ",
                    "BCbthUDMhLkCQY8NS1ESgRLltCYYZAsLdgb7FlRQZHXkFQY1A4DgQSCpT344FwIBGQwAGpJRhJeUAt7/",
                    "/GoIRABRQ0WQvHv3GkLaUiBBYMTHzbE9/7Zlr/3uClIWYQ8GeG8dbWi3pYAw4bpdZ9wxrEQGwsSCMf//",
                    "/4/m0DiYgpqKZlxyc0AMAkBcWBKFgMDCpCJMMwmU5bwVTDtA3AoIBgRgKGBAAGAgQQMBOYAgB5gNgCGE",
                    "IZOdoiuYUAYYDBqYFA45JgWIZAChg4IJgiQBiJXodSZKUo8YxgCBZgAA40Cy0TA4JRAARhdRZikJ5iMA",
                    "5hkDxg4AocBL5SJRYDCSYMRCY8j4ChdMABOGgIhqMtGGARMDASMxkoMyQ0MDAAMEALGQQc4cAMvagsYQ",
                    "hUZOARnMKDwkWmYYHoYA2dROyYBBJqxGmbRSYHBk8CAiW6Y5ERgCBUIGcJSVRWHAKG1HjBb/+9Rkbg37",
                    "0GXGC93jcAAADSAAAAEucZcWD3eNwAAANIAAAAQVijvqyGEw8Y6lJgwyhwpgqLaFhAWSdcSGhhd1iEtg",
                    "olO5ZfQwmCiQIK+WQZ5VJl0giwLkr1P8mUvpFZLYziazCprY8OgCizwYmWhJQsaJBaA4oBOrOs6CAxAF",
                    "DLhVASUdS/ruaRabxhMBmXjWYYDaUUw0KX5ISbvf/dZ3cJeLBDHv/+sbL6g4STvf/86CGJgiBP//8/5T",
                    "Biked7oxqgUAgimLA4joVZhtkKnU6EYYSIFJguAZEABBgRgFr9AoAJgcAEGA+AQYPw24/rwYeANDMwrD",
                    "NMoDCaBQFMKggMQwFMPJtN9w6MOCRAwtCELQAD40ETHwsEZgmGxj1IJqGPZhaIJh4JKsD3O4u8vIChnM",
                    "XH3M4gMMBgDC4UlYLSt3GXmAADGFI3GLsDGLwWGJgRkQmhwewMjY3EvkWAIMnZAGn4wyAWiAIWBBGS6U",
                    "pGgKMjMyNaDN5sGAOPAoMBZhAB7f4dBpmEQmQJgYxLxg4Cv04Y6CU4BCCC1iEk1BBBULAYZ0UuaMCgeE",
                    "BCcMHj02wcgCJjCALjPaEAANSDehUAGdAyKBcoGUfS9ZSo8DgsvFFI4ELTKIEGQGhzrYYpSr0FQ4aoBJ",
                    "ggOqa/nrO5DRUEhqE4DoHatlypijYIAMYJFZs0dGNxpLofoIw3Qu9W//+rTaQ/GhDY///CenmqBQDzmX",
                    "/3KpStij9Nv/5/6bBBeWKpsiNcAAAQAwBQOgoA6YBwFxgJgUmJkP2dMIGBgogFmAcACgGMAIBItOYAwA",
                    "YNAmMBUH8wkAxTRnBLMDoAkCgXmAoAoAgDjAjAdJAGTAiABKgCJhrAlmReDaHAqBcBAwAwOxgBktsMgR",
                    "mBQCkYIoB5hABVgo+cwFwdxEA6CgBk7XIYOhgYBIRpEQYYYgCRgEAgCwCyrIi+DcxABQYB4ARglhKGIg",
                    "BkCANRIB+XtxAQGxIAsWYJQJAfNG0GAGDGAF8AcJJbx8y9FMYFDi3A7/+9RkZQT73mVFw97bcAAADSAA",
                    "AAErOZcY73eNwAAANIAAAARBGCouimHL7xNSpCURNQVDoXoyReMrAOyhSJakSOxYzTmOLSDClIEibV6N",
                    "u4QHI9rnMGODy4gAJwsGMe3HnaJgGGWUnltQkSoVROBHIkhWAo+GnIx064YuGA4CGACLczKgO4pKKAtC",
                    "GQp1pzv/uXjJgdkMmPCaWdjLG2hxUwBhieQCGLH7ydykcSKBF+8v//x4SALe65//jhqGwwOr0Xf1hcp1",
                    "5lA3f5///8tJ5HkKe7UkUQAAAEMAAIQIjARAKMA4EswQAAzljAtDApjAhAhMCYAUcADQ4tcJAKwoDCYA",
                    "Y2QL7siDdTEIK6GwIGqkUUTBMPgu4xwCFQ0CsqIArYnMAAPhoagAL5iAyxqiDhgkVpgGFJg2DBeFX5aB",
                    "1QoN5g4+wckIODVIV+J2XPkFQGEAGGP61mPQSmDQEioCVpSYIBGqsIA/LADhaugEGBBAhjTLn4aQYeJB",
                    "g8GBaJkoHMDAMxSHAcPnu+WLDGEBuYgiZhsaiwof99WzxMHJQLBB0TFTrMIjcxULw4Tyx9c2lNVMJhcy",
                    "M3TBIbIgg1enrRtyZoRiUx0fSIIRmxp+4goqKAQKkMzEWQCPXRZHKs9Mhhy8ZoHo8KXDr63hddAChAyC",
                    "bgCEEor2vsJ7UohDJm8hhiSbPY3S5jwWf7n///6+XGx/+c7YnVsl2LGXO8vdlBUBLKt6////5W5qsItU",
                    "lUAUEMAUAwwIAJQQDmYQw+B2riAGCyA0IQHDAzAYIgJjAXACSgHQcSgDMwTDYjQREgVgEIBhgcAmjQDZ",
                    "gEAO2h0AkZAkMJAxAxoQwAgB18jAKAfCAH3fAQFZguAUmBIA6QE/GEKBAYIAAosCWnEtRWNBILAHmAsA",
                    "mYKZCxhrhTmC4BUv2Wyhy1MDADAhMA4BQwfB1zDDBHMEwBUwOAB4S1owCQJjAFAXMAMCokAnNTPMIzRi",
                    "YBts7qM7PoeMdkEwORzQA2NrlcwCGx5HLufeNOn/+9RkaAH76GZFC97jcAAADSAAAAErfZcVD3eNwAAA",
                    "NIAAAAQIguYVChnBeGRyqrO5TzPMIhUZXGpggMmAQsaAlxlMskodHh1F6dlMoRtEiCY6fgUEKJcFTkrj",
                    "r2T44BwamCUQlYBaW/yvL9wqAgwAMzK6aMQEuDk6MdWq0uIAMafPlcBAzuXa19RRBs0QHzFQsk+WX4Cw",
                    "BUtBg5MpCgwkCI/O44x0wYAZbZ/n//HrFgjPc/Heu/GAUGdWf/ePMUdSYE493//3mVWi+ukcBawgGEIA",
                    "BAulbYFAkMGkJsQH+HTCEmEAJmAoASLAdAQDNB1XhgOAJmB2AYYFyGh26H5hwApEDhhQIhgqARICrEhA",
                    "BohFIwf7YILgSAkMBcwIAQwTABG9wURxwJjDOADPYXDGAQAECz/wJJ4ca8YMCMZVlsGY0Y0BC7K3ZVBa",
                    "2hwKyAFzLBQDPcCBYO2FSmHy0IjA1AMYCC4Y82AVGIKH6V0MxpOcKAQMFJhYqGO9IYgHpisVkwGd1Wxt",
                    "I0BRICBMaLfxmAFCxbcxo8uHQgYjCiCxbE12YjOQuMcidBND9D1ZJQD0ojP6hMeDQeB07MQzMWmkEgnE",
                    "MbMMD5rCuIZU5sXR0EGCRWYSUKiakEL5N37tZuRn5OiEWEwdncsM5huyeJl0SmTATT0fPzZNApCCRhig",
                    "oqyC3+6dEeBbXPx//ekWE2HP5++2ok1qF46/P5vJ9YLy/X///E3DvOtpW48sNkTxGA8YDgAJgaAcGQpB",
                    "0eI4XQcLgIQBjAfAMMDQAcwLgIwIAMBAWjAdAyMBtkQ79PYAguY+g6YsgCrYIARVEmmYdDYZr+od2E0K",
                    "hCJAmYGCMGBQt8EB9E1mmK4zHChBGSQpA0HGiv1XfZZRiCIJgJD5pWKRgMA4YByVLzOYscFAgYXhqYD3",
                    "AEFMChVRSelpYUAoQgohmIRmNI4o3EejMY5BRUdogAjOEbjBgkMVio4atzNBCCC01xoTGjA4NcktyKn8",
                    "yrpzLB4AoIbq3aIreBSbdIL/+9RkaY/7l23EA93jcAAADSAAAAEv7a8OD3eNyAAANIAAAASA81VdwKfg",
                    "wAgItxCkm3cAyBAoUNFMU1GDEWWvxODJXFpSQgk2tKDNppEgCJDdi6SNqkTeBwDMRO4xaXx4Oos7uZzU",
                    "fLVGjykZPIRQYeYZ2ImnY7xzQmmJjGRCO5vVcvjdQYM1LgmAUNWu1CoAwMIoxOZ//fyrEQ9mcv//mMJW",
                    "JAKFb/lTlJNJPjQyo/yx//4o6UAO/h/93lre+/X5y3jQCQLDAqAoHQYDBxCIMcemI9owjDDqBZMCQE4w",
                    "RgGTArASMCsAZIwwOwPxEDEYRTgBnGeQEEMx0GoWJBK9EhQYtMYGkwYc1sfYBiYKgaoaIyIMSQPQXMDR",
                    "bViMBhFMhabOGiMMKBOMCgmGgFak1GgaCYGG+YuYaZoCeBgBUyXRF1yITzAIRAwMjT9RjQQCAgG0WFP3",
                    "gSBRKCxbUqiWa36pz4AGJwoYSBMoQZe0LgEEocZVprr+mJCoAQoYAHDQBGDTI4GUahseHBzpLmryIDmI",
                    "x9UDSQsDTIRAAgBMLjwxJWjAwIMIDkKAKVyd1WMGRQIYEKBpOxAgaiQTgjk/K2rKxoGm4SCaIMRgUCoT",
                    "i8BfSb2vIQAsza/TBJiWqCgU/NqzPRkKjkw+4wIXTCIRZtS2r0laYIhuctLJnAQDw2in/dLbZJFGUWeT",
                    "AaMaw04IONELluX/38Ed0w3mxy5/44OyHDBs3f+zRdgBDiAhxKdbw/m9Id3Yt5fr95c/n2b/TLbqQAMB",
                    "TMC0AsMAiEYJ4Ug0OdkIEwUABzAfAmQiMA4CYgARi5gDAYmAUBoYVadgtzocL5gwIZguFDJUQmLo7Dgy",
                    "mXKIneQkkwppOlUNDB0IHLMGAkTSAI2mH1shwVCQ3iwwEwEI1IoIVgwHDAYOjGImTSAaSIEpS+0Mv0n6",
                    "BQQEATGTLTmZwNjQNL1tQIhLJALWSYQACZCtpnkhDI+BRvjCadMu0wuTBgsGeowaXIAkRQCQAMJC9oOA",
                    "EeXKDS3/+9RkXgT7GmXEi93jdgAADSAAAAEvqZkS73eNwAAANIAAAAQaPthhcigIetiae/yUhh4TuSYC",
                    "EptULmUgqYVEokQNSmSJukwcHCSFn+YGC4cGqXKI5w/BxKBTa0bGmwNEoBBl2mt8fhuxYARqZDA4EtDL",
                    "i2seTMoCw/MwhowAATBoGnv/OMM3ScNGC8vQrFM631QmEjoRMZHYiF7+0v3VkDAFyv/3+/XlpMHoP5//",
                    "y1abIh/R8//7/W4BAZsZ/v//NuokAL3FXfw/YgIQAAAMQABGBAASKglmCwBAYrULRx2hTGBeAaYA4Hpg",
                    "WAGEwAIXAMVMIwQ1uGBCg0cFEkYYgIY2hoYGBytsqAg19DkDBfMFIhNgiRMPwEMAwHMBweBQ6pcA4MxY",
                    "ADA0ezFh7TWcTzGouTIgRzAIAkawoAyIZgULxiGP5kU/RnsRoYMSwrQ2os3SNCoIigNGADLmKoYoVSmw",
                    "8Q4AJUAURgKIxeNEUQ1SVjDBkGk8yxQ50jA4IMNBsxqJTQNYMzF8vSDRgYaBZhEDhAhiLBzAopNAts0A",
                    "H2bNWykSbRisKM+BQMMfNUyGHhgFllZiIU8fQlGFxAakUBjMlKcXH/poOnJlAgZLSQjGpgoKAoJQO2a2",
                    "OgJlCpDTpzBgGa0X+7nlYggkA5mxOgImhwNlsvt/UlIyDzIomJiFNU/M4+q+aayY8OZiwNQfYzweIrAs",
                    "Uy//5nKBwAGHBA8mVjuFeMWI2YbBjF6K18ai8Tl4qCAcN5dzL+f+3QTVvfag0eihCYoAIAABLuDQD4qB",
                    "GYCIGxhWunG1CGIVAKDAABVSrAoHJgQAQhAA5gAgMhYBYwbSbDugPzJMDyYTE9HjMAgiQ4iwVmBIqmH9",
                    "rmQwoGDoFQhhzBGGkIBxswNFcwNKU1xC4ACuSgamkriOIcACApjaDxiFABlOG4CEpkrMkUKrVDAIGyoK",
                    "5iMQhnOLTVlHmov+sIl0TAEYNgkYJqRjgYGNCoYnADcGeJUqmlJjIlmS46ZqM4cT0xDAYTL/+9RkW4b7",
                    "O21FQ93jcAAADSAAAAEtHY0WD3dtwAAANIAAAATPOmsduAkFDNTvMdhFlgNAbfxFZebBTA48MYOQyych",
                    "4WoVtEgd0XYUdMACU1KWjGQfiiOd/Kafd6FvBZdmNQMwEWDqgbbt0EQPgkMExpAuBhkSTXLLMcUh5KmQ",
                    "YdQxEGEoUJ8itOg1iHEPzKAcARLLvxCXxiMqUQao4Y1HhjcILMz19Mji9v8+V67qRBcF853n8lfxAaFF",
                    "bncsKlikj5ebf7+vf/Ws///338/1rP/3VQwJIYDA2mBeCGYRzmhqzg2GDoA6YBoFYsAS3g4A4YDgFBga",
                    "AJBQB4wdQ2jyonTGAdDEIMTAACQ4GwIFAKCAHB6YNhYYByCZ0hGYaCYgwW7L+joKAAGBEB5hGEpjIrhr",
                    "OLxgEDq0R4M0cUN0LgEGhigJpmyYBm+MCQbnBYFg4TUBgUCABDoSA2YNLcYBg8NAwYBgPvqeg6DJgiAZ",
                    "h8CZ0KqbgWmSJhgYOmMjSt0xQMJAIGkRvFmBgsx8BApIh6UBkkUAU7MnCzPMgxkMd0LBiuGYLOirHUBp",
                    "soYKFNdKxEplgODFL0EAQTGmV4KIxgFCAKaoomyN2isRM+ogCvI+KcJwLkd5IRc5EAD3GMDpgQci9CNs",
                    "wKBEvIQCA4tmJgIsEFQHIgvKDL6B8Cm/m4jGwcNP+7MCp3tTVcgKNQRRY4SZtc+ontO9/6kv/dhR63//",
                    "/3Ox4SAsOf+8fr1VYf//ob4bJZMoyACTd2WqQBAMgBEp8wKDy54CG4GEgVwhzU7mZyCQFY0IVjGIbMfi",
                    "8w2CTAIDR5MViM4gKLQBYQMRBQCBmDgJZ8eBjECYzYxNfPTBwYQhgCBAhgLAMXptkRAWF5Spgaz0YzEi",
                    "AxICU8HB6+zCzMFH8CTTPIZGARCQxUUADDQoxIMEgyBpfbp4YpkJBgpYqPLURVlbvA0aYcCShUOBgGRp",
                    "QC0C9zk3ZS7ktBgRFtU6e4GB0aGC14IL6K4MkbLSkQpKtoagjiKPqnH/+9RkYQD5xGPLU5vTcAAADSAA",
                    "AAEsrZEiD3NtyAAANIAAAAQIUCHiEAvRWF3LFJGXmBwwifMCEjAsbQTpdptK8S/a2CC6IKNq13EjEAJH",
                    "ggItsw5wSAokRmEonruAxguwIghIKBBhYRhwIEFqAUAQLUHCxAAghQLKdc/Xd/hXgONRvKVLtou77r7u",
                    "5Whxc63vXdcwycL///pJ8WA5bkFAHQwDgwIRAjDHD0MK0MwwHk6jKEFpMK8LgaD7MBMDAwBAJzAxAcMC",
                    "IC8xMEQMNoHKB4YzBhi4gGKQeZnOBlvjHcgMaEH5i4ugIlhQHAoLGFwYk1Bjql5Qw5CodBwHMilYBcsz",
                    "MRQUmTFgNDBMYWAJhkFNdglYJOIaBaShgELDwcMDjQ3q+TBgzEiAzwaAwwDjAQEScc4MFzDhorOJay1C",
                    "UZwUmyTgBEUOoXBBUAVWdKVypmRKFAASEIeYomhiYaAumPrwBCgMNpvGPgAcCtylzI0wkxR4GBgWKBpW",
                    "dDiucKFBAGka8qIIgAYu/MbYYDQRIJA0MGDGB0cPzaw0dCgsMmKB6uTCxAMPocRqWGTvXWxBnRdwEiI0",
                    "ZAocaACAcWEDCxIMC1BwwNHQIxUALRKrJ1mIAxg6yDAAGB6eBZ1TRg1Wdq9+7bj7S1ObGsuf////+PKs",
                    "n5////r/3leqv9CtTJiCmopmXHJyQFDC2ODQwlNVVVVVVVVVVVVVVVVVVVVVVVVVVQAAMFALCwDJgMAF",
                    "IQGByA0YKYEZgYgTGCarsZ8gCJgxA+GBuAKYFIEhgEABCwHIYACDgO2JAgDQKWAKBRuKBEFAs1rkzpQb",
                    "HRMOlwx0FjAYdMKDIwIB2ztVHAEKAlrBhQKpcmIiyaU7JiozmGByBgOW9BgcBQObWVqJFsyYdsBbkjWj",
                    "gb0IxhcSjQBSqMPiIwyMzLQtTqS9MCDwAUBcLa8pMdBAwcMt/SYbRjQ6jBKYEjlm4QyddwiFgIBjo2FA",
                    "Uw0KIBg/QrATJIkbAMNGXDTQlkSuyIgK664ECRD/+9Rkbg77KmNIE9zbcgAADSAAAAEtGZMcD3eNwAAA",
                    "NIAAAASBCNRN+CBYwCCsdAUESFFBTv8k8uJegVBC64cDGUmIKtgEnCARX4FwBYNQZ0oAVlEgRibpPuXH",
                    "MsrRCHiILVsZOYEFBgoqi4LyPow1Pp/gSDBQdBDuJERgokuFdaj4cBxqnws/O9eYCC5MZZw/HqWxU3lh",
                    "vcTm6gCAF1QdrleX288u/lhuq5IfjtpwNAhMCUDVL0KgVBgBpgkAVmR2oIa4QWRgCCYGESB4MAGjAHRg",
                    "WgJq1AwETAgBUA4OK0RgMYCgOKg2YZDCYzd2CRdBofmFQLjQRmBgGGHACDAGJRNxKgGGAwEoRGCADFqQ",
                    "KAhmY1hmaEQKQEoEtniHIw7AFyHKZoVQFMMgSCoGCgvF5wsGRrmZhigCaa66DCUPCUMyAEgwBqQQgggB",
                    "QKQTnMJIQoZLF5mV3GECM7aphAHhASCITqMTcpIBEJFQv4MAgLhswgPDg57FgswUmAYOBpi8XIWNrYlQ",
                    "oQFU6ytieRhoKHLgWNB0YAjTTAoOABHU/Lca5MCmmhAMRaTAFG+DmcXlHQALAhJUxOHW3dnryEwgIgVK",
                    "nbAoCMIH0wyMk+rL4AgeDyFAAMg6m0FwUEBxgKwSSRkYdB0SL5QwqiSC8ymBHfoaXDLLtK1gmBX/jQSb",
                    "n//61ueGQcrTjrc3J/////7JBkBSq11MQU1FMy45OSAoYWxwaBwABhhgxAGlgCNAgYBwApgmAMGEONYc",
                    "HABhgdDSBYBQwAgFk5zB7ABQZAgBGCAUEAFmO4ODgNGFoIM1MABhMmHZPQxfMkgJLAamDoBhQOjGQHzA",
                    "ABoGbEOgYYUhgDhaQkqTMCwXNtXyB0MmAQGgYDhGAIyJBieC7T4FjYoAwcWJhACpgqDI8BxguE5wQ7YC",
                    "IMvVTGB4HGDooiECGlPyFwuQCcaMbB34iDqHIpyBkKNANMUlAhgk0BgcZu2RNYkIgcAFdBAOJQcYPK5u",
                    "tyI8ryMCAEDBIw4Y064RbjD/+9Rkbg/7nGRGA93jcAAADSAAAAEvIY8WD3uNwAAANIAAAARgkaJ7OoBQ",
                    "FFQoljORJSZGAOBAAncYDJCMXcnJGhIrehoiokkOs8wGDkQQAAU6R0IGLjkWYkifCGZiceLqrxkSEhiF",
                    "6lQMyWmaQVB4CAMGB2dxbKBSCLEFvXEHQYCWIZ1Cg4D2xuKOk8OLqdtrPX/jBRVBifW/5NLcx//3cmrz",
                    "sg0DpA2uextcff/n//wYo/FJ1mUttHtapl1owUwPAcAoQgFGAqAIYFgCpipo6nJYFOYGw5xgSAkAQAsK",
                    "AYgkCRWZ2jAHAKVoMEQBslADAACgUAVMBEHAxPEFDJrAcJgXhgBAmAMLAMBgMAXoir0nRAAsYHwCjbEo",
                    "AoBACJAczAaM3MH4C9NRmbmDgDgOD/KABphsrJzB5A/MAUAAwEAJAEBEYCwChiYk8GAGAIjWzARAMmBk",
                    "A+XqsQIEAghHpgoUR+CGoGDA6eNdgIFyYzUoFMRnEHCmLuhIjAYkAREQJo4q1GCBufwDoYUE12nBUECq",
                    "UVWidNJRgIDQ8fK0IgCSkg6aTy5S/QSCCQBAQpqi/FO4QEcoNZgAEjwNQ8MINc1oEHhZLDYoTDVAzDjQ",
                    "shMYVFICQ7sz7MB4JGOzWY8AyeW1UBQImeREhQ8srcgxMPB4aw6sEXcMlpgyIOi54cA14GBg2ZgCQhAM",
                    "OY5c/ekETNP/BmaNPf/us6HlKCAuxexnpAuAM/5z//cBJuM1fY3eQqklctxTAaCTKwHTAIACDAXjBSAn",
                    "MPWA04ThRzC6GmMJIFAwIgAywAeCg6S/CsTuoBTCBAqBgBYQAIKASgQEoxI1qDDaDWFAETAWAYEgEDAF",
                    "BoMB0AtdLQVURCBQPA5iQDSQwEAPMCUDQx2hMgUNMYJQCKQTFR4AYSFGQuoX0LAJ5gSgXCQC4sCOXdAI",
                    "Chg0FdjAC7cpahkYCIWgOBAkToICiAFyZMVqyQVABKw4uPMwZCNkcGINmHQ0kwnssgZuQNAUSGmXt2HA",
                    "JGBqNKz/+9RkZY/8AGRFA97rcAAADSAAAAEsrZkWD3eNwAAANIAAAAT7MAwAiL9IJTDUaR4JYtZxCoOE",
                    "wwLASUGAAYTiuasjoAQLT4UNMAgcMRxUr0mMKMExAAwzIGQ2W6HSzMygTbWBmcmAoIGQogjQk0y5hCE5",
                    "jgCBQA25QOhKYmjWUIpO10OwiFEwiGYHCCsNdeIw1G1xbzK0EphGLZmoArMR4DkbgAGQQloUAliuGf6/",
                    "FDwoAz/9R0SAeRb//xmbT7CIFl7Y99KVFj/w5+/zwLPU9mMUx70mktYNQSp1mBIA8JAjsjMAkBgwCAdz",
                    "D7qRNQoCUwpg3DCuA6MAwAsVAmMDwBFdj61XqMKArWcoSPAcYdAWagnIc/BEZEgmAgwRsMAwyMVwUZ1L",
                    "3CKgHCIUF0KYDoFmBQxGwdbGeAdBwFtIbmn+Y9gZD0hf4KAuY/BMmwYKAOCgCEYYGQkWAoYpTLnRJRQD",
                    "CUDgIgJny9jMgBkk635gcQHwSqYwCiEphq5jAB4MRgImAFaHggCGAAE2jlomGFTecpUBicBooM4XeY2F",
                    "LjSmSEoJMRlceDrPLCBQNUZswnFuWfSsQhgzQMX7pI2pQYeAwGBjVWZRYxAVxLOLgft8DAADMWEweILY",
                    "k1RQGmGxssJH3gLAjC5PAWgazTO8YEEAdISgEOjSSMx0PCYDRmVIJSqrRQP5UizyErDSUJAC0DX//++y",
                    "kb/M51PKRc//1QY2AUAk4LfOvCTAjmtc///YwBYxa7qpFGqqU46pKgEABOmAEAIYCIIAIAEMAEC0LgWC",
                    "EH8wm6+zJSBpMG8Acw9gFDAaAZAoDBgpgHsnclnQUAIMEsDxoyE0LgIGAcCiYVaJJisBIhwGIVADYuiC",
                    "YMoATFmuRwGAcA4DUiA4YCBQCCqE+Yg5mZhVApigASmsvUFMGMAF1a1YQABGBcBelwYCIDidIWALMU0e",
                    "Nry/pKXsMDEDYFBoDQGMqVSMEEgGAeBqVuYIBB2JbCELoiyJ3DB5CMICFYemd8lIBh4KyKH/+9RkYIv7",
                    "SmZFq97jcAAADSAAAAEtOZsUD3eNwAAANIAAAATVTGECyd0PA0KW/eueMVlxICVxAsBUxEOQ4WPct2Gg",
                    "UKTtAbVC87kN0MBlpWCnxeIxeZSIEPvDzKjBRSNVBOWWsRCEDACRdHaUbVhEJB4QU8wVQaYsKISCJ61S",
                    "ipeAIxcaGr6nSDKoL8gT7MrJ8DQZrjwEADMAjQAC8vOzXW+c1xRdZnedWwmlZ7v/yw5MjofiOXO3EScP",
                    "y///6zWH5vf8wxyUlVwKFkrDgJjACAXMFYCoQATmAEBKIwNjBRCrMeK7Ex0xwTB7CVMYgCUwHgBACAoY",
                    "FQEkWfyTjIIERskwUlnwAAxhqJ5rJmpxmIphUAhheAquwcAqeg6ALsLAlURDF0AyIKF3EQCmFIrgM/RK",
                    "MxoVGXJ8gAKjDsIJm+7YoEBh0ACAEwED9L4iBI28WwMINM2FDASGFwdAYaCgCIYRuMOj4w4GHOwZIME4",
                    "5bMQwcFYBhMFIemSAeTC9VSFmAQoVAYtdwEQwAcjUjpAwITDjwUAJgspkQdrU4hDJjoBmBge+r1CoFCy",
                    "gOACMvM9MkSaMKHdEWNRRVMhCalzN4GdIEpY4oRmmxO0/ZjdFEQjfdJhBow6EiYe3KsPmREwaoIpa50W",
                    "4BAKMqhpobuU6hxIC1BX4dleRDGDHICYLKkMWSmfRQ1+U/z+6zLATguxnSMyDBLIN//3Zn64MA6WfO/U",
                    "h3vdd/f/milLKP/eJQn3HCtkEgEAAGAFJUGDCBUngYEoFIkBAYCoARiPR7mjSBMYH4oJiLAOmBIBgYAI",
                    "DxgHgEqkZDHiEATDEbS9aXQYEBgyLRq1whwGGRi0AhgiABhGC4MBgOR0wMABxIfEgHBxNFv0BxAA5gEK",
                    "BoXqBisJwBA0CAAmaYCEEYGga3BkDKBgFjFcTUFgIITEQACpvaGoiApOJcpgKCBgaIAAABi9OrYYGBBQ",
                    "1XmbAWkSwMzYZAAsVrzWTBZFMKBpQJdEZGAOULSlgdegYKz2I6EiGrz/+9RkZQv7f2bFK93jcgAADSAA",
                    "AAEtzZkWD3eNwAAANIAAAARoCSZigkqcvJGy2phYFBcCSFyiqIzC6WNmksVADXU/BAEzDBGbaDcwuA7q",
                    "aRdtK5OcqLA5cPBIWqAOo6xlYVhwchhqa8zHY/EgBAii8MgmPGahQyaHY0QBkz8Eoq3SJEAEMMBhAAiJ",
                    "C0LQqtjOAOYm7aRgVCJbWpGM//92lQlYDvZ60TBu9//+NW1HhQONOs/8FUd/ff/9c2X9h3DXvgrT/Tee",
                    "+crWFgBRGAKYDgIKNwGA3CAVACCGYnSX5rdiZmA+JCYVwEYQD4swwhQBy74XBVTcVCMxKFpIswLAEkBg",
                    "wABQxV+IyAHQwNBIskDQIAIVGLwBAENRoDh4SAqAoGKwDBmFgBMAQEMFhdNG3hBTmiEBC1AkAhAMwNBp",
                    "jKnE0VQHMKQ8FgPBocwIFwfNajZMNwJLxGDgCBUCTAQDzDwOBoB2wLChUZEoTbYcCysIoUjWFdBAZQOp",
                    "XfMJEkSFTSmuSxO8ITFaCVbgISTfymMOAcwCBElUEhgA0SyBaakEQUIiI2CugJMFh8nR4GB7c0M5eZVE",
                    "bkr0wCgFFRquIv2sJZCqQNcCEWDqNgcBS94GZSzHAdgZAJiISMiX4OgVnhkJtGLhDIpxgahhiAMhwKcC",
                    "Dl8GOxsEBys/oKBJg0HkUVgZdaHQKAUBChNOtr//4mMhhi2OW44JAG3z//VbdlJp7Pw33XOf//+9CMBS",
                    "P/+Zc2p84Br6KgEACYAIAr8FQFYtGYFwBRgKACmBUB4YGhTpsmgvmBEIaYLoGoGCJHQKzAjAcQ4IwlYb",
                    "MPAsx6K1yhg0EY+MHDM431juBMEh8YkEZlAEKFJImSxcYLAI8YCIDGHQwTFJZLRjBIhOTXU0aJxoUEgQ",
                    "lAVHwsRRQDgIJoZgUAGVg8jaShAODg6AzheMYUHB4w8FTAYRMIkUqg9RxApAxNIMP7TCULAYJAYbnIYQ",
                    "YDAjex90gATkwggBwB0LAwHJWLwAz0hGBn5TqLj/+9RkY4v7gmbGK9zjdAAADSAAAAEtGZkcD3dtwAAA",
                    "NIAAAAQoEI7oAzEo1R/ucjAjAZWJGjR0KikwuSTMYsbZkjeigKMcAynU3ayDQKTEESNaKZeQYCZhRKGL",
                    "Aay1coGBENDwpGhDSPizEwKCgEAGgJvoyGLzUPGdxlN0xwqAjF4CLhgUDt+KgUxYMRCAV8LcAAFMGssB",
                    "AlZDUkGh0IGOgsgRc693/+lEQKX5n/0JZrXP/n/SxMRAmA6n/+PLnf///iBcus5blch/pqJF0tggBUwB",
                    "wETASALMD0BUlA4MCEC4wxhvjRjB4MGUNkwMwVTAQAPKAIjAmAEDgFjAYFl7hUFA4GCsA0XTA0RgQNpo",
                    "7C5oQBph2BgVBMwqAssAGYhguHBKOAeYJg+iWMgwHAdohAELgkMLUYEhUkuOgEGAuVQkWSMgiHAkuUwJ",
                    "BCCAaC5CAJgCAYAAcysUMwCB0wJAGLjQJmAQZqxKpqoFo1HQcVDpKUKxQNiQQdk+mfl4YRwNFQwSRpWL",
                    "A0PA4LDBGD4fj6ix26MgcWxTVIgAsoTJ9JyoFhEeAYlKS1JjCCd4FKRKBpM4wUtMPByYCL3L/RZBpoRH",
                    "S1laVGzDX4SA4WyUHAZgZIY+LmDAA8Dqxv+gyYYBI0L0Fhsx9QMTA1L8IUFQExsOYSmgo8X0MXLgENsJ",
                    "QkNXMsaTQRNCfEo0QjQQmwav////oEODeZ/qpekHf1zP+QWuiBquP//////4XGsxW1+71nTZ6wAAIwwC",
                    "Iw+CwiFgUAYwcDwMIYwaHQ0izo/nm88CgIz6IoxxEkwtE4wkAIwmFwxUCFAVRpfMSEI+MJFAwMBjglbM",
                    "2g0yoMDHw0BRHEAzNks0zKSTExCMdh0aEYFB5QCpejuYCAZocUmpjUkClEJCYqCIQgIAAdhYFHBlo7GR",
                    "AIWAGIBIIAUh8ZVWAYfzHQlMAhpkrFDD4xQBNJARUm6iqYinmTkpppubOJnIjBjJKDgZ6GuvyW0MOEAM",
                    "AGBAivFfRFx4fMBQTLiwyIj/+9RkZQ77wGTHk7zbdgAADSAAAAErHY0kb3NtyAAANIAAAAQMuJgcjqQM",
                    "UDgYAMjiT+ROGYwwtHsuKApkOGyYYFiEAEYAKDLDIxIKZWBQFFNg4hDFaRYrEJEAmcGiCA0dBDBQYw0e",
                    "MPC11RNjJjJKYeAgwELzuYYyeDw2AgwxQSEgguYwxTAEgcv6YEEgwMhbJDAhQOJQyDMHAw4AgQwQQMIA",
                    "HCnq28P5IhQOBQC1t0pyOSmh3EGYKUs2h/FkZAHPJGc4g/GH9uV/zqdj6yr2F6UACppDQByA9W1QUwBQ",
                    "QjAXAwMG0KwwEwCzCHD0NKQGAwighzAMAXMCQGEQAIGIA+xUGBAwEEiIEmCgyDQoYEGhiUeGBBiUEwIE",
                    "IKDRgYEmFl6fjDIyMDEYQAQWBAWadEYIQfMDCFmbLrqklrEwgZQYEBIJHBgcnHJAyYBAZhwBiAHq3gIC",
                    "iwrX0XkX6/TvixFnxYMYam2IA4YCAArh/GCQcUAzBg32sMXboFR0hCho0FAoSDM2dN3AgmjiYKNJ7DcW",
                    "YWNBQGM2D3Ho68sYArmAS/q7EPC7S3i8yMhhZKMDRzw+YqQt0TvgteC9E+zDxoBIQUD2GttL56njz/Mx",
                    "MBOzfSIwcOMYBVQqlbVN9RMvOXxrJpKBQ43VhzNEC0MhCTGzA5IHl6SgJYC3ZRx6KT7OW91XdW5J7NmX",
                    "8fV32v5iEfARo/cbZynuUAsTZejU8sRnu2L/859DK4tAAACwApgHAcMSMAUBICAXmAaCsYCIKJgACPAU",
                    "EcxGCRDhqDOMGAEUwBgEzAHALMCACcwmAJhxgWCBg4LKMZhqAhYDVtTAkCTAAAzBcBBYFzDIBRGDRiWt",
                    "J7GShMHxhCDRgGFKRQcAyXU2YOBgRB+paYCiEVgYvYICZC0wHBkxEAMwDCowTRQDhCIRBDB1MDQMhwsk",
                    "IwEQxMIRbYaygwBE3YyA4cBZlqgCBpiEXmOXeetDYXASuR0EpqJ7DwRWMYAMiRgwGxEHwUPGmKDJzBcD",
                    "LvMKA0z/+9Rkaof7wWTHK93jcAAADSAAAAEu4ZEYD3eNwAAANIAAAAQEaDnIRDAOYZCAMCwsBnetuOAQ",
                    "ATBRLQWCCMyjS1HUQfRqMFAkwwYjbw7ScFAqwRuLmuDDxUABgIBpwgQFOxB6wheOTy5pRiBHmgwYChiY",
                    "HCAKAygxEAQsDwAAjEgyHhOo8utrr8vUrhDYwOJDCovMhmwwkFS8UNdTlQzR6dVzL3d/uUujRYZfr/xm",
                    "o2kqPBh+cv3hlNLC2cdY/38qavYX/drYEQAxgigtlQAxcpgDACGAqAwSgKAkVYwlQgTEjNuOnQQEwuQQ",
                    "jC4A8DAOh0EcLgcRAQXNMGBkHhTAgamEQaCQXJemDYVhgMGCYSIKhcMDGGRz/cIDCAOzCEADCgAFXlUS",
                    "xICHZMNxzHgzMEBIMYxnFg1TvMJANgUGCGEJIYBFiYWtQAxJTQMEg3QCI8AYAxACRbowqFIOCYt8QgsP",
                    "BEKBO988mGYzGwOOxi/JnM04EEcVEJgsGjwgMBA4eHifBk0YmMA6w0eKoKEjLJ+iLxmCAukOFZYY/ERh",
                    "4XiMLEwEbJTugkuY0DxELG2Mng8RgEwGCVBWtGDQOFw8ogadgBgZQjR0EQFkUAtvlARgIejQLLVCIXtC",
                    "qIdhILVn1T2MYpkS+Cc7tOiEA8mCpYApigNGM0gAhYxUWAqNNlsCAaCQCCDCgdBwcNjllHuKuw9JgQCj",
                    "IWlL+///+npivNf//vV1I0WBOX/+X5pzXv/////SMhWA6G27WsU1KkAAAHAAmAsB0DQCQMA0YEQC40Aq",
                    "YBwEJgiiLGESA0KktHF8BmYE4GZgLAKM2WHMPQpb12TEsR0NjAoBQKHoYGxgKC5hUFgXA4qgANCEYAg4",
                    "YjVudFicYgCICQGEIFSgwQCYIAWNBAyA4GEszC4DmcwNGnJMAAUMOAtHQAMYHeNRAlMHQeLAPkwC3zAc",
                    "DxCEsYMOQkWYyMwnAp30EgYLoFKojAgEXSYqvpnQ0AgEEIlHh0UBQhIgcGXXMXD0OAJaUqj/+9RkYIL7",
                    "DGNGq93jcAAADSAAAAEumY8Wr3eNwAAANIAAAARRWGHcrJUCYshpOFnEbSDBgIFiE2DxKfidfd1DE6IQ",
                    "BPWZQFZb9PFGt9gqBQEeU+AaPDf4MnXFdaK2cpcYHJw0mzAoXMkkSXWIejFeULBmHASbIAConXg0eArk",
                    "0IODphlEhxVXWYjHocH6lBF1glrykwOJzSo8JguqonBafcZD0D67//+DCL3f////0m2uy///h91Hnn//",
                    "///pGZbwu/+usAgS+JgjgkkQCpgLgMBUBoQALggAowLxNjCvAoMSg6g62APjBDAaMKEBUwEQCTAUAbMD",
                    "AYIgCBAJGMwwBwMIehYXBYIiEKzAQAzBkCDBYOKwBAIyR207PG4mEUcCYRgmtwwnCBnT1GJIdjIClUHz",
                    "BsAAcGDzGD4WJJBUJjHUIQuBg7NBgeL6rjAMPSYGaUwKCgwNCpSswmGNp+ZjgGosHYcARjMCxsYGJjIF",
                    "mAQIYstp6IgBxtJBOFhkDhSYTC6B6IRickEoMBRCEJTFgG5laGh0flBLCAQYjOh8ANGIg+YKHxQGopFa",
                    "zYjFR5FhoQAow2ml0CgPFgk0UAAceNhIADCqVN7gJRFuT9yCIQ6u1pBg4JGBhuYaBaIuVLhVbIhmYGHx",
                    "oIsiQCht9HYc1sYKGRkYtlnFigpIkSTrafGymSkSDCuZ2IUOioATNf6HB0IUd/8u/+knZ3///13lwlBp",
                    "MLOd/9f5ZK/jzv8//07Cz64dxptPeqoBAAPYYEAIBdwhAeMCABEs0MACmBuKUYc4JZhgplHPgMiYNwEg",
                    "GBKMB0CAwDQFy90sBoJGMYnwy65g2NMTHQjMNAyXOWBAHghMBgcMSN9NrxGCoWgQIobeQwYBF/aYxMBM",
                    "OF4LAEEEiRDKsCQCmj43cwBAgwkCcwVlA15EEBA0WAtJgMgQwRBsCAWzgRjolm2QxZJQiBogBcwMBiPo",
                    "MhhICAATBIvTogQQEIpKApi8ESBoQDg0FSSpgSRqS4EAMYFAaAKT3r7/+9RkYwr7JGRFq93rcAAADSAA",
                    "AAEvuacUL3utwAAANIAAAARCI4kK5cAwpKk2wFMu2IgDKwbitS4nsYCkkYTACzsxJG8v6FgDBwGNqGA6",
                    "gJa0Iz9MMR6YHWzibB6jtGCQkmCYHigDhcBVCr2W8ZpRsAGAaBgeJB1KYh2dR1d8xBLQIK0YAIlA4FCN",
                    "dtwzHE5LRggAhmQD7QG3j9BKnWX/a5//91W7H/////ukIDoQ6//y/ReH/////5peScVem1FtEWC/QWBb",
                    "URMBQB4wEwDmQAQEEwMRVDEhAmMLZnQ6BhOzCtAJMKsDgGALiEBYYASJgEBAA0YOgHgcAWyUwNAbmKjI",
                    "C5gpAYxIcA4Y6FwNDBDQPML0K4wbwIR0CJ7IAMAsChq62DBRBaU5VQCAoh4FmCjAuAqGgCWcEIAyKJga",
                    "kDGY+FCEA1BQDcSBEqGBcAtF0XTAnBrWugRMAgHsaAzKgBZhGEcyMA8GA6TAWY+GgdYCSEAAYCAgYpAY",
                    "i2YAiE/CDQOOUOGJnZguJ7I5LhPBYTR4RC+gMUE0qAxTYQgeh0lMUYGOAeZBigWmJQDMSggIhPHACBQE",
                    "rEDgZEiDS+MJjxM+gEBwYtelNx3WTjgGGDxqGGoCCABzCoUmmz9ivLYfSsMHxoKIjBQHOZIpyWRkhBEL",
                    "CiYAAWmMYTgOJANFdYxoQgKtMqkQY/BG2CC5fIZGvtX1/n//6AAB4d/fP/9bIQpVfa5/9xjgCAq1/97/",
                    "7/ayEz47T//8/L/+52fKMSPqR0MA4GxHMRACAICUGABo4mAqLsBiNjExbSOcAWgwTwagMAoNBFAoD0wJ",
                    "AcoDgRgUYngKPAUh4YKkK2JNEw+ChawwExEHIjCwwE+M3eMYWLYwBCJ5YSFA3qNwMRhtIgCKgAGIAwjQ",
                    "KtyMJQKa8o0WWLeGIaCHmo0ExDmAAJiwq2zDEDVjwUYmDgyJgg6Dg8KxYDECiyyQDAOS7WzB+0N8FkVA",
                    "wWJxkIFBgjMDh9PlhBn0lLEh0xQNk1nEwlwEC4H/+9RkX4/65mTFA93jcAAADSAAAAEvvZMSD3utwAAA",
                    "NIAAAASNDADCddOMocYBQKCb8wc4yRA6KzHydDCIXYEaaZFISsEtEGAOBjs+ZgAanwhIJDVTmMwEsYRg",
                    "EQBIxKMx4gI6GFCqrFP3r9aJigAMGsc12ZgMAXYu0kkQtRDDEALL5W0wkQkCVLjQQIQgxpIhMxuMNqZS",
                    "HKMv2z93N6/X/pK7+f/8//8qh8iA/f/8+UCAHv8//73/Q6IE6GN96mJZqMAIBgwHAZ1egUAAFA1pjmBG",
                    "AEDBRjFZA4MQxyo7JATTALABAAPBgFgCGAmAOYAQNoCAJHQCDByA9EgYnGMB4JyICIAAwQgO1TCAAIwU",
                    "gAwsBUYLyF5nEALI0BUBRt2tAADp32bGB2E4y9Uxg/gxEQEA4ACYAwCamzkKSBgCxgigimdOEol6BACy",
                    "IGWFCwNJEBM4Bg/gokQAgyA8YEQS5eIEAMmIQNtIEYVGJ4HCMETAiEjDoNWZBUaDBAER4NjCYEGIJ+mL",
                    "hSsBh8DC0w1oc7IwYDxkQCa+zC46zekSQKEhEMZEAcGqooisQMfCQMCgBXkLA0NBww9YJG4wFAsUAQgA",
                    "Uw6LQ2KJkSEhWN+H/fVD9TAHBmBhJHQEMJQaUsoaK1DUtSGGTlNOh9BAAsSlr/tYQNaIYZHIVg7gl4PB",
                    "Rb7NOsQBe1oFAWaDgsHAG2kQh90Zas3X5d/8VQzuv3v//8xGF6EWv33fNBAFd////5/koFEQFVaa+3RB",
                    "p7xpUDUAgKGB+CMFwFQwEQwBAEzAtAIMCYD8wNQ5DE3AqMHlz43jhGzBbAmAAJiEZgEgGEwOJWJ0FBTC",
                    "wrJMmGodiwCsOCoPLuRdMLAHAwLGMOWnzwHjwGp7KKRkwdCcgAAeAkVGVTVaZgQIpMBMGgodHSkK71DD",
                    "E91TmMDgEDJgEAAkIqdwhDZXSlZi0FIkB4MEQwuAIIBRk7XlMgYIAwLCAFmN7kcZI5dwEigiIY0GgcPk",
                    "fVhgCTEtGZmIBaoE+UP7FCn/+9RkYA/7GmtFA93jcgAADSAAAAEv3ZUSD3utwAAANIAAAAQNDcVAZhon",
                    "H6QMYNFBEK0bIbSElYUCwYWw4PNbMFgUMBq7n0aYDgENEwlAZhVpGOUiYFAUVuZTisogAxgsGF2lHEh1",
                    "BVtyGpL6qRZjQCnBA2PDKRyy+NBd+2mmKwoUG9zk5lcSypK1lhUTINBQngksLCwxYk7mRSJ4fz/3QRbn",
                    "////fzEQjVHzP/z3cL88/////8CoBFvZyrXP///XP3vG7vr2kRDA6BzcktkYJIFosB+QgrmAGHkYvoDx",
                    "hPP+G+cCcEA8pGCABdUhgkgDiAAsBADmCsC2HA5K/AwZqmYkAMYGgEokAYDQGU+E0jBwLTNCICUFAGAk",
                    "BwDAQpbmA8BqDgJQQAAYNwJyyGhmCiBksdJQDBUxyNPvRFUq0x9QUEzDAoADCAMSqAIx9VrkGA6EclQI",
                    "wQDCpB/cNTomC5jQ6BwyBwMAUYL44ZD1CNAWFQbHgLMHgnBwdq1mF41pUoSTCMOkR35iRgABgwKBguBi",
                    "nJhwkhoSKhAEA8Cxg+D7lAwSBYBHvMGxxHhIIABMGxpa6o60hXYNBoweAURACYEiAa9kSYOgIDQXfuFN",
                    "MJQBGgNMAxLY+VQAAANiQRp+zetFqBEAojNQyOGcDBu9K04PMMBGDgQUfBg2gYPhgCjFIKE6FLIVVggw",
                    "CBVhAsCAROA8AL3zckiEy89fX//3M+Yf/P73kcJAJHgXw7jzfMA4C5/////f1SoAir68XvZOrO0TrgCq",
                    "AIAABiEAECgfFuSQBcVASVVLeEITRhwgZGB6q8aQwAZgegVmAEAmYAQFQjAEDhgRmAADmEY/AkAi6gCH",
                    "9F0v8JA8CgTGQnDAOMDgoMcD3O3gUWSDQcMHgAhBUB4VCAWCIw7DFUwVBsDDbTFQAGOXnzWWlsYnNyYH",
                    "hYIgTMLwNT4Q+FAFWmXXEIfpWhcAjEYDiYPGkuHXUDARcTpMMiI9mBn6FQKYQBbMCoACIVAIKGKgORC9",
                    "TIwqHQ7/+9RkXIr7CmRGM93jcAAADSAAAAEtCZMYD3eNwAAANIAAAAQC20vzAIJGQUUAcEhswBBjDgIY",
                    "WsccC1kGhwrBkqMKHJL1c5hgToOMoTcU89ACG84YLDpp0hBcJmAgqJCNBmOrLjoADqTqpkdSIXRmtjMq",
                    "xIYihqMulsmXTspfSMwyEhYMwMOFYHDdKQGgpGl/G/wVvGjW18AD4yoI0xH/znItTKca/v/+udz+5cqX",
                    "LfYaEAbIi33Hv18KwsKVx87/7//0mQxerNvsK8XUEMAYDcOANR/MAEAtL4LAMmAAEoViImAMoQaIgFxg",
                    "zAGGA2BWYCoHwiAeMDxDJglMMQXMKgnSOMCQFEhoAQGpmDIAiEAgsAYUAIwCIALEWd/AemiUAECAFZwI",
                    "QWAQsIPFA4MbMBgLMLgOqDIFDQKKZt87LGDDNowMko4EoFBAmCUZABl5CCJgWAJgQGCkiqAAsKQEAwLg",
                    "UPC9W8RAUwICwEDDBatOFj4FAFNMGAVSwKgswGAkaTA4aHgMIwOYQDSmD0hcDCQhMBhUWHzDjALeN5DJ",
                    "MdD4xcA0+FH0sFKDDoAGg8xsAlAt6ysCBYHAwFBADApzAufRI4FohgNFrnYDAcnIoojsx58y9aFVLljA",
                    "qIDcRoXGqTMEH5MwtwYCAyPaDKYZisHJ5lpQCMxYPob5O+Iw2YzAAhAINIwOW63YjOcjbdnhsf/////P",
                    "7vv9+bXyVgfn/+91y/0oz////+4rM1LHK/VulDy6AAA1BTAbAoC4AIsAAIQAhIAowAwJTA+ByMQMHUwk",
                    "WfDLyD1MBsLswPwNAEBojuYKA4YihWYEAYMBIAAGHhWMJQtDgJKAcFAYGgZMAQPMCwwMKBsMQQ+O5BPM",
                    "IQJEIBgAAwMH5fAwBBMFAkYTi4FgKBAjEAG0IIAQwhA9Bxr0CmAoNmCDCmjAiGCAPmAoBKLkgBGBoClU",
                    "CwQBYNAcqAdB5hMJoCA9fA6FkYDBIRHiAYAFhi93iT2ZSq4WBKloJD6XwFBwiJYkFkZTHoP/+9RkZY77",
                    "2GRGE93jcAAADSAAAAErLY0eLvNtwAAANIAAAASQxT3Ehyw4FBExMFAYGjA4KH1ii6IgQAg2UBYKAJgb",
                    "cAQFVYnMAQtSJQRmFwIXQdNLZnZhQtjUFdwMAbZHUXxDpdwcBaiCfSDxQDbFzMkACrQSBxCTTCYFMUgV",
                    "aaE8tyJAIwIGxQNmFAymi25ZwaG4sAC4btgAJiw8UdC4HNhiMOATXW0xj80llRc////uWK93u8NZwSqU",
                    "oJ34czu5M9AgDKwVn+OWX/+l5Ljq0zOjkwtdMCgTFQALzgEEQaAujCMGTJspDPv0DbQjhpPTFMtTEUej",
                    "KgTjH5FMdgQwkNDBoDQXR8KAyDg8HAAHAVTYqAEgFQXMIAOAD2hhEjCIOhxuMNBREsxkCDBgbMFikxAK",
                    "DAQVBwTVOh6YDAjPmSPSQhsyIpwGeBCATEYXDgPHVnM+MNA8KgVToWC48DwEGzAYNZe0xHkwgBLVGIO5",
                    "pxRBK/C04IAQARKqAoHGg8SA4CAguLGDSRoTSHEYCABEyETMnXTbh0BGQhDzGxEmB4Pak0qVRiUDwAs2",
                    "NhURZKDBJHcOHDBiQ4IdAQgYMMBQDKAsxAOQLJgkZDTEQFlz8vvWj8iSmMMCg4pADqZMWBQFMIHjAgUm",
                    "DxCGlwAgsGgRCtS9CcYWDhAOjgyRFQHCr6hAuZWMFYEhA9bzwJRQLX/v9//5zfP//1UiDTq+X/v8YbkP",
                    "///+sORyBku/tRVAAAAEIQGiIAdayvRUAdCSFwAjAHAHMDEGEwhQpDETEqME8HE0lESDEnCBMLoMkw4E",
                    "IyJAgxZE8xXDYwFB4eGkIB0wUAhaREAiZiQwXAgwfBAmDsw8AkwqB8LAeYFAYLA+YHi6YHiAZIwiaziY",
                    "OBaYNCGNEODQDDgXGgNKoHyuJLJMLhfMOA3MEAzMIAABQjMMLAFJ6AYKTAEAQUDZEIQwAJgkR5tQcAgD",
                    "AcAJCgozMTCDHlE2ZHL0tACAkkFDDQIqBphwOOg0CIczARYWQyENMED/+9RkaQb8BWPIM93bcgAADSAA",
                    "AAEsYY8eD3dtyAAANIAAAASgoEGIkpghWcFkGAEZqpkZmEiEBLnExFGaSreYO0VgKQIAD3wMZEk4xAHs",
                    "LMQAUJZni8ZMQGGWZ4aMaMFgwbMKFzNgkwEOMnGrLtLqtI/FUMMbDhgfMaKTJB0IJRAPgYpAo0YELGAl",
                    "pkhAZSAHDPhiQiYeBkSyjoIwdOtDBBAYKHAQFMgCQwRKAiMONJ7GO7n5fr+4/l/dd1T8rOZy1bu53JKs",
                    "BYfyvhzv77fqSfa1p3wUASX+XWFwDi8IVA6JAHwcDkYLgXBgBgdGnCfkNGaGCSBIZCEuYXAWYBAUAg9M",
                    "NhFULHQLEYBJCBACmBQAs9nkGTAQDzBkBVkAUEDDwHTFABjA4NoIMTZXNFwZMMQkMOAOCgFFQFwgT32A",
                    "QApxuVbHASIAFFQmMEQQAwEuKhsjSYBAmxERB4Yii0TBYYHoSZ7qqaSRAUgMGLgMpFQQFAkCg4cBKnLl",
                    "CRMGAoEGgCOGOCSdKCEwgBHABD0ibDB1k1YICoeenEmhJZjosZGIAQKAokuyOJ9MVkbYVk+tILgSZbMS",
                    "IigsWAC5pkLmcqGp7GFkZ3I8YcGGUnBlA4iyjTRNReGpS2lOntDAm0XEXopWBAcuYXbApOZSGGKFRti6",
                    "NMpiocZOemMiLF23MCAVqhYJMWFSsAVrJgAQAUvlMPNjdiXqrq7lt//1//////uzjzP8foVMhoXvdzwr",
                    "9+tvKFbN2jAJABL0BwEZgLgEmAMAeFgHQ4CgwKQL1CjAaAPMDYJgwTBbTFCwJMCkHcwOwfDHUNzBsDxY",
                    "gjCoF1pmDwQIxDw0BAWBwSCIGIgYBguJAOnWFgrEYHGDIgmBIklBOGGIkmLQGGT/8m9ogmMAYmC4QjR+",
                    "EAijRnMJCghK6S8CgJmAoDjoEBUCTBoHjAMFGZCEFyqEIICEwsAsxPBMxHEEw0HUwqEo5vY4HGswSRTE",
                    "wLEYHMUgYwEBEFomLAILBowIBUrzGghRFTLexer/+9RkZQD78mNGA93jcAAADSAAAAEr7Y0fL3eNwAAA",
                    "NIAAAAQKFoGAI8RxwCmACWaEDZCSDmVLMDgcCCUxUDDB4CEYRKx03MwMF02cLyGLfyswSEgcJzDwMDkO",
                    "7BioMO4YYYJohHMTBKzN3rMOJIOFYsThoKogpRqM2uzWa7lTogLApiNacdks6XbHEUXVMTkQ7SRS+4VM",
                    "pj8TGOQMhg0WHrWVZlbZgaEDDwDacxKMlQEkQI2vkeB03nzv61/6/n///yZj2tVWkiw6x5r5Xf//pbYg",
                    "s8YxbHqwABAAQoMB8BIIABAgBTXwEACYBYBLfmAsAcrwwFQDDA4AbMFUP4z0lgDGNB2MEoEswtDQwEB0",
                    "GAkAgNT6AAHz6WA0CCmgMAWiGgIHgOpTAoDHsMCg1BQLhA+mHwbGB4KmEVBm2oniwcGHgziMDxwIS1XQ",
                    "gFxICVUpShyMCwAbRIYEAW94iAkQgXSmEwFBABmDwho6mEBCG+Q6GNgOYPOoOCTOwg8hcCCMFskYWYlB",
                    "qlI6AC76KwOFb+ogIeQ4JBlgiwYkkRgIGgaIYaABZwDIUeAghJq8bIiC0u3dYeLAeoYEAzFguCS0TIjB",
                    "oLURGBeZeLaUBiQQBlmJAQASQYtBqGIiAZZJQr+7uQKXBWMHAJ5FlMGZU1W0YYAIKNAVOJoc7CIOiAWG",
                    "IQ2BQYjgi2/OW/ZDQLnY1Il8xckA5MHYIAAUgjcza5///71///6/4F5ywqmPA/n/qMf//Wpjt39NBwDB",
                    "EAMYEgBzSzASAgC4FCKxgBgGkQCRABgYNgH5hnBCHBumAZqgFxhAghhieM7MICGGgnBoLkgDJNBgOhAg",
                    "igBI2O2YDhNECABjBICwUFpg0JBgMHoOMgxNHkwGDMsdOevheDAcMIAmMPQaQCkQ6K4MBBPJgrGQBMZQ",
                    "ibALBSYOAGMAkYCAoyYKhEmWyAwoCIwaAow4HIgDwyTR00QcswDBQwMIEDFGkiHDmWvGAfEhMLAOjwPJ",
                    "mgEC12ggBRYA3lGQcJAzCwD/+9RkZA/7zmpFg93rcAAADSAAAAEs0YEWD3eNwAAANIAAAARmJ4GNEQ4m",
                    "OwAGCQ7mbMTmGgChUHgaAgBAMeF4SB6UjoSwzftl6BoXo4Cg+DghBgIiwMOAYQCSYGgCDgUMyQcGg2Cq",
                    "BGpYEl+BENbZkc1H1ew9v8M4bjjjMGYQ6ebrx9I4wODEaA4HAgbNA2qwHAWGDGXcBAvIsv3r9ZRpoys8",
                    "wX8kTDWA0hgaBxMCEARzusv3v/////zyyZbTsHxa6LBFn/M1B///1a///v5/U/X3v56swBgA2MBgH8lM",
                    "AADQwCQE0xRCB83oqCYYJQMRgViymdtfGYfIk5gIA/GQQ3mAQGGEYFkxBAAIQwNFyioBBwYpaA4SngFQ",
                    "hJgBJQKMAQtYgOjQMhCYgBGYpi0YFiUYGdSdxiYHBaHA20whBQw0AdmoUCZZAWA8BEqjQYGhCPBKKg4Q",
                    "Aq9BgABrlAAHDCYIygFTD8fjBYFzEYbT5EagUqjDgNKHeukxMWlKRAJQwcq4ZctYRDcaFxUAYYIG1JQE",
                    "YRDCmxmAU3yQDGkAWTAc7klhp7GEQ+ZZHbGzJgUDgIl4YoDEKymguBhYBPGYGH4YFEVA5Cs5AhSMFghN",
                    "IxAOGeiKQAdpBgbFQQYIDYsAmerj7/9+AZbRdmYm+qq6riwFDJxuRBEJsM5oEwOADBSkBAKZyAQaLCG/",
                    "z/yxl7/TyJUgrtebCOjVeuVqz3H8Ncx/////JuDfy4OBL9KVs2zw+6uRtrUWKVrU+tUIAwCcHAElqxID",
                    "QcAiCwA5gTgGCEFMwHwGjA/CCMDQG0wlRqjUklcMpcPgwYgGTK0MBIEQIGZEFZICpgWBq1TAwHCIMV9G",
                    "AoGxkwEAxyVjjwZpRGCIAGHQThw8mTgUmEIhGH0tnb4blAOwC/pADBEBr9FQCBIB3uMGgJUrEgPHgVFA",
                    "0MDgQdowJASGkJggAkUAMwdK0wCA8wuTg3OXYzMNSVmGfQc0IyWS0KhEIx4Aig2JAk4pgYQBBEKofAQv",
                    "a8rePA//+9RkYYf7Q2BFi93jdAAADSAAAAEt7YEUr3etyAAANIAAAASKGSwYqMcDwQ9TAAoOc5IzcAjB",
                    "gVMOkhvizw8XBkJKCsktxN4IpHiEQDRQKoGMDgFa5gY/ERMEYHMLDFrYIuhs8lGAAKLDowADJOw2Rd/v",
                    "/llllTMch9QBQtD40iNx4CGFRKdXHhQDwADjH4DUiHAOEQ1X//+AXKsrNkF2igMwIARYFwHJdb/8fzz7",
                    "//rf6gdoU0YBB0CIvoDM8Oabq7CK1b5Mg/KwGBOAQrEYBwFoQASDAFDAGAOAQAYABmR2JQNjCvAVMLIL",
                    "I4DzxDPoBKMKUFcxLAIwDAcQhWkYkaYRBcLA4YEBWRCItMHDss8wBCZsxAC5gmHihpgmJJgsGphAAxmO",
                    "B5hYPxi7RZ8SDMmtUoyERgqALxILBwcGAwPCQVSIw2ENlojEAZBl2AYCr9mBoSCw/uMYtC+YThAZAh2d",
                    "JKyYmAkYLkUYhAotkwyICEGAgKBgJkIUA0C4ZIQuMCQJKgSmBgTNWC4XpRxUaKCQjAUCR+EoZmGlCmBY",
                    "NtJJiRIgRMGQHGiRTHMUQFj9hkkRpY+DQrFhZbsBQMTjMGxiIjUGQNMWQOipgw5BkSEoQAhi0HTA5aru",
                    "D/////79CPAO9RgoJyoSUDxCOIKBIwCHMzgJ4iCEHBGYIBEpg7CWEg7//2s/9I39LrceEAZDwHTN3vNf",
                    "f5rff//1vjIWpzJACLylgBSsIMe/Wbs9+h5u3Q3/cY+38QBhCPAUCoBhgDgKiECJPMBAkBYBYwFQWwIA",
                    "ASgCGC2CIYK4sZpCYmmKCJCHBKGNAxv0SDCJBAwAwvFMMBQwHC4eFELhGhUmcCQFDgHBgJkQGA4DTBwa",
                    "zCMTwEJJkIJhgIGojm0T2trFM8iAMmO9YYAh60cwTAYwqAKMGEYPjQTiEGjCoIGqEofL0MDgZMAwAR2C",
                    "phFAjGCBbnh5dmgwQYeORpQAJqmPSqjQAQsY8CgjDhm4POCNA8WV5ACxoUjQRHCKNC2FGTT/+9RkY4D7",
                    "YGBFK93jcAAADSAAAAEtYXcUr3eN0AAANIAAAAQG6YiLhlICmAxMcg6BmEGFQYGhAupeYJPIsEWAmaBI",
                    "8sNv/KkkImYOIxfmCy7ycxh0smSgSKAY1cDBAHDEkuMjj5VAxmCiIZPDBrTquW//f/qDUAECmKSWzcqg",
                    "sw8O0KDDBqOcJMwcAh0VmPgiQAwwuK1OdY9/98s5x2mwzfQCh5Sx9Jrtyzj+6v3v//7VqrYXE8CdEuSN",
                    "Hjhzv40h7FHrcGsqWieAAAGCEAQYCwAQgAeZStowMABQKAUYDAGhgJgFCIBwwYQZzCHFcNJqsIyaQ8DA",
                    "oB1MahkLvmDQQA4VWDhAEK/W2TBSIgbC4HSEwQBAaA4UAAwCDWPBQCQgjygRTBEfwsDRiM558uBCMLJw",
                    "4GBGH5iGAT/mBwNg4IwMEAhAFDUoCQaD8ZAAwYDN3TA8Q2omC4OosRkw3BMLgmYsIQIGkCwJMKl4zgAX",
                    "OMFBhp5bcxIBUbhAEXEMDA8wCAqQxQJU+QcCRYkPOZAHDJRg3BglEhCejDQOgBIVjGQITfMbAMFC8RAQ",
                    "wAK4cYYyy2EAuUFAPUQHQCEENyjCRzMXgERi4zWSQuGjFfoGqpApiY1BAOIAyPJaf5//rvP3cJAURAEw",
                    "wNw41pqmTB4GKEwmdjppvMSgYwGSRYXkACMrCZV+WP7//x7aqwjUEmBRa7OpVepOb5+v7r+/+83/g+VA",
                    "EAyeXjQ1ON6xkkB2RQskPhwAgBLTAYBUwGAHioAQIwDzAIA8HgGh0CsDAEmBkB2YOYFphYA1m32IgAmZ",
                    "TBrCRGAhDAmCxODwB9MHgHLvmGYUDQOBQEWgKtMEwYQoGQCMOQJKAPGQMMNBNBQOmC41BcSDApOz5ECQ",
                    "gBFYSIJCQPTCQAF4iATlNhCERgaAioAADQ0CyVJguFz/GDwWM3MDgZDAcVVEBDmGwIGMIMHhxcgqGmNS",
                    "GZyAKXZiUipxjQdAgCT1AQGZQYBLxQHHjKAO84gGBQPXCMblecJTdHj/+9RkZg37VWDFE93jcAAADSAA",
                    "AAEt1YUUL3etwAAANIAAAAQKDzu3xMmg0HAYyyIVFAuCg4hFUCGHgc9z3kQYJQOPDKByUGqTWyDiw5Jg",
                    "AVBx+FQqYRG0iMQ4g3oFnbMeiAwkBgQKRAFJTW3r//vMp1XRMLUcisdiASGAEiDhSYJPZt9DCxHFhaGD",
                    "ZZJf+GaHLf/v+75WY5hKzBwHHgnAcdwdqTb5h+v/9/hd+PKcqzmAwZE7w8Kdb7g3LnXUU1HFn0BSrRHM",
                    "BkARK8LAUmBMAGHASEIHhgHACGAQCmYI4SBgcjMmgtNSYv4bZgmAbCSpGAgDGFYWjQjMEMJQDRlBABhg",
                    "UA0EwMCsuAgHjwKDoBmAIHKuMAgMMJAbAAMGPgzhgFARAT78B1YTDMCCIQBwFR4qHYAQbqQQImBQAoog",
                    "oLlPkIBGDQIzxEIbEE3QgqI+YXBoHHmYFoKc7q2YzhEYbDWhspiYKBcnGrsMAl8FAXdBoLhgMwWHC5Aw",
                    "hCZGl4zCIWHhIB6MLwPHBSMVZGCgMEAAs4BQDmGYhDwLEAIA0AYoQgOJCoVQJKAskQiCEmBdRRAtnZgU",
                    "Kw0DReUxiAtppgaiACjRsJhMBJgoCYwAokFvLWH//938GGBAgiwCskDBCMBQqMNAcQeMDgrNMiqJhIME",
                    "Q8MMwFIQBQnxu93//eGv4vtju5IShUmdM49gmd/n//93+896SeW83EFBTVCwIEwEzmfcVH7ftucpoXMb",
                    "lMpVAMAA4EldJgBgFGAYACIAMy75f4wKATzABAKAoGJgCAxmD+KcaIFPxkBh+GBcDGYLQNBgDAKmAsA+",
                    "UAHQUYEwBTiJ5iQHoBAFMAIBB4wsA4PAQI2jQOkUMB0FkwBgOUJhhagKK5MA4N80RQAR0AUwCAuQuAGF",
                    "gAgEETAZgNAZuFGzAUArVtAQNqtUwX8lgQB7AY4AEDgqWABULgICFMIAMox8x2DEJHMigkwEAUUhCaRY",
                    "xDwJsDIEKgGGQGYfNIckyoLi+scKgub5lAoS4cL/+9RkZw37mGlEk97jcgAADSAAAAEvYZ0QD3uNyAAA",
                    "NIAAAASh+MmggLBk6DwTOgFasFB8YGAJjYyDRAXsHH6yrQJIEVFYsenRMEhVCJOYBBdb5iE0EQoT5NKh",
                    "1FIwWpDsQdFQEBAMBAs4qPUu7l+//+2XbMOgl0CEDJhPyatOhgIKBRBGsnuBh47Rh4TFgDmBQWwaly5/",
                    "9y1+2Ey3tkGhBMyISrb63//////9Ydyeij7DV8qihu+H/peFr///y///V23/8vdn+qlLlIAwDgJTALAL",
                    "FAIx0E4wDAETAIBaMAQBkwLgbwCAQYawMZGFkTO8GEOA+YdQBI8AWYAIGJgLABDgAQhApTKFQGwMA6Cg",
                    "ATAsAXYsEAVjQEpAAQYFQGrCxQDUwKgUwYAiYMQGAsAkYC4FBo+g2IMmAIB0LA/kAFAVARKgBooCkyAD",
                    "AGBUDFEoMAyaRJBICWMGA2AlBI4BUVAEVNTBlCdMCgAIwYQxDPUAkM/AEwulzFYJYkIj4phHnygJ448Y",
                    "yDhMEl9gY3vcFQAoi0oQAREswiShJHmEQafUV5psJgUBmZCWDAQYTMaarcQUjGoKHExgLBBAyRhRiYZw",
                    "YMhcxqGkejBZlJgYYQNBoBkEQgMWmQFigFBItEMhtWhO7X//7/XcEXyYKNbhtK0QCExApzNQvMNhoPu5",
                    "MVzABSM5CVVooTICt8/L/gt1f62G/qAQqI3juTV5olz/x/8f138ufMU0TWnmQiIWD9HzDTj4f/6+9+99",
                    "+zaNZ8GdtKwNHgJ0ogKBGnkAQFzAfAxCAHAIBmCgJTAOBTMFYEAwJRfTTUnBMbEP0wKgPDF8JTBgAgAJ",
                    "JgEBaihhCAymQCD4iBQWAwwWCR4AYHKY5fYwdBlTNUhiCFbXzCsSSQBjC0oCfBy8I4DZEJQyAw0OwVBM",
                    "EA0YHgKChPMAwATHAwBpYhcCTAICHGMDAPmRkBCYik9zEwdwSBhhukpnyvZgEFGLCWPOpfgwPyYIsaVu",
                    "h620QwqQEwECJhYMSxrCMcr/+9RkXg/7JGVEg93jcAAADSAAAAEspY0QD3etyAAANIAAAARHAkscGBw0",
                    "GBwYIjgvaMHBwLBgmN5WBRgJCwvGAEOANljvDQZHBGYLATAjBoiV4IgaLEhUBigVDwrMOg4wAPRIgGET",
                    "meGCTpGFTAEBKBVsXOc//x5/xFkEDyaKioLLyC0KCqBMlJovqYLBhggELOBItU0l2Ouf8GuZ3bxz+EvM",
                    "CAtFqJ0OolIN/+/y///H9clT4yK+MgQrCtH+vmb/P//7/3lihx8i6fj1lOIiEXaLAAoKAnBoAJgMAZF6",
                    "mFGF4DmYJYkBmBW6GPeHUYGwP5jCAQAA8wGG4MDJCIwMDMiAtZJQCgWAIwgCNXpgQBwGCoZAUFCEpMwA",
                    "CQwND0wHCcw5EYhBgQKwT8Ol4YPGwvIKguNEUSBCYGBeicCgwIg1aQYdBizQcCEwSBmCjAUJmgCEAwgc",
                    "lBjAgmDEkHzIQHDq1BAcLZggJgOOp7TBMFmSrKMDQNe2/GVqhgoxowQBlXCpygD7CG71BUADJ0CBkOTA",
                    "WWSUEwSDZjyCwoAZgqHBEGa0jBMEnsUcgkgCMmHF/DAwGRIAX8MGAzVjMEw4GhrMEApMUQQUQEZ1mmQT",
                    "rVMExvAwzqhSOs93///PzmFuyZusWdgx2F4wDAgGAWa7BqRBISgaDjBbR9EWuf/6963s/b+vddmiULH6",
                    "xpb+OPe9w7/f//1at6lBMCtMz4iCLPDD5VTf/9uVKqXF++sX9bkqKwOh4CgwKgJjANAGCwCxgPgGAQBs",
                    "KggiACswLgBAUICYWgaZwOl2mgAAYYXoAo0OAVgNmAIEMRAdjIApgggfCQBwAAWFgVDAJAcAwGDzmAmA",
                    "nTFQAswJgAm6DgNRgAATmASAEYVQF4iAWMD4d40oQHDACABMHMJ9ZghBBEYBAgATKoN4cBKXZDgE4sYK",
                    "oDw8AQOAQiIBy0FAO5SMALjQO7KDBHBSMGQBwwIw9DL6EEMpAEwWlhYhLmMUDWFCoPMRh6nVPBYNDgKF",
                    "bQzD4CX/+9RkZw/78mvDg97jcgAADSAAAAErbYEQD3eNyAAANIAAAAT+CRCTAKSl/XzBoXBTSMHhg7V2",
                    "BJvFUnmHhSW3MUApOa0YIBBQAVjlAHQZBQtWk2OREIACoaZOYaNQGKxfwzcCgwUmT7OcMCrlkRFMBB1t",
                    "2qSz+c1nlnzdZX0wg1PiAFGcyqChaNAY2+rxIJGChOYlA77CgAUlfw3/6bDKfyvudt9RoXEQAgCSfc/v",
                    "4ZfzDn97+4YjEcHhlUa2PAr9f/cr34/cu583a/+75/97ju/aqYHAEssMBMAgHAHEoDgQB2AAADAPBABI",
                    "B4jAcMFQEowQRUTSAk7McUMMwUghhYuTA4GAwDxot0NRoPGJFqyYUSAFgMETFTAYERIBGYBgkt4EBMYa",
                    "BuGCECkrLNGADzFODhUATGwJigKwsEYkSAYAI8DReovoYDAAqqYTBaNAKSAaYJAm3QwKCp2hgDwECSaJ",
                    "gqSZMABiud5nQy5gsNFg3AoGRAwiTGmGAgESBOMiAHPIFAUIAUqmLBdCswGDYpJUQlvjI9FkuYIBR0tM",
                    "GcgMAgYZUHT+mAwCTAFshgELtqm7DDMXSdMv84q/wMc6MxiIR4DAUnGWRukSYurppoBr5DCOKgCBoKov",
                    "/H+fh/2Fiw2wmaaEYmKoYHgqfzjp2MCgMwCBxgFPo+EZ5//zcdtf7CJFp6QIIWg3L17/7zn17l7+/z8Z",
                    "VHXxVRl5KAxoF9//u4yNALseKWj/jowH3QCAAGAfQ8YBIAwAAEJALAAASpSYEwJJMCeYHYLRglBCmAqM",
                    "QZc1KxjzhoGBYBKYwiMYJACYdi+YDgZHwwMwKA5gSABQNCNwwDrwBgHFYPL6BQjtxKoTmDocmFoSmMgm",
                    "AQLzDaVD8kHEejCcdFhFmjRqiAGCzUDA0GjBYB4MAIQwYOgGYGAQ4hg6Ea/IZMQgAZeDicMHwbMTCtPL",
                    "ymElsMFQMSGxATVmkQvMOgh2B0CqeCAmYEAcFjRQBwBLlkwFhwwoCF2FUzhyqBIZNse8xeH/+9RkaAv7",
                    "R21Dq93jcgAADSAAAAEu4Z0MD3etyAAANIAAAARQSDAIQ1GAaNwwDsyLkuu7CXLGJatkZCanIgA4kkoo",
                    "HFEOFQyPDEZiCwBMV5MDMVUhkoTDwdjMNSH//mWu/qmWG7DrOkyjBp2MCgow4eTphiCAqYcEgBCsQnZf",
                    "K//Pu6S9npRJ05+mCgjVHE7uX5f/eVM//8tVK0FrjjowBJcVQegOz/98wn8qlj8/53+61hh+vy5+PMr2",
                    "M2AkBWAgFDAqAHRRBIEhIBEOADmA+CUYDIAYJAeMIMEAw2AMzdjG9GnVDCJBlAIOKYmNwVhwQCMAzAoD",
                    "F0mBobiwwmAAPGBYEFpjB0DwcGIqAIcD0XCgYgwKTDUKzHcaTA0KTHG3j6EWpsFB0PCqSBQYeAaOAwYM",
                    "BSgTHQKDgaZ2IQYbuShSEBi4Q8NKZ4oEgcWqHAwZKwOAAweNA2mZQxUBkMD4FGaqIEiA25gMJIOENaCL",
                    "7ExECphoCgwABhABJgQC4wBBWACyTEED2WiEcyIohUQjFiTjCkDi/xhmJ4QFY4CI0JSyHHbZ0o1M3oBC",
                    "gEkQJAkFQUDq7zBMBigAhGExhgK6QpisyZgiCIjA0wnHcwoAaVS+Q///rdfH4JcGINyclkphSDZggBoM",
                    "IY0aLUxSCwwJHIqAQy+NwLJ8P13lbkzL3aJAFhyJCgMKFUMV/e99+/nc//19DyDYepGcwIVAZZJS/jhz",
                    "HCvvPvP1rHG1fXybji3qFU4AQ4BkwCABzAVAfBoBZdYOA9IgEREByCgUQcAWYNoABgVh0moFFqY+ofIk",
                    "FwYuBKYKAIYLgOGCSiCYGguOgQBQQFgJMBQKDgLXcAQBCATLAImCILLcAgJGAgYmF4pmH4uGEQGmAVsH",
                    "wIQkAHmFYpg4ESEMjCkBVggEGgkFxKBBh4BD2BASyAqBGly0YwbBB1yAODBoBVQmHIamHgOGMZDnCi5m",
                    "NgMBSqPIGHjCgrhIVGJjwHbLAYqJGDoPcUmPZgUCggCKtqgZWusCDmD/+9RkZg77ZWhDC93jcgAADSAA",
                    "AAEvQcEID3eNwAAANIAAAASgMFAScloo0wBABTOIqYCYcGQcHoDQTpn3tLAWsQSHVNhACQQFm6CIMOEM",
                    "BYyKJRoTmCZiGFcYEZmgbAYa0kRov///lXWqjDLsph2WmICeZBBZg8iHdySYiA46VgEOGSSiYi3dTX83",
                    "yhsvGOAtfksT2X5MVs997ctU9y7zO3uu/V6UxnULg4kDo8RLO6SzhzCzna/nedv56xu4jMo96yYkoCAF",
                    "xQBUsgqMDAFRkwNQDDAEBEaUYHoMxg9gXGFyPIZJFrRiEimGA8C6DlgMDABEQ3A4NRAGRieFBKBAwBoO",
                    "DwmBQwLBKHgwMiIUioBpiAD63SEUDA0GTDkCTLoQzCEFjDfmD+cYC8QGWVHJBoWNJMMwUEqViMKDFgGa",
                    "QwzAODxwL2aaMFgVcsLiEChXCoAmHxGmE4DmER2nx5QmYwsYSU4YCWemPRMoGAhaYyAq2BgQqtVugkhD",
                    "JhYGEw7MIBxr6SgQrkwCU7hw0C4NO+NsziEwqVTBgHMNBYyqKEaGymEBtJKeYIAolA/xhgFr9MBDIxYG",
                    "1LE7mGDo0MfKgDBsw5RTWIJBwJM8nWURNpdLzvPw/D+vRBrwuizoQgYwEHjAxGMCn04K2DAIDFRYYNGK",
                    "3MGtS7e6/MsfjybjqhYAp0ykEg9mtSgs190lbd+3Wzxn/xZxIbdmzAMOkoTKxBSdwytY0urt+9IualGv",
                    "iWedaxf3vHDudW3V1h3CrQBgEARgBgGAYA0AgNF2TABAHDgGB4AowDgI1zGBaAUYLIBZgfAKmimNmZAA",
                    "P5gUgfFUGxoRwuIQkAw6CggAEgAJA8ODECgIYJgMpqIwxYEo8XVfoZB4wWBcwpAEiJ4KAaYNTUUkutYx",
                    "bE4oBQRgaAgqZ2TAuTAA3wsF7WzAoBrxIBqoIuAQGnBkChIVl3GDAyFAfGIxVGBqOGIiyDEmDjfLQxMs",
                    "QKgCBypCgWMvAyC2IDQCGQ2YEHIgADH0W74CHrX/+9RkYIL7CmxDs93jcgAADSAAAAEugbkIr3eNyAAA",
                    "NIAAAATxAPU1RgJGoasAhQg6Y8ATDEXFeqdAgFoQSuZBoLh2gMEgJXgVChiUJreC4LpRGLhImsEMGKMF",
                    "TqOhhtQcfyC/yy73f9uWIMl8k4+abwMJhh4GmDAaAs4RBlMNtWv085hh+u8/GbizRJiIVwsBWp16/42p",
                    "HYq5Zc1VkWMxHa8Yaeo8CgRiBAKUDV8sc5Jrm9czw5+PcOby3nl3//VbpZb5EAABQCAOAoGQCjAFAHEI",
                    "GYVAhQeKoIRgAARGA2CCYDoJxg6gkmqo+KZIoOIcAgZIi0EAQYKhGUDWMAoEAwCgCMEAPR3LTmBoDhAA",
                    "ggGw4QHpEh7LpiwHmHgImIYDgo6DAUNDFPEjpUfk5zDQuy8pKDphoAypDBMAh4LSoCYUAB4jAYKb4jC0",
                    "SCR7TAwG9wOYTgEXQMPxGMMBEMHSQOijdCCQGBQMXTLDKoBbVCeDkAKDoxuRS3hdJkQyNzDoqMKAkMI5",
                    "QFkrzCIkUCCxHMkBYkJZmXsmMgik4EANdJkoQumn8YPABEMW7SIMFixn1IR+rSkOAAANBswEDVdlgQGV",
                    "wa2ILBs4GDS2DFVY2oM/nda3hvurkbtlnnEZ2s9splEQofCMrGFUahUKBMDBRmmFn88+f3CdiF5bLZ35",
                    "phQKIx3aW12tR7mNbz5uM38nnvwVcTKGQHNJSF4bH/QY6xore5ZnSbxrWaWzhjj9Be/lNc5yrsAClQgA",
                    "QAMNVOCQAQwBwEnmBoEoOBXHAETAcAtCAHhCCWAQWQAGQYATGxhzhEGBEDKAiJMBQGGQlBwNEQLBgwRE",
                    "eApWccAUmAt3xEAxEDJfUMAIlA0VB1HMiDYEgKLACYCQoa7gqYNAkYXCczItaFQFUSMIgPJgRZyl7FgS",
                    "AULEQKkwERIVBCuOACvxI0wFEEwJAcGjOadmOdKODK0GY4yDmiDIhAQuQmHAoqKExSGBQMCwcAChqDBI",
                    "uqYQIl+3JFQpeooJhj6oye7/+9RkY4D7VnBDS93bcAAADSAAAAEulcEGzvdtwAAANIAAAAQ7Bku2YxsR",
                    "S7QGlAlGBkHJhBGt0ACGLd0IAZZ6wICBGTCMQXlEVDJSY4MnZhhcwrFjJjOSjACudicN37VJF+1GHrYM",
                    "uGDBgQw4uL6CMPEokxENDhM/saBRmRAAJA10Sqfr59zz/lFTS5+X/b+JgkCVxUuflSzNDvDutZ0FzlNT",
                    "wBBzrgYalCTzJLksn5Vn/LN76vLWf3LH853v/zvdVLn83qtlWAGAQKIPr4JglKwIGQBMFwiC4EgwFgsE",
                    "xgATpgoMAFG88h+E3uGEyeCEyaAMxBEhMNLowCBUxcC0AAkYTBOYLAuYVBCAgnT7SnMJwPIQFAQYEgFD",
                    "IGmDgQjRFmE4REIrGR9vG9ZWGKYJmGIdCQWOCYHAIDQPamWzWO3COFYDKCiAGxICYKEALq0JkmDQAp5j",
                    "w4kwrmJAAmX6fHnkJpokDloWDjQxBPIYEQUoqDGBohEDCMPLKkgGZIOhCSYUSprKbCEtRZHCEIdDIFg/",
                    "/qL6KlFTJTELjw8PXCZmV4IAdMxWxPmAwwPd5gCmDpmBAziqTMSK09SqlH/lQFNDbzAiAAgSUfqPBOyy",
                    "nkVeVr6TBRMDnYmMAM3jSbdMtMBUkMDezuqRH4wouAoXx678gkm4jILVagdmLyyNIDH6EIimq7F2Yqx6",
                    "7WlO89/X5coZBD7I4Q2V/ao6CMNu1a1JU5Y7rmWfbXJRuUcywryrn559vWbve42Z66oDAMYFAoBAJQfH",
                    "QQFQRMCwnCoQmAIAGNwSGEQLGGIPHrW0mlICmGgPmgTmYHFgWDZjIWA4WEIIMRA5wjBAUMTAZqZhIHBA",
                    "OL1mDwmIQqIgyw8IMyHxhYqhxhMf/o4uMzIIYMSFdCQiqTBtdgcNgMBkVQgJwAAQTP0rL5Skm28NrFYU",
                    "YFDxiULABFHQFGCl1JJkjWxIllaOxEKluQ4jVYlurFAA4FtxQkP5PhQCUmKApmgQZaNG0YZexRUOHXcC",
                    "4Av4hEX/+9RkYY76b29CA7zbcgAADSAAAAEtZcD8Lu9NwAAANIAAAAScQCYaEZITGCyRH2C1lGCg8hEI",
                    "o1pVYUJi7RiSEEcyepMKN0eeK54WM92bV+PT7opaF6wYFqhZwDBcwYHKCU0ozZAOjRElSaOxu5M6zq6z",
                    "52Ot2cdCGH2Es6l92W54Z2/qbz1rDHK9MR2L2Y1WZkmy/Xbn1aW9/61Ytbzq50ljG3rudn981hf5vV9I",
                    "ICAmNAYW2RtMFADRFAgTmKQQlsTFEbDHUkjH1VDml6DU8VDGQExg7MwNzL3Q0IQMdGjFwQdGDFggx4LB",
                    "oKZQIgAJMnBi2RiJEY2LBcSMjMEIjIVg0MsNCTwrXHP2hwIqYyaPiqA0oTGRsZDzGAERiy0EuwsEMHLq",
                    "FBGtkQAipy5qvJaYWOGUmhvLkYoZHVcGTDArciECiUnEQwxp4RDwQTT5CpMmeodQsHLdjyy7OpjToiCG",
                    "jOGnmGxPDRUKiwEtQIqblApxASEajBKa6KjoxYqimTQtyy7UbRih5NI3IQ3Pg86IwY8kBCwFbzm14zef",
                    "qpFJmldhvmFv6BQDRJaVBBhxxZ8xTY1+oOZAlECgy14cbjOOtAbJ5C2CGazDnlQ6shdRnyJK1XWWFZvA",
                    "kBcybNXfiehx6o+8Mvwrs6lzxzdE14DGvhmdkktcJl8PZSiHHr+IuPCnizdOKQzT1IRKIcgyXxH43Wr7",
                    "tSCYTEFNRTMuOTkgKAgAALBg5EJD0TWETsXKylWMLiJkROaEdmOjJrMIECghHABXCRplRpwVhSTGwxnx",
                    "ppDILNBAE6lcIiGfNmoHgUW2UDEzBjUlwKZFDAkiM5tNsCMkkOhdHiCVx8WQEIA0usI2E1JZJcygZPsV",
                    "KDUppxlAidwUKmwByA1R8yQQyL4ieLzB2QKsUUIT34FYkUjJWCg8BkoYlWKGnVO3A4AYLaURER8RnDyx",
                    "CidahshpxRAQgGAbkDxVYAAIaoRMyZtQc+CBjdKYovorAJkkvXcGC2kAFoHJGYodMod6BDD/+9Rkbgb7",
                    "eXA9M3rLcAAADSAAAAEtucDwLOstwAAANIAAAARYNFRWJCakSketxWO496AFoCwazCE0uNGh0IHDEiYC",
                    "GIFR44s0FBm+eNiTshYAcHAppII4qt8OL2zLflhaTmQADWi8Q8alsuhF2DmesMZpK39cx0GPIaw7LFzN",
                    "Pa87aqals0pmGKN1VbKnZgiCmxwfXgZQ2ag5p000qMOysKull8CvjWiVWwy6PxOSNBeVc8DLUbPwLJij",
                    "QCgLkFAyhp8LPoFZzK6BrRqMmqoDigi41ZQ6cUx6AyCgBfTDFDWhiofIJC+jVAzahjIgiwrNAaN+MNET",
                    "HYhQjMUFNCIEIcFaTIpUmTTpgcYLMnCXiBOVRqFIFJFUWZAgRMgcEBJgEiE2mQt1ZKuwQgDPoILQGFvF",
                    "vGXUwewDmmpCMQyUzZOMw9S0uaGCIagQ0aGM4djBCmDQBEISGAZU6QjIAIZkGweEX7UAHnAa2GWgwxYA",
                    "xBBhwBLILuwXhTCMwcS2CgiT5EYygyAzPNOIsZHBo4tMYoMvLzFyEJKSKdLDV+xZnD6l9S1ggGFk1cA0",
                    "oGHmtCWfEmwQAXvQRPG/6DLFkcXpLtOIqq1BxJc7jRnDSRTOXeg4sVoMRSTboqm0B0IdhaxFtwW6kDJF",
                    "O6xlqcy+IAAam0pS2ma+q9pAwHBkof0kFUzep91GYLelMWJJzLvTVnGBM1VEkM0huzHX/Ysr+G5uE0Rf",
                    "1r8IEZxYSECUkmas/cgmEmAHIqGBTgWGYpkascbJSY4QmNQhijEYICmyC4XCDAV5aIJBzPQgWDBQFTdF",
                    "hUaGVuIyorKGBYkKpWZyEPyZQMAYzEgVOlNUxcSHQND8kAy1KJhkYS1EFBIJAkjZU8Smz9EwOjO65aAw",
                    "QUCGEFgDxyA4qBgEAWNTIlIgANVIdEJXRwYMXVhCx6SA0ITEjx6mIqEUFBTMgEaYRGpiyZiDQ062DBwo",
                    "8WiG9wOPBhaYwwSgcmQNAs5SCHBhHaaQxhkmOYDQOKXp8tEbGsotUjv/+9RkbY37aXA7C1vLcAAADSAA",
                    "AAEr2cDsDWstwAAANIAAAAQgSYnD6WyNSSSaSOxdpnzAyEFdS5AxlGRUK8QYCIglEwwMuiX3RuaNF0w1",
                    "/L+XAvJCerYXmQ+RQLx8LwJel4S2qJCwqNJZlQ9DghcpUOhJ9pKoqslR6kEEv0ugZBcNo0XWUVgM7Vte",
                    "hFeGkvgc0XOgR/GPpuO/ApfxiDfsyV23zFUAbTjBATeYiy0tyrbXWEYW/ogAuijYpWLAFtAg8LXDhkQu",
                    "MMShM8JBK404YKjE5zU+zggTKjBY1FgNbB0lUphpIyLHgDbuG2RYF9Etx4osQDblbDVk0KhLIKCFbRQK",
                    "QhC2iOjHC1D/hDEvMDhqhxZhpKQqFSTCsRdIoJAVANUTFABYcu6hkWYXuXogFq6vy66YalpYAgF3lotM",
                    "BxgiKBQqygCEbfLDiqCa8SbiP0FDhDJUwIZHQEjgcU7jWVaRIdhap0c0xV7l4xEKb4wQMPPGIGrADSAC",
                    "gXbQjVMrYl6qsXnXWwVp6wagREKvdGYAjr/ToSmWFT0LMFBIsChewNc1d2k3goYBQAAGy0LgRpI9LpL9",
                    "FZPMWSeh5SoC8aonysLpS7RxEZasTvrEQEpDsPe5MFMcqDuONPNKlax0e1kSpxY0qdIFoLRFSuEhPYav",
                    "u0oBKQQRGREEqAt4lemPk1B8mnMPAgbUXDUpXQpJnbXWaJiCmopmXHJyQFDC2ODQwoRABWFL4OBMKXUp",
                    "sFShv6gC1NiV+u1cKTpbVWERlGOGYIZtJlsTWZModCQZZSEtJlMWC1cmpGZCJkMHvIJTFnUHgQmZwpMK",
                    "k0nY0JQMiYZqZUIRSYLByxBDwJGTXS2eBdylKqqeDJmirCGK8awqeoYSmkaKAoeHGo5GQSgmMSMBKhhK",
                    "TxtrLDGWYg8zgCRhmqmyDqZZoDssCyaZ7orVTcByTWmAtUBJRmFw6oKpFNYQiL30YIgFCQxaymK12ODI",
                    "xulJDQYsEquoKzwQClkVWshSqXs8xf1rj7KDAEL/+9Rkbg368HA5E1nLcAAADSAAAAEkwcDMR+MNwAAA",
                    "NIAAAAR2S2qtr2LBL+Vuhcw+6Jy6iUEMVSNcgKCl+ZqhaQnkiiDBxYV/l4rtSKSNLgoUGSQAkpGgKT6x",
                    "Yk1lxaBOZx3sSGBiZuHq4ctrMHIJVFkByplyqlclR5K56WsswIQEckxmplsVbEgn5dxTBAWDgUfYS65Z",
                    "1NV6GUJ1JhL6QeL1O4h1YAFkGUENMghUMvp4A5gxhawjI5jyN1mqJySrO21jLAmtr9YdK4y7yqq7AwwU",
                    "GlQkEiqwphi40fQqAlOHIAXjE1NpnDQozS1qGUQphrPWmK6Wi7jLoJaarc0Z24YftpqtzA0kQaJQxA4v",
                    "6yBjzTX6VKXmSkTzTBfRYy+WoLueNrzIWoKBN3aCzqS8cJbK9EASZK3EVmlqWpytIeeQQ2+SpmEtMZy9",
                    "DBlKWuJ1LxagqaCG2jONlpTc1Ilwk/lXp0tyhcO4U33neZC3Bv2WvtT0VmNPrAEDvzKr9mzGnZeiB3Fh",
                    "q3KbT6yiBpTZoH6XK2NzYaizgv406AYS4MAPM7NFDUja6zKBGdRN+aBymxq9LrJtK1qavVCozjOtabE5",
                    "6wrRGLJCsIU5TEFNRTMuOTkgKGFscGhhKao="
                ];
                data.audio = {};
                data.audio.binary = window.atob(audioString.join(""));
                data.audio.play = function dom_load_audio() {
                    const source = test
                        .audio
                        .createBufferSource(), focused = document.activeElement, buff = new ArrayBuffer(data.audio.binary.length), bytes = new Uint8Array(buff), bytelen = buff.byteLength;
                    let z = 0;
                    do {
                        bytes[z] = data
                            .audio
                            .binary
                            .charCodeAt(z);
                        z = z + 1;
                    } while (z < bytelen);
                    test
                        .audio
                        .decodeAudioData(buff, function dom_load_audio_decode(buffer) {
                        source.buffer = buffer;
                        source.loop = false;
                        source.connect(test.audio.destination);
                        source.start(0, 0, 1.8);
                        // eslint-disable-next-line
                        console.log("You found a secret!");
                        focused.focus();
                    });
                };
            }
            // sets some default event configurations
            if (textarea.codeIn !== null) {
                textarea.codeIn.onfocus = textareafocus;
                textarea.codeIn.onblur = textareablur;
                if (test.ace === true) {
                    textarea.codeIn.onkeydown = function dom_load_bindInDownAce(event) {
                        areaTabOut(event);
                        method
                            .event
                            .keydown(event);
                    };
                }
                else {
                    textarea.codeIn.onkeydown = function dom_load_bindInDown(event) {
                        method
                            .event
                            .fixtabs(event, textarea.codeIn);
                        areaTabOut(event);
                        method
                            .event
                            .keydown(event);
                    };
                }
            }
            if (textarea.codeOut !== null) {
                textarea.codeOut.onfocus = textareafocus;
                textarea.codeOut.onblur = textareablur;
                if (test.ace === true) {
                    textarea.codeOut.onkeydown = areaTabOut;
                }
            }
            window.onresize = fixHeight;
            window.onkeyup = areaShiftUp;
            document.onkeypress = backspace;
            document.onkeydown = backspace;
            // sets vertical responsive design layout
            // must occur after all other visual and interactive changes
            fixHeight();
            method.app.hideOutput();
            // connecting to web sockets if running as localhost
            if (location.href.indexOf("//localhost:") > 0) {
                let ws = new WebSocket(`ws://localhost:${(function dom_load_webSocketsPort() {
                    const uri = location.href;
                    let str = uri.slice(location.href.indexOf("host:") + 5), ind = str.indexOf("/");
                    if (ind > 0) {
                        str = str.slice(0, ind);
                    }
                    ind = str.indexOf("?");
                    if (ind > 0) {
                        str = str.slice(0, ind);
                    }
                    ind = str.indexOf("#");
                    if (ind > 0) {
                        str = str.slice(0, ind);
                    }
                    ind = Number(str);
                    if (isNaN(ind) === true) {
                        return 8080;
                    }
                    return ind;
                }()) + 1}`);
                ws.addEventListener("message", function dom_load_webSockets(event) {
                    if (event.data === "reload") {
                        location.reload();
                    }
                });
                document.getElementsByTagName("body")[0].style.display = "none";
                window.onload = function dom_load_webSocketLoaded() {
                    security();
                    document.getElementsByTagName("body")[0].style.display = "block";
                    id("button-primary").getElementsByTagName("button")[0].click();
                };
            }
            // sets up the option comment string
            x = id("commentString");
            if (x !== null) {
                if (localStorage.getItem("commentString") !== undefined && localStorage.getItem("commentString") !== null && localStorage.getItem("commentString") !== "") {
                    data.commentString = JSON.parse(localStorage.getItem("commentString"));
                }
                if (x.value.length === 0) {
                    x.innerHTML = "/*prettydiff.com \u002a/";
                }
                else {
                    x.innerHTML = `/*prettydiff.com ${data
                        .commentString
                        .join(", ")
                        .replace(/api\./g, "")} \u002a/`;
                }
                x = id("commentClear");
                if (x !== null) {
                    x.onclick = clearComment;
                }
            }
            // set the ace wrap slider load conditions
            if (test.ace === true) {
                const slide = id("slider"), input = id("input"), gutter = input.getElementsByClassName("ace_gutter")[0], wrap = (options.wrap > 1)
                    ? options.wrap
                    : 80;
                setTimeout(function dom_load_aceGutter() {
                    slide.style.marginLeft = gutter.style.width;
                }, 500);
                slide.getElementsByTagName("span")[0].style.left = `${wrap * 1.0035}em`;
                if (options.mode !== "beautify") {
                    slide.style.display = "none";
                }
            }
        }
        if (pages === "documentation") {
            let a = 0, b = 0, colorParam = (typeof location === "object" && typeof location.href === "string" && location.href.indexOf("?") > -1)
                ? location
                    .href
                    .toLowerCase()
                    .split("?")[1]
                : "";
            const docbuttons = document.getElementsByTagName("button"), docbuttonClick = function dom_load_documentation_showhide(event) {
                const x = event.target || event.srcElement, span = x.getElementsByTagName("span")[0], parent = x
                    .parentNode
                    .parentNode, target = parent.getElementsByTagName("div")[0];
                if (target === undefined) {
                    return;
                }
                if (span.innerHTML === "Show") {
                    target.setAttribute("class", "content-show");
                    span.innerHTML = "Hide";
                }
                else {
                    target.setAttribute("class", "content-hide");
                    span.innerHTML = "Show";
                }
            }, colorScheme = id("option-color"), hashgo = function dom_load_documentation_hashgo() {
                let hash = "", test = false, hashnode, parent;
                const body = document.getElementsByTagName("body")[0];
                if (location.href.indexOf("#") > 0) {
                    hash = location
                        .href
                        .split("#")[1];
                    hashnode = document.getElementById(hash);
                    if (hashnode !== null) {
                        parent = hashnode.parentNode;
                        test = (parent.nodeName.toLowerCase() === "h2" || parent.getAttribute("class") === "content-hide");
                        if (test === true) {
                            parent = parent.parentNode;
                            parent.getElementsByTagName("button")[0].click();
                        }
                        else {
                            do {
                                parent = parent.parentNode;
                                test = (parent.nodeName.toLowerCase() === "h2" || parent.getAttribute("class") === "content-hide");
                            } while (test === false && parent.nodeName.toLowerCase() !== "body");
                            if (test === true) {
                                parent = parent.parentNode;
                                parent.getElementsByTagName("button")[0].click();
                            }
                        }
                        document.documentElement.scrollTop = hashnode.offsetTop;
                        body.scrollTop = hashnode.offsetTop;
                    }
                }
            }, colorChange = function dom_load_documentation_colorChange() {
                const options = colorScheme.getElementsByTagName("option"), olen = options.length;
                if (test.store === true && localStorage !== null && localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null && localStorage.getItem("settings").indexOf(":undefined") > 0) {
                    localStorage.setItem("settings", localStorage.getItem("settings").replace(/:undefined/g, ":false"));
                }
                data.settings = (localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null)
                    ? JSON.parse(localStorage.getItem("settings"))
                    : {};
                if (colorParam.indexOf("c=") === 0 || colorParam.indexOf("&c=") > -1) {
                    if (colorParam.indexOf("&c=") > -1) {
                        colorParam.substr(colorParam.indexOf("&c=") + 1);
                    }
                    colorParam = colorParam.split("&")[0];
                    colorParam = colorParam.substr(colorParam.indexOf("=") + 1);
                    b = 0;
                    do {
                        if (options[b].value.toLowerCase() === colorParam) {
                            colorScheme.selectedIndex = b;
                            break;
                        }
                        b = b + 1;
                    } while (b < olen);
                }
                if (((olen > 0 && b !== olen) || olen === 0) && data.settings["option-color"] !== undefined) {
                    colorScheme.selectedIndex = data.settings["option-color"];
                }
                method
                    .event
                    .colorScheme(null);
                colorScheme.onchange = method.event.colorScheme;
            };
            b = docbuttons.length;
            a = 0;
            do {
                if (docbuttons[a].parentNode.nodeName.toLowerCase() === "h2") {
                    docbuttons[a].onclick = docbuttonClick;
                }
                a = a + 1;
            } while (a < b);
            if (colorScheme !== null) {
                colorChange();
            }
            window.onhashchange = hashgo;
            hashgo();
            window.onload = security;
        }
        if (pages === "page") {
            let b = 0, colorOptions, olen = 0, colorParam = (typeof location === "object" && typeof location.href === "string" && location.href.indexOf("?") > -1)
                ? location
                    .href
                    .toLowerCase()
                    .split("?")[1]
                : "";
            const node = id("option-color");
            colorOptions = node.getElementsByTagName("option");
            olen = colorOptions.length;
            if (node !== null) {
                if (test.store === true && localStorage !== null && localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null && localStorage.getItem("settings").indexOf(":undefined") > 0) {
                    localStorage.setItem("settings", localStorage.getItem("settings").replace(/:undefined/g, ":false"));
                }
                data.settings = (localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null)
                    ? JSON.parse(localStorage.getItem("settings"))
                    : {};
                if (colorParam.indexOf("c=") === 0 || colorParam.indexOf("&c=") > -1) {
                    if (colorParam.indexOf("&c=") > -1) {
                        colorParam.substr(colorParam.indexOf("&c=") + 1);
                    }
                    colorParam = colorParam.split("&")[0];
                    colorParam = colorParam.substr(colorParam.indexOf("=") + 1);
                    b = 0;
                    do {
                        if (colorOptions[b].value.toLowerCase() === colorParam) {
                            node.selectedIndex = b;
                            break;
                        }
                        b = b + 1;
                    } while (b < olen);
                }
                if (((olen > 0 && b !== olen) || olen === 0) && data.settings["option-color"] !== undefined) {
                    node.selectedIndex = data.settings["option-color"];
                }
                method
                    .event
                    .colorScheme(null);
                node.onchange = method.event.colorScheme;
            }
            {
                let inca = 0, incb = 0, ol, li, lilen = 0;
                const div = document.getElementsByTagName("div"), len = div.length;
                inca = 0;
                do {
                    if (div[inca].getAttribute("class") === "beautify") {
                        ol = div[inca].getElementsByTagName("ol");
                        if (ol[0].getAttribute("class") === "count") {
                            li = ol[0].getElementsByTagName("li");
                            lilen = li.length;
                            incb = 0;
                            do {
                                if (li[incb].getAttribute("class") === "fold") {
                                    li[incb].onclick = method.event.beaufold;
                                }
                                incb = incb + 1;
                            } while (incb < lilen);
                        }
                    }
                    inca = inca + 1;
                } while (inca < len);
            }
            window.onload = security;
        }
        test.load = false;
    };
    let meta, options, prettydiff;
    // builds the Pretty Diff options comment as options are updated
    method.app.commentString = function dom_app_commentString() {
        const comment = id("commentString");
        if (comment !== null) {
            if (data.commentString.length === 0) {
                comment.innerHTML = "/*prettydiff.com \u002a/";
            }
            else if (data.commentString.length === 1) {
                comment.innerHTML = `/*prettydiff.com ${data
                    .commentString[0]
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/api\./g, "")} \u002a/`;
            }
            else {
                data.commentString.sort();
                comment.innerHTML = `/*prettydiff.com ${data
                    .commentString
                    .join(", ")
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/api\./g, "")} \u002a/`;
            }
        }
        method.app.hideOutput();
        if (test.store === true) {
            localStorage.setItem("commentString", JSON.stringify(data.commentString));
        }
    };
    // stretches input to 100% width if output is a html report
    method.app.hideOutput = function dom_app_hideOutput() {
        let hide;
        if (options.complete_document === true) {
            hide = false;
        }
        else if (options.parse_format === "renderhtml" && options.mode === "parse") {
            hide = true;
        }
        else if (options.jsscope === "report" && options.mode === "beautify") {
            hide = true;
        }
        else {
            hide = false;
        }
        if (hide === true) {
            if (test.ace === true) {
                id("output").parentNode.style.display = "none";
                id("input").parentNode.style.width = "100%";
            }
            else {
                id("output").parentNode.parentNode.style.display = "none";
                id("input").parentNode.parentNode.style.width = "100%";
            }
        }
        else {
            if (test.ace === true) {
                id("output").parentNode.style.display = "block";
                id("input").parentNode.style.width = "49%";
            }
            else {
                id("output").parentNode.parentNode.style.display = "block";
                id("input").parentNode.parentNode.style.width = "49%";
            }
        }
    };
    // determine the specific language if auto or unknown
    method.app.langkey = function dom_app_langkey(obj) {
        let defaultval = "", defaultt = "", value;
        const language = prettydiff.api.language, langdefault = id("option-language_default");
        if (typeof language !== "object") {
            return ["", "", ""];
        }
        defaultval = (langdefault === null)
            ? "javascript"
            : (langdefault.value === "text" && options.mode !== "diff")
                ? "javascript"
                : langdefault.value;
        defaultt = language.setlexer(defaultval);
        if (defaultval === "auto") {
            obj.name = "auto";
        }
        if (obj.name === "auto" && obj.sample !== "") {
            data.langvalue = language.auto(obj.sample, defaultt);
        }
        else if (obj.name === "csv") {
            data.langvalue = ["plain_text", "csv", "CSV"];
        }
        else if (obj.name === "text") {
            data.langvalue = ["plain_text", "text", "Plain Text"];
        }
        else if (obj.name !== "") {
            data.langvalue = [obj.name, language.setlexer(obj.name), language.nameproper(obj.name)];
        }
        else if (obj.sample !== "" || test.ace === false) {
            data.langvalue = language.auto(obj.sample, defaultt);
        }
        else {
            data.langvalue = [defaultt, language.setlexer(defaultt), language.nameproper(defaultt)];
        }
        value = data.langvalue;
        if (test.ace === true) {
            if (value[0] === "script" || value[0] === "tss") {
                value = ["javascript", value[1], value[2]];
            }
            else if (value[0] === "dustjs") {
                value = ["html", value[1], value[2]];
            }
            else if (value[0] === "markup") {
                value = ["xml", value[1], value[2]];
            }
            else if (value[1] === "style") {
                value = ["css", value[1], value[2]];
            }
            if (textarea.codeIn !== null) {
                if (value[0] === "vapor") {
                    aceStore
                        .codeIn
                        .getSession()
                        .setMode("ace/mode/html");
                }
                else {
                    aceStore
                        .codeIn
                        .getSession()
                        .setMode(`ace/mode/${value[0]}`);
                }
            }
            if (textarea.codeOut !== null) {
                if (value[0] === "vapor") {
                    aceStore
                        .codeOut
                        .getSession()
                        .setMode("ace/mode/html");
                }
                else {
                    aceStore
                        .codeOut
                        .getSession()
                        .setMode(`ace/mode/${value[0]}`);
                }
            }
        }
        if (obj.name === "text") {
            return ["text", "text", "Plain Text"];
        }
        if (obj.name !== "") {
            return value;
        }
        if (value.length < 1 && obj.name === "") {
            if (textarea.codeIn !== null) {
                value = language.auto(textarea.codeIn.value, defaultt);
            }
            if (value.length < 1) {
                return ["javascript", "script", "JavaScript"];
            }
            data.langvalue = value;
        }
        return value;
    };
    //store tool changes into localStorage to maintain state
    method.app.options = function dom_app_options(event) {
        let x = event.srcElement || event.target, input, select, item, node = "", value = "", xname = "", type = "", idval = "", classy = "", h3, body, opt;
        xname = x.nodeName.toLowerCase();
        if (xname === "div") {
            if (x.getAttribute("class") === "box") {
                item = x;
            }
            else {
                if (x.getElementsByTagName("input")[0] === undefined) {
                    return;
                }
                item = x.getElementsByTagName("input")[0];
            }
        }
        else if (xname === "input" || xname === "textarea") {
            input = x;
            item = input;
        }
        else if (xname === "select") {
            select = x;
            item = select;
        }
        else if (xname === "button") {
            item = x.parentNode;
            item = (item.nodeName.toLowerCase() === "a")
                ? item.parentNode.parentNode
                : item.parentNode;
        }
        else {
            input = x.getElementsByTagName("input")[0];
            item = input;
        }
        if (test.load === false && item !== id("option-language")) {
            item.focus();
        }
        node = item
            .nodeName
            .toLowerCase();
        xname = item.getAttribute("name");
        type = item.getAttribute("type");
        idval = item.getAttribute("id");
        classy = item.getAttribute("class");
        if (test.load === true) {
            return;
        }
        if (node === "input") {
            if (type === "radio") {
                data.settings[xname] = idval;
            }
            else if (type === "text") {
                data.settings[idval] = input.value;
            }
        }
        else if (node === "select") {
            data.settings[idval] = select.selectedIndex;
        }
        else if (node === "div" && classy === "box") {
            h3 = item.getElementsByTagName("h3")[0];
            body = item.getElementsByTagName("div")[0];
            idval = idval.replace("report", "");
            if (data.settings.report[idval] === undefined) {
                data.settings.report[idval] = {};
            }
            if (body.style.display === "none" && h3.clientWidth < 175) {
                data.settings.report[idval].min = true;
                data.settings.report[idval].max = false;
            }
            else if (data.settings.report[idval].max === false || data.settings.report[idval].max === undefined) {
                data.settings.report[idval].min = false;
                data.settings.report[idval].left = item.offsetLeft;
                data.settings.report[idval].top = item.offsetTop;
                if (test.agent.indexOf("macintosh") > 0) {
                    data.settings.report[idval].width = (body.clientWidth - 20);
                    data.settings.report[idval].height = (body.clientHeight - 53);
                }
                else {
                    data.settings.report[idval].width = (body.clientWidth - 4);
                    data.settings.report[idval].height = (body.clientHeight - 36);
                }
            }
        }
        else if (node === "button" && idval !== null) {
            data.settings[idval] = item
                .innerHTML
                .replace(/\s+/g, " ");
        }
        if (test.store === true) {
            localStorage.setItem("settings", JSON.stringify(data.settings));
        }
        if (classy === "box" || page.getAttribute("id") !== "webtool") {
            return;
        }
        if (item.nodeName.toLowerCase() === "select") {
            opt = select[select.selectedIndex];
            value = opt.value;
        }
        else {
            value = input.value;
        }
        if (idval.indexOf("option-") === 0) {
            classy = idval.replace("option-", "");
            if (classy.indexOf("true-") === 0) {
                classy = classy.replace("true-", "");
                options[classy] = true;
            }
            else if (classy.indexOf("false-") === 0) {
                classy = classy.replace("false-", "");
                options[classy] = false;
            }
            else if (item.getAttribute("data-type") === "number") {
                if (isNaN(Number(value)) === false) {
                    options[classy] = Number(value);
                }
            }
            else {
                options[classy] = value;
            }
        }
        else if (idval === "inputlabel") {
            classy = "sourcelabel";
            options.source_label = value;
        }
        else if (idval === "outputlabel") {
            classy = "difflabel";
            options.diff_label = value;
        }
        if (classy !== null && options[classy] !== undefined && classy !== "source" && classy !== "diff") {
            let a = 0;
            const cslen = data.commentString.length;
            if (cslen > 0) {
                do {
                    if (data.commentString[a].slice(0, data.commentString[a].indexOf(":")) === classy) {
                        data.commentString.splice(a, 1);
                        break;
                    }
                    a = a + 1;
                } while (a < cslen);
            }
            if (typeof options[classy] === "number" || typeof options[classy] === "boolean") {
                data.commentString.push(`${classy}: ${options[classy]}`);
            }
            else {
                data.commentString.push(`${classy}: "${options[classy]}"`);
            }
            method.app.commentString();
        }
        if (test.ace === true && x.getAttribute("id") === "option-wrap" && isNaN(Number(input.value)) === false) {
            let numb = Number(input.value);
            if (numb < 1) {
                numb = 80;
            }
            aceStore.codeIn.setPrintMarginColumn(numb);
            aceStore.codeOut.setPrintMarginColumn(numb);
        }
    };
    //ace wrap slider
    method.event.aceSlider = function dom_app_aceSlider(event) {
        let subOffset = 0, cursorStatus = "ew", node = event.srcElement || event.target, slide = node.parentNode, parent = slide.parentNode, value = 0;
        const touch = (event !== null && event.type === "touchstart"), width = parent.clientWidth, scale = 8.35, max = Math.round(((parent.offsetLeft + width) / scale) - scale), wrap = id("option-wrap");
        if (node.nodeName === "button") {
            node = slide;
            slide = parent;
            parent = parent.parentNode;
        }
        if (touch === true) {
            document.ontouchmove = function dom_event_colSliderGrab_Touchboxmove(f) {
                f.preventDefault();
                subOffset = Math.round((f.touches[0].clientX / scale) - scale);
                if (subOffset > max) {
                    node.style.left = `${max}em`;
                    cursorStatus = "e";
                    value = max;
                }
                else if (subOffset < 0) {
                    node.style.left = "0";
                    cursorStatus = "w";
                    value = 0;
                }
                else if (subOffset < max && subOffset > 0) {
                    node.style.left = `${subOffset * 1.0035}em`;
                    cursorStatus = "ew";
                    value = subOffset;
                }
                aceStore.codeIn.setPrintMarginColumn(value);
                aceStore.codeOut.setPrintMarginColumn(value);
                document.ontouchend = function dom_event_colSliderGrab_Touchboxmove_drop(f) {
                    f.preventDefault();
                    node.style.cursor = `${cursorStatus}-resize`;
                    node.getElementsByTagName("button")[0].style.cursor = `${cursorStatus}-resize`;
                    document.onmousemove = null;
                    document.onmouseup = null;
                    wrap.value = value;
                    data.settings["option-wrap"] = value;
                    if (test.store === true) {
                        localStorage.setItem("settings", JSON.stringify(data.settings));
                    }
                    method.event.execute();
                };
            };
            document.ontouchstart = null;
        }
        else {
            document.onmousemove = function dom_event_colSliderGrab_Mouseboxmove(f) {
                f.preventDefault();
                subOffset = Math.round((f.clientX / scale) - scale);
                if (subOffset > max) {
                    node.style.left = `${max}em`;
                    cursorStatus = "e";
                    value = max;
                }
                else if (subOffset < 0) {
                    node.style.left = "0";
                    cursorStatus = "w";
                    value = 0;
                }
                else if (subOffset < max && subOffset > 0) {
                    node.style.left = `${subOffset * 1.0035}em`;
                    cursorStatus = "ew";
                    value = subOffset;
                }
                aceStore.codeIn.setPrintMarginColumn(value);
                aceStore.codeOut.setPrintMarginColumn(value);
                document.onmouseup = function dom_event_colSliderGrab_Mouseboxmove_drop(f) {
                    f.preventDefault();
                    node.style.cursor = `${cursorStatus}-resize`;
                    node.getElementsByTagName("button")[0].style.cursor = `${cursorStatus}-resize`;
                    document.onmousemove = null;
                    document.onmouseup = null;
                    wrap.value = value;
                    data.settings["option-wrap"] = value;
                    if (test.store === true) {
                        localStorage.setItem("settings", JSON.stringify(data.settings));
                    }
                    method.event.execute();
                };
            };
            document.onmousedown = null;
        }
        return false;
    };
    //allows visual folding of function in the JSPretty jsscope HTML output
    method.event.beaufold = function dom_event_beaufold(event) {
        let a = 0, b = "";
        const el = event.srcElement || event.target, title = el
            .getAttribute("title")
            .split("line "), parent = [el.parentNode, el.parentNode.nextSibling], min = Number(title[1].substr(0, title[1].indexOf(" "))), max = Number(title[2]), list = [
            parent[0].getElementsByTagName("li"),
            parent[1].getElementsByTagName("li")
        ];
        a = min;
        if (el.innerHTML.charAt(0) === "-") {
            do {
                list[0][a].style.display = "none";
                list[1][a].style.display = "none";
                a = a + 1;
            } while (a < max);
            el.innerHTML = `+${el
                .innerHTML
                .substr(1)}`;
        }
        else {
            do {
                list[0][a].style.display = "block";
                list[1][a].style.display = "block";
                if (list[0][a].getAttribute("class") === "fold" && list[0][a].innerHTML.charAt(0) === "+") {
                    b = list[0][a].getAttribute("title");
                    b = b.substring(b.indexOf("to line ") + 1);
                    a = Number(b) - 1;
                }
                a = a + 1;
            } while (a < max);
            el.innerHTML = `-${el
                .innerHTML
                .substr(1)}`;
        }
    };
    //change the color scheme of the web UI
    method.event.colorScheme = function dom_event_colorScheme(event) {
        const item = id("option-color"), option = item.getElementsByTagName("option"), optionLen = option.length, index = (function dom_event_colorScheme_indexLen() {
            if (item.selectedIndex < 0 || item.selectedIndex > optionLen) {
                item.selectedIndex = optionLen - 1;
                return optionLen - 1;
            }
            return item.selectedIndex;
        }()), color = option[index]
            .innerHTML
            .toLowerCase()
            .replace(/\s+/g, ""), logo = id("pdlogo"), output = id("output");
        let theme = "", logoColor = "";
        document
            .getElementsByTagName("body")[0]
            .setAttribute("class", color);
        if (test.ace === true && page.getAttribute("id") === "webtool") {
            if (color === "white") {
                theme = "ace/theme/textmate";
            }
            if (color === "shadow") {
                theme = "ace/theme/idle_fingers";
            }
            if (color === "canvas") {
                theme = "ace/theme/textmate";
            }
            aceStore
                .codeIn
                .setTheme(theme);
            aceStore
                .codeOut
                .setTheme(theme);
        }
        if (output !== null) {
            if (options.mode === "diff") {
                if (options.color === "white") {
                    output.style.background = "#fff";
                }
                else if (options.color === "shadow") {
                    output.style.background = "transparent";
                }
                else if (options.color === "canvas") {
                    output.style.background = "#f2f2f2";
                }
            }
            else {
                if (options.color === "white") {
                    output.style.background = "#f2f2f2";
                }
                else if (options.color === "shadow") {
                    output.style.background = "#111";
                }
                else if (options.color === "canvas") {
                    output.style.background = "#ccccc8";
                }
            }
        }
        if (logo !== null) {
            if (color === "canvas") {
                logoColor = "664";
            }
            else if (color === "shadow") {
                logoColor = "999";
            }
            else {
                logoColor = "666";
            }
            logo.style.borderColor = `#${logoColor}`;
            logo
                .getElementsByTagName("g")[0]
                .setAttribute("fill", `#${logoColor}`);
        }
        if (test.load === false && event !== null) {
            method
                .app
                .options(event);
        }
    };
    // allows grabbing and resizing columns (from the third column) in the diff
    // side-by-side report
    method.event.colSliderGrab = function dom_event_colSliderGrab(event) {
        let subOffset = 0, withinRange = false, offset = 0, cursorStatus = "ew", diffLeft, node = event.srcElement || event.target;
        const touch = (event !== null && event.type === "touchstart"), diffRight = (function dom_event_colSliderGrab_nodeFix() {
            if (node.nodeName === "li") {
                node = node.parentNode;
            }
            return node.parentNode;
        }()), diff = diffRight.parentNode, lists = diff.getElementsByTagName("ol"), par1 = lists[2].parentNode, par2 = lists[2].parentNode.parentNode, counter = lists[0].clientWidth, data = lists[1].clientWidth, width = par1.clientWidth, total = par2.clientWidth, min = ((total - counter - data - 2) - width), max = (total - width - counter), minAdjust = min + 15, maxAdjust = max - 20;
        diffLeft = diffRight.previousSibling;
        offset = par1.offsetLeft - par2.offsetLeft;
        event.preventDefault();
        if (report.code.box !== null) {
            offset = offset + report.code.box.offsetLeft;
            offset = offset - report.code.body.scrollLeft;
        }
        else {
            subOffset = (par1.scrollLeft > document.body.scrollLeft)
                ? par1.scrollLeft
                : document.body.scrollLeft;
            offset = offset - subOffset;
        }
        offset = offset + node.clientWidth;
        node.style.cursor = "ew-resize";
        diff.style.width = `${total / 10}em`;
        diff.style.display = "inline-block";
        if (diffLeft.nodeType !== 1) {
            do {
                diffLeft = diffLeft.previousSibling;
            } while (diffLeft.nodeType !== 1);
        }
        diffLeft.style.display = "block";
        diffRight.style.width = `${diffRight.clientWidth / 10}em`;
        diffRight.style.position = "absolute";
        if (touch === true) {
            document.ontouchmove = function dom_event_colSliderGrab_Touchboxmove(f) {
                f.preventDefault();
                subOffset = offset - f.touches[0].clientX;
                if (subOffset > minAdjust && subOffset < maxAdjust) {
                    withinRange = true;
                }
                if (withinRange === true && subOffset > maxAdjust) {
                    diffRight.style.width = `${(total - counter - 2) / 10}em`;
                    cursorStatus = "e";
                }
                else if (withinRange === true && subOffset < minAdjust) {
                    diffRight.style.width = `${(total - counter - data - 2) / 10}em`;
                    cursorStatus = "w";
                }
                else if (subOffset < max && subOffset > min) {
                    diffRight.style.width = `${(width + subOffset) / 10}em`;
                    cursorStatus = "ew";
                }
                document.ontouchend = function dom_event_colSliderGrab_Touchboxmove_drop(f) {
                    f.preventDefault();
                    node.style.cursor = `${cursorStatus}-resize`;
                    document.ontouchmove = null;
                    document.ontouchend = null;
                };
            };
            document.ontouchstart = null;
        }
        else {
            document.onmousemove = function dom_event_colSliderGrab_Mouseboxmove(f) {
                f.preventDefault();
                subOffset = offset - f.clientX;
                if (subOffset > minAdjust && subOffset < maxAdjust) {
                    withinRange = true;
                }
                if (withinRange === true && subOffset > maxAdjust) {
                    diffRight.style.width = `${(total - counter - 2) / 10}em`;
                    cursorStatus = "e";
                }
                else if (withinRange === true && subOffset < minAdjust) {
                    diffRight.style.width = `${(total - counter - data - 2) / 10}em`;
                    cursorStatus = "w";
                }
                else if (subOffset < max && subOffset > min) {
                    diffRight.style.width = `${(width + subOffset) / 10}em`;
                    cursorStatus = "ew";
                }
                document.onmouseup = function dom_event_colSliderGrab_Mouseboxmove_drop(f) {
                    f.preventDefault();
                    node.style.cursor = `${cursorStatus}-resize`;
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
            document.onmousedown = null;
        }
        return false;
    };
    //allows visual folding of consecutive equal lines in a diff report
    method.event.difffold = function dom_event_difffold(event) {
        let a = 0, b = 0, max, lists = [];
        const node = event.srcElement || event.target, title = node
            .getAttribute("title")
            .split("line "), min = Number(title[1].substr(0, title[1].indexOf(" "))), inner = node.innerHTML, parent = node.parentNode.parentNode, par1 = parent.parentNode, listnodes = (parent.getAttribute("class") === "diff")
            ? parent.getElementsByTagName("ol")
            : par1.getElementsByTagName("ol"), listLen = listnodes.length;
        do {
            lists.push(listnodes[a].getElementsByTagName("li"));
            a = a + 1;
        } while (a < listLen);
        max = (max >= lists[0].length)
            ? lists[0].length
            : Number(title[2]);
        if (inner.charAt(0) === "-") {
            node.innerHTML = `+${inner.substr(1)}`;
            a = min;
            if (min < max) {
                do {
                    b = 0;
                    do {
                        lists[b][a].style.display = "none";
                        b = b + 1;
                    } while (b < listLen);
                    a = a + 1;
                } while (a < max);
            }
        }
        else {
            node.innerHTML = `-${inner.substr(1)}`;
            a = min;
            if (min < max) {
                do {
                    b = 0;
                    do {
                        lists[b][a].style.display = "block";
                        b = b + 1;
                    } while (b < listLen);
                    a = a + 1;
                } while (a < max);
            }
        }
    };
    // execute bundles arguments in preparation for executing prettydiff references
    method.event.execute = function dom_event_execute(event) {
        let lang, errortext = "", requests = false, requestd = false, completed = false, completes = false, autolang = false, autolexer = false, node = id("option-jsscope");
        const startTime = Date.now(), lex = id("option-lexer"), lexval = (lex === null)
            ? null
            : lex[lex.selectedIndex], langvalue = (id("option-language") === null || id("option-language").value === "" || lexval === null || lexval.value === "" || lexval.value === "auto")
            ? "auto"
            : id("option-language").value, ann = id("announcement"), domain = (/^((https?:\/\/)|(file:\/\/\/))/), lf = id("option-crlf"), opt = node[node.selectedIndex], textout = (options.jsscope !== "report" && (node === null || opt.value !== "report")), app = function dom_event_execute_app() {
            let output = "";
            const sanitize = function dom_event_execute_app_sanitize(input) {
                return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }, renderOutput = function dom_event_execute_app_renderOutput() {
                let diffList, button, buttons, pdlang = "", parent, chromeSave = false;
                const commanumb = function dom_event_execute_app_renderOutput_commanumb(numb) {
                    let str = "", len = 0, arr = [];
                    if (typeof numb !== "number" || isNaN(numb) === true) {
                        return numb;
                    }
                    str = String(numb);
                    if (str.length < 4) {
                        return str;
                    }
                    arr = str.split("");
                    len = str.length - 4;
                    do {
                        arr[len] = `${arr[len]},`;
                        len = len - 3;
                    } while (len > -1);
                    return arr.join("");
                }, langtext = function dom_event_execute_app_renderOutput_langtext() {
                    if (autolang === true) {
                        return `Code type is set to <em>auto</em>. Presumed language is <strong>${data.langvalue[2]}</strong>.`;
                    }
                    if (autolexer === true) {
                        return `Language is set to <strong>${data.langvalue[2]}</strong>. Presumed lexer is <strong>${data.langvalue[1]}</strong>.`;
                    }
                    if (options.language === "text") {
                        return `Language set to <strong>Plain Text</strong>.`;
                    }
                    return `Language set to <strong>${data.langvalue[2]}</strong>.`;
                };
                meta.time = (function dom_event_execute_app_renderOutput_proctime() {
                    const plural = function dom_event_execute_app_renderOutput_proctime_plural(x, y) {
                        let a = x + y;
                        if (x !== 1) {
                            a = `${a}s`;
                        }
                        if (y !== " second") {
                            a = `${a} `;
                        }
                        return a;
                    }, minute = function dom_event_execute_app_renderOutput_proctime_minute() {
                        minutes = elapsed / 60;
                        minuteString = plural(minutes, " minute");
                        minutes = elapsed - (minutes * 60);
                        secondString = (minutes === 1)
                            ? "1 second"
                            : `${minutes.toFixed(3)} seconds`;
                    };
                    let elapsed = (Date.now() - startTime) / 1000, minuteString = "", hourString = "", minutes = 0, hours = 0, secondString = String(elapsed);
                    if (elapsed >= 60 && elapsed < 3600) {
                        minute();
                    }
                    else if (elapsed >= 3600) {
                        hours = elapsed / 3600;
                        hourString = hours.toString();
                        elapsed = elapsed - (hours * 3600);
                        hourString = plural(hours, " hour");
                        minute();
                    }
                    else {
                        secondString = plural(Number(secondString), " second");
                    }
                    return hourString + minuteString + secondString;
                }());
                meta.outsize = output.length;
                data.zIndex = data.zIndex + 1;
                if (autolexer === true) {
                    options.lexer = "auto";
                }
                button = report
                    .code
                    .box
                    .getElementsByTagName("p")[0]
                    .getElementsByTagName("button")[0];
                if (button.getAttribute("class") === "save" && button.innerHTML === "H") {
                    chromeSave = true;
                    button.innerHTML = "S";
                }
                if (output.length > 125000) {
                    test.filled.code = true;
                }
                else {
                    test.filled.code = false;
                }
                if ((options.mode === "parse" && options.parse_format === "table" && options.complete_document === false) || (options.language === "csv" && options.mode !== "diff")) {
                    if (report.code.box !== null) {
                        if (options.language === "csv") {
                            let a = 0, b = output.length, c = 0, d = 0, cells = 0, heading = false, tr, table, td, body, div;
                            do {
                                if (output[a].length > cells) {
                                    cells = output[a].length;
                                }
                                a = a + 1;
                            } while (a < b);
                            if (b > 5) {
                                c = output[0].length;
                                a = 0;
                                do {
                                    if (isNaN(Number(output[0][a])) === false || (output[0][a].length < 4 && output[0][a].length < output[1][a].length && output[0][a].length < output[2][a].length)) {
                                        break;
                                    }
                                    a = a + 1;
                                } while (a < c);
                                if (a === c) {
                                    a = 0;
                                    do {
                                        if (output[1][a] !== undefined && (isNaN(Number(output[1][a].charAt(0))) === false || output[1][a].length < 4)) {
                                            break;
                                        }
                                        a = a + 1;
                                    } while (a < c);
                                    if (a < c) {
                                        do {
                                            if (output[2][d] !== undefined && (isNaN(Number(output[2][d].charAt(0))) === false || output[2][d].length < 4)) {
                                                if (d === a) {
                                                    heading = true;
                                                }
                                                break;
                                            }
                                            d = d + 1;
                                        } while (d < c);
                                    }
                                }
                            }
                            div = document.createElement("div");
                            table = document.createElement("table");
                            div.setAttribute("class", "doc");
                            table.setAttribute("class", "analysis");
                            table.setAttribute("summary", "CSV data");
                            a = 0;
                            if (heading === true) {
                                a = 1;
                                body = document.createElement("thead");
                                tr = document.createElement("tr");
                                td = document.createElement("th");
                                td.innerHTML = "Index";
                                tr.appendChild(td);
                                c = 0;
                                do {
                                    td = document.createElement("th");
                                    if (output[0][c] !== undefined) {
                                        td.innerHTML = output[0][c];
                                    }
                                    tr.appendChild(td);
                                    c = c + 1;
                                } while (c < cells);
                                body.appendChild(tr);
                                table.appendChild(body);
                            }
                            body = document.createElement("tbody");
                            do {
                                tr = document.createElement("tr");
                                td = document.createElement("td");
                                if (a === 0) {
                                    td.innerHTML = "Index";
                                }
                                else {
                                    td.innerHTML = String(a);
                                }
                                tr.appendChild(td);
                                c = 0;
                                do {
                                    td = document.createElement("td");
                                    if (output[a][c] !== undefined) {
                                        td.innerHTML = output[a][c];
                                    }
                                    tr.appendChild(td);
                                    c = c + 1;
                                } while (c < cells);
                                body.appendChild(tr);
                                a = a + 1;
                            } while (a < b);
                            table.appendChild(body);
                            div.appendChild(table);
                            report
                                .code
                                .body
                                .appendChild(div);
                        }
                        else if (options.mode === "parse") {
                            if (report.code.box !== null) {
                                const table = [];
                                table.push("<div class='report'><h4>Parsed Output</h4>");
                                table.push(output);
                                table.push("</div>");
                                output = `<p>${langtext()}</p>${table.join("")}`;
                                report.code.body.innerHTML = output;
                                if (report.code.body.style.display === "none") {
                                    report.code.box.getElementsByTagName("h3")[0].getElementsByTagName("button")[0].focus();
                                }
                                report.code.box.style.top = `${data.settings.report.code.top / 10}em`;
                                report.code.box.style.right = "auto";
                            }
                        }
                    }
                    else if (options.language !== "csv") {
                        if (test.ace === true) {
                            aceStore
                                .codeOut
                                .setValue(output);
                            aceStore
                                .codeOut
                                .clearSelection();
                        }
                        else {
                            textarea.codeOut.value = output;
                        }
                    }
                }
                else if (options.mode === "beautify") {
                    if (options.jsscope === "report" && options.complete_document === false && report.code.box !== null && (data.langvalue[0] === "javascript" || data.langvalue[0] === "jsx") && output.indexOf("Error:") !== 0) {
                        report.code.body.innerHTML = output;
                        if (report.code.body.style.display === "none") {
                            report.code.box.getElementsByTagName("h3")[0].getElementsByTagName("button")[0].focus();
                        }
                        report.code.box.style.top = `${data.settings.report.code.top / 10}em`;
                        report.code.box.style.right = "auto";
                        diffList = report
                            .code
                            .body
                            .getElementsByTagName("ol");
                        if (diffList.length > 0) {
                            const list = diffList[0].getElementsByTagName("li");
                            let a = 0, b = list.length;
                            do {
                                if (list[a].getAttribute("class") === "fold") {
                                    list[a].onclick = method.event.beaufold;
                                }
                                a = a + 1;
                            } while (a < b);
                        }
                        return;
                    }
                    if (test.ace === true) {
                        aceStore
                            .codeOut
                            .setValue(output);
                        aceStore
                            .codeOut
                            .clearSelection();
                    }
                    else {
                        textarea.codeOut.value = output;
                    }
                }
                else if (options.mode === "diff" && report.code.box !== null) {
                    buttons = report
                        .code
                        .box
                        .getElementsByTagName("p")[0]
                        .getElementsByTagName("button");
                    if (options.diff_format === "json" && options.diff_rendered_html === false) {
                        const json = JSON.parse(output).diff, len = json.length, tab = (function dom_event_execute_app_renderOutput_diffTab() {
                            const tabout = [];
                            let aa = options.indent_size;
                            do {
                                tabout.push(options.indent_char);
                                aa = aa - 1;
                            } while (aa > 0);
                            return tabout.join("");
                        }()), json_output = [`{"diff": [`];
                        let a = 0;
                        do {
                            if (json[a][0] === "r") {
                                json_output.push(`${tab}["${json[a][0]}", "${json[a][1].replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}", "${json[a][2].replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"],`);
                            }
                            else {
                                json_output.push(`${tab}["${json[a][0]}", "${json[a][1].replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"],`);
                            }
                            a = a + 1;
                        } while (a < len);
                        json_output[json_output.length - 1] = json_output[json_output.length - 1].replace(/\],$/, "]");
                        json_output.push("]}");
                        output = `<textarea>${json_output.join("\n")}</textarea>`;
                    }
                    if (options.complete_document === true || options.diff_rendered_html === true) {
                        output = `<textarea>${sanitize(output)}</textarea>`;
                    }
                    report.code.body.innerHTML = `<p>${langtext()}</p><p><strong>Execution time:</strong> <em>${meta.time}</em></p>${output}`;
                    if ((autolang === true || autolexer === true) && report.code.body.firstChild !== null) {
                        if (report.code.body.firstChild.nodeType > 1) {
                            report
                                .code
                                .body
                                .removeChild(report.code.body.firstChild);
                        }
                    }
                    let textarea = report.code.body.getElementsByTagName("textarea")[0];
                    if (textarea === undefined) {
                        diffList = report
                            .code
                            .body
                            .getElementsByTagName("ol");
                        if (diffList.length > 0) {
                            const cells = diffList[0].getElementsByTagName("li"), len = cells.length;
                            let a = 0;
                            do {
                                if (cells[a].getAttribute("class") === "fold") {
                                    cells[a].onclick = method.event.difffold;
                                }
                                a = a + 1;
                            } while (a < len);
                        }
                        if (options.diff_view === "sidebyside" && diffList.length > 3) {
                            diffList[2].onmousedown = method.event.colSliderGrab;
                            diffList[2].ontouchstart = method.event.colSliderGrab;
                        }
                    }
                    else {
                        textarea.style.height = `${(report.code.body.clientHeight - 140) / 12}em`;
                    }
                }
                else if (options.mode === "minify" || options.mode === "parse") {
                    if (test.ace === true) {
                        aceStore
                            .codeOut
                            .setValue(output);
                        aceStore
                            .codeOut
                            .clearSelection();
                    }
                    else {
                        textarea.codeOut.value = output;
                    }
                }
                if (ann !== null) {
                    if (errortext.indexOf("end tag") > 0 || errortext.indexOf("Duplicate id") > 0) {
                        ann.setAttribute("class", "error");
                        ann.innerHTML = sanitize(errortext);
                    }
                    else if (id("jserror") !== null) {
                        ann.removeAttribute("class");
                        ann.innerHTML = `<strong>${id("jserror")
                            .getElementsByTagName("strong")[0]
                            .innerHTML}</strong> <span>See 'Code Report' for details</span>`;
                    }
                    else {
                        ann.innerHTML = langtext();
                        if (options.mode === "parse" && options.parse_format !== "htmltable") {
                            pdlang = "tokens";
                        }
                        else {
                            pdlang = "characters";
                        }
                        if (prettydiff.sparser.parseerror !== "" && ann !== null) {
                            ann.innerHTML = `${ann.innerHTML}<span><strong>Parse Error:</strong> ${sanitize(prettydiff.sparser.parseerror)}</span>`;
                        }
                        else if (meta.error === "" || meta.error === undefined) {
                            ann.innerHTML = `${ann.innerHTML}<span><em>Execution time:</em> <strong>${sanitize(meta.time)}</strong>. <em>Output size:</em> <strong>${commanumb(meta.outsize)} ${pdlang}</strong></span>`;
                        }
                        else {
                            ann.innerHTML = `${ann.innerHTML}<span><strong>${sanitize(meta.error)}</strong></span>`;
                        }
                    }
                }
                buttons = report
                    .code
                    .box
                    .getElementsByTagName("p")[0]
                    .getElementsByTagName("button");
                if (chromeSave === true) {
                    buttons[0].click();
                }
                parent = buttons[1].parentNode;
                if (parent.style.display === "none" && (options.mode === "diff" || (options.mode === "beautify" && options.jsscope === "report" && lang[1] === "javascript"))) {
                    buttons[1].click();
                }
            };
            data.langvalue = lang;
            if (options.mode === "diff") {
                if (prettydiff.beautify[options.lexer] === undefined && options.lexer !== "auto" && options.lexer !== "text") {
                    if (ann !== null) {
                        ann.innerHTML = `Library <em>prettydiff.beautify.${options.lexer}</em> is <strong>undefined</strong>.`;
                    }
                    options.language = "text";
                }
                let diffmeta = {
                    differences: 0,
                    lines: 0
                };
                meta.insize = options.source.length + options.diff.length;
                output = prettydiff(diffmeta);
                meta.difftotal = diffmeta.differences;
                meta.difflines = diffmeta.lines;
            }
            else {
                meta.insize = options.source.length;
                output = prettydiff();
                if (output.indexOf("Error: ") === 0) {
                    ann.innerHTML = output.replace("Error: ", "");
                    output = options.source;
                }
            }
            renderOutput();
        };
        meta.error = "";
        options.api = "dom";
        options.crlf = (lf !== null && lf.checked === true);
        if (typeof event === "object" && event !== null && event.type === "keyup") {
            // jsscope does not get the convenience of keypress execution, because its
            // overhead is costly do not execute keypress from alt, home, end, or arrow keys
            if ((textout === false && options.mode === "beautify") || event.altKey === true || event.keyCode === 16 || event.keyCode === 18 || event.keyCode === 35 || event.keyCode === 36 || event.keyCode === 37 || event.keyCode === 38 || event.keyCode === 39 || event.keyCode === 40) {
                return false;
            }
            if (test.keypress === true) {
                if (test.keystore.length > 0) {
                    test
                        .keystore
                        .pop();
                    if (event.keyCode === 17 || event.ctrlKey === true || event.keyCode === 224) {
                        test.keypress = false;
                        test.keystore = [];
                    }
                    else {
                        if (test.keystore.length === 0) {
                            test.keypress = false;
                        }
                        return false;
                    }
                }
            }
            if ((event.keyCode === 17 || event.ctrlKey === true || event.keyCode === 224) && test.keypress === true && test.keystore.length === 0) {
                test.keypress = false;
                return false;
            }
        }
        if (test.ace === true) {
            options.source = aceStore.codeIn.getValue();
        }
        else {
            options.source = textarea.codeIn.value;
        }
        if (options.source === undefined || options.source === "") {
            if (ann !== null) {
                ann.innerHTML = "No source sample to process.";
            }
            return false;
        }
        if (test.store === true) {
            if (options.source.length > 4800000) {
                // eslint-disable-next-line
                console.warn("Source sample too large to save in browser localStorage.");
            }
            else {
                localStorage.setItem("source", options.source);
            }
        }
        //gather updated dom nodes
        {
            const li = id("addOptions").getElementsByTagName("li"), reg = (/option-((true-)|(false-))?/);
            let a = li.length, select, input, opt;
            do {
                a = a - 1;
                if (li[a].getElementsByTagName("div")[0].style.display === "none") {
                    select = li[a].getElementsByTagName("select")[0];
                    if (select === undefined) {
                        input = li[a].getElementsByTagName("input")[0];
                        if (input.getAttribute("type") === "radio") {
                            if (input.value === "false" && input.checked === true) {
                                options[input.getAttribute("id").replace(reg, "")] = false;
                            }
                            else if (input.value === "false" && input.checked === false) {
                                options[input.getAttribute("id").replace(reg, "")] = true;
                            }
                            else if (input.value === "true" && input.checked === true) {
                                options[input.getAttribute("id").replace(reg, "")] = true;
                            }
                            else if (input.value === "true" && input.checked === false) {
                                options[input.getAttribute("id").replace(reg, "")] = false;
                            }
                        }
                        else {
                            if (input.getAttribute("data-type") === "number") {
                                options[input.getAttribute("id").replace(reg, "")] = Number(input.value);
                            }
                            else {
                                options[input.getAttribute("id").replace(reg, "")] = input.value;
                            }
                        }
                    }
                    else {
                        opt = select[select.selectedIndex];
                        options[select.getAttribute("id").replace(reg, "")] = opt.value;
                    }
                }
            } while (a > 0);
        }
        if (options.language === "") {
            options.language = "auto";
        }
        if (options.language === "auto") {
            autolang = true;
        }
        if (options.lexer === "auto") {
            autolexer = true;
        }
        if (test.ace === true) {
            options.source = aceStore.codeIn.getValue();
        }
        else {
            options.source = textarea.codeIn.value;
        }
        if (domain.test(options.source) === true) {
            const filetest = (options.source.indexOf("file:///") === 0), protocolRemove = (filetest === true)
                ? options
                    .source
                    .split(":///")[1]
                : options
                    .source
                    .split("://")[1], slashIndex = (protocolRemove !== undefined)
                ? protocolRemove.indexOf("/")
                : 0, xhr = new XMLHttpRequest();
            if ((slashIndex > 0 || options.source.indexOf("http") === 0) && typeof protocolRemove === "string" && protocolRemove.length > 0) {
                requests = true;
                xhr.onreadystatechange = function dom_event_execute_xhrSource_statechange() {
                    if (xhr.readyState === 4) {
                        if (xhr.status === 200 || xhr.status === 0) {
                            options.source = xhr
                                .responseText
                                .replace(/\r\n/g, "\n");
                            if (options.mode !== "diff" || requestd === false || (requestd === true && completed === true)) {
                                if (test.ace === true) {
                                    lang = method
                                        .app
                                        .langkey({
                                        sample: aceStore.codeIn.getValue(),
                                        name: "auto"
                                    });
                                }
                                else {
                                    lang = method
                                        .app
                                        .langkey({
                                        sample: options.source,
                                        name: "auto"
                                    });
                                }
                                app();
                                return;
                            }
                            completes = true;
                        }
                        else {
                            options.source = "Error: transmission failure receiving source code from address.";
                        }
                    }
                };
                if (filetest === true) {
                    xhr.open("GET", options.source.replace(/(\s*)$/, "").replace(/%26/g, "&").replace(/%3F/, "?"), true);
                }
                else {
                    xhr.open("GET", `proxy.php?x=${options.source.replace(/(\s*)$/, "").replace(/%26/g, "&").replace(/%3F/, "?")}`, true);
                }
                xhr.send();
            }
        }
        if (options.mode === "diff") {
            if (id("inputlabel") !== null) {
                options.source_label = id("inputlabel").value;
            }
            if (id("outputlabel") !== null) {
                options.diff_label = id("outputlabel").value;
            }
            if (test.ace === true) {
                options.diff = aceStore.codeOut.getValue();
            }
            else {
                options.diff = textarea.codeOut.value;
            }
            if (options.diff === undefined || options.diff === "") {
                return false;
            }
            if (test.store === true) {
                localStorage.setItem("diff", options.diff);
            }
            if (options.language === "text" || options.lexer === "text") {
                options.language = "text";
                options.lexer = "text";
                options.language_name = "Plain Text";
                autolang = false;
                autolexer = false;
            }
            if (test.ace === true) {
                options.diff = aceStore.codeOut.getValue();
            }
            else {
                options.diff = textarea.codeOut.value;
            }
            if (domain.test(options.diff) === true) {
                const filetest = (options.diff.indexOf("file:///") === 0), protocolRemove = (filetest === true)
                    ? options
                        .diff
                        .split(":///")[1]
                    : options
                        .diff
                        .split("://")[1], slashIndex = (protocolRemove !== undefined)
                    ? protocolRemove.indexOf("/")
                    : 0, xhr = new XMLHttpRequest();
                if ((slashIndex > 0 || options.diff.indexOf("http") === 0) && typeof protocolRemove === "string" && protocolRemove.length > 0) {
                    requestd = true;
                    xhr.onreadystatechange = function dom_event_execute_xhrSource_statechange() {
                        if (xhr.readyState === 4) {
                            if (xhr.status === 200 || xhr.status === 0) {
                                options.diff = xhr
                                    .responseText
                                    .replace(/\r\n/g, "\n");
                                if (requests === false || (requests === true && completes === true)) {
                                    app();
                                    return;
                                }
                                completed = true;
                            }
                            else {
                                options.diff = "Error: transmission failure receiving diff code from address.";
                            }
                        }
                    };
                    if (filetest === true) {
                        xhr.open("GET", options.diff.replace(/(\s*)$/, "").replace(/%26/g, "&").replace(/%3F/, "?"), true);
                    }
                    else {
                        xhr.open("GET", `proxy.php?x=${options.diff.replace(/(\s*)$/, "").replace(/%26/g, "&").replace(/%3F/, "?")}`, true);
                    }
                    xhr.send();
                }
            }
        }
        else {
            if (ann !== null) {
                if (options.language === "text") {
                    ann.innerHTML = "The value of <em>options.language</em> is <strong>text</strong> but <em>options.mode</em> is not <strong>diff</strong>.";
                }
                else if (options.lexer === "text") {
                    ann.innerHTML = "The value of <em>options.lexer</em> is <strong>text</strong> but <em>options.mode</em> is not <strong>diff</strong>.";
                }
            }
        }
        if (requests === false && requestd === false) {
            if (langvalue === "auto") {
                if (test.ace === true) {
                    lang = method
                        .app
                        .langkey({
                        sample: aceStore.codeIn.getValue(),
                        name: "auto"
                    });
                }
                else {
                    lang = method
                        .app
                        .langkey({
                        sample: id("input").value,
                        name: "auto"
                    });
                }
            }
            else {
                lang = method.app.langkey({
                    sample: "",
                    name: langvalue
                });
            }
            app();
        }
    };
    // this function allows typing of tab characters into textareas without the
    // textarea loosing focus
    method.event.fixtabs = function dom_event_fixtabs(event, node) {
        let start = "", end = "", val = "", sel = 0;
        if (typeof event !== "object" || event === null || event.type !== "keydown" || event.keyCode !== 9 || typeof node.selectionStart !== "number" || typeof node.selectionEnd !== "number") {
            return true;
        }
        val = node.value;
        sel = node.selectionStart;
        start = val.substring(0, sel);
        end = val.substring(sel, val.length);
        node.value = `${start}\t${end}`;
        node.selectionStart = sel + 1;
        node.selectionEnd = sel + 1;
        event.preventDefault();
        return false;
    };
    //basic drag and drop for the report windows references events: minimize
    method.event.grab = function dom_event_grab(event) {
        const x = event.srcElement || event.target, box = (x.nodeName.toLowerCase() === "h3")
            ? x.parentNode
            : x.parentNode.parentNode, parent = box.getElementsByTagName("p")[0], save = (parent.innerHTML.indexOf("save") > -1), minifyTest = (parent.style.display === "none"), buttons = box
            .getElementsByTagName("p")[0]
            .getElementsByTagName("button"), minButton = (save === true)
            ? buttons[1]
            : buttons[0], resize = (save === true)
            ? buttons[3]
            : buttons[2], touch = (event !== null && event.type === "touchstart"), mouseEvent = event, touchEvent = event, mouseX = (touch === true)
            ? 0
            : mouseEvent.clientX, mouseY = (touch === true)
            ? 0
            : mouseEvent.clientY, touchX = (touch === true)
            ? touchEvent.touches[0].clientX
            : 0, touchY = (touch === true)
            ? touchEvent.touches[0].clientY
            : 0, filled = ((box === report.stat.box && test.filled.stat === true) || (box === report.feed.box && test.filled.feed === true) || (box === report.code.box && test.filled.code === true)), drop = function dom_event_grab_drop(e) {
            const headingWidth = box.getElementsByTagName("h3")[0].clientWidth, idval = box.getAttribute("id").replace("report", "");
            boxLeft = box.offsetLeft;
            boxTop = box.offsetTop;
            if (touch === true) {
                document.ontouchmove = null;
                document.ontouchend = null;
            }
            else {
                document.onmousemove = null;
                document.onmouseup = null;
            }
            if (boxTop < 10) {
                box.style.top = "1em";
            }
            else if (boxTop > (max - 40)) {
                box.style.top = `${(max / 10) - 4}em`;
            }
            else {
                box.style.top = `${boxTop / 10}em`;
            }
            if (boxLeft < ((headingWidth * -1) + 40)) {
                box.style.left = `${((headingWidth * -1) + 40) / 10}em`;
            }
            data.settings.report[idval].top = boxTop;
            data.settings.report[idval].left = boxLeft;
            body.style.opacity = "1";
            box.style.height = "auto";
            heading.style.top = "100%";
            resize.style.top = "100%";
            method
                .app
                .options(e);
            e.preventDefault();
            return false;
        }, boxmoveTouch = function dom_event_grab_touch(f) {
            f.preventDefault();
            box.style.right = "auto";
            box.style.left = `${(boxLeft + (f.touches[0].clientX - touchX)) / 10}em`;
            box.style.top = `${(boxTop + (f.touches[0].clientY - touchY)) / 10}em`;
            document.ontouchend = drop;
            return false;
        }, boxmoveClick = function dom_event_grab_click(f) {
            f.preventDefault();
            box.style.right = "auto";
            box.style.left = `${(boxLeft + (f.clientX - mouseX)) / 10}em`;
            box.style.top = `${(boxTop + (f.clientY - mouseY)) / 10}em`;
            document.onmouseup = drop;
            return false;
        };
        let boxLeft = box.offsetLeft, boxTop = box.offsetTop, body = box.getElementsByTagName("div")[0], heading = (box.firstChild.nodeType > 1)
            ? box.firstChild.nextSibling
            : box.firstChild, max = document.getElementsByTagName("body")[0].clientHeight;
        if (minifyTest === true) {
            if (filled === true) {
                box.style.right = "auto";
            }
            else {
                box.style.left = "auto";
            }
            minButton.click();
            return false;
        }
        method
            .app
            .zTop(box);
        event.preventDefault();
        if (body.nodeType !== 1) {
            do {
                body = body.previousSibling;
            } while (body.nodeType !== 1);
        }
        if (heading.nodeType !== 1) {
            do {
                heading = heading.nextSibling;
            } while (heading.nodeType !== 1);
        }
        heading = heading.lastChild;
        if (heading.nodeType !== 1) {
            do {
                heading = heading.previousSibling;
            } while (heading.nodeType !== 1);
        }
        body.style.opacity = ".5";
        heading.style.top = `${box.clientHeight / 20}0em`;
        box.style.height = ".1em";
        resize.style.top = `${(Number(body.style.height.replace("em", "")) + 5.45) / 1.44}em`;
        if (touch === true) {
            document.ontouchmove = boxmoveTouch;
            document.ontouchstart = null;
        }
        else {
            document.onmousemove = boxmoveClick;
            document.onmousedown = null;
        }
        method
            .app
            .options(event);
        return false;
    };
    //tests if a key press is a short command
    method.event.keydown = function dom_event_keydown(event) {
        if (test.keypress === true && (test.keystore.length === 0 || event.keyCode !== test.keystore[test.keystore.length - 1]) && event.keyCode !== 17 && event.keyCode !== 224) {
            test
                .keystore
                .push(event.keyCode);
        }
        if (event.keyCode === 17 || event.ctrlKey === true || event.keyCode === 224) {
            test.keypress = true;
        }
    };
    //maximize report window to available browser window
    method.event.maximize = function dom_event_maximize(event) {
        let node = event.srcElement || event.target, parent, save = false, box, idval = "", heading, body, top, left, buttons, resize, textarea;
        if (node.nodeType !== 1) {
            return;
        }
        parent = document.body.parentNode;
        left = (parent.scrollLeft > document.body.scrollLeft)
            ? parent.scrollLeft
            : document.body.scrollLeft;
        top = (parent.scrollTop > document.body.scrollTop)
            ? parent.scrollTop
            : document.body.scrollTop;
        parent = node.parentNode;
        buttons = parent.getElementsByTagName("button");
        resize = buttons[buttons.length - 1];
        save = (parent.innerHTML.indexOf("save") > -1);
        box = parent.parentNode;
        idval = box.getAttribute("id").replace("report", "");
        heading = box.getElementsByTagName("h3")[0];
        body = box.getElementsByTagName("div")[0];
        method
            .app
            .zTop(box);
        //maximize
        if (node.innerHTML === "\u2191") {
            node.innerHTML = "\u2193";
            node.setAttribute("title", "Return this dialogue to its prior size and location.");
            data.settings.report[idval].max = true;
            data.settings.report[idval].min = false;
            if (test.store === true) {
                localStorage.setItem("settings", JSON.stringify(data.settings));
            }
            data.settings.report[idval].top = box.offsetTop;
            data.settings.report[idval].left = box.offsetLeft;
            data.settings.report[idval].height = body.clientHeight - 36;
            data.settings.report[idval].width = body.clientWidth - 3;
            data.settings.report[idval].zindex = box.style.zIndex;
            box.style.top = `${top / 10}em`;
            box.style.left = `${left / 10}em`;
            if (typeof window.innerHeight === "number") {
                body.style.height = `${(window.innerHeight / 10) - 5.5}em`;
                if (save === true) {
                    heading.style.width = `${(window.innerWidth / 10) - 13.76}em`;
                }
                else {
                    heading.style.width = `${(window.innerWidth / 10) - 10.76}em`;
                }
                body.style.width = `${(window.innerWidth / 10) - 4.1}em`;
            }
            resize.style.display = "none";
            //return to normal size
        }
        else {
            data.settings.report[idval].max = false;
            node.innerHTML = "\u2191";
            node.setAttribute("title", "Maximize this dialogue to the browser window.");
            box.style.top = `${data.settings.report[idval].top / 10}em`;
            box.style.left = `${data.settings.report[idval].left / 10}em`;
            if (save === true) {
                heading.style.width = `${(data.settings.report[idval].width / 10) - 9.76}em`;
            }
            else {
                heading.style.width = `${(data.settings.report[idval].width / 10) - 6.76}em`;
            }
            body.style.width = `${data.settings.report[idval].width / 10}em`;
            body.style.height = `${data.settings.report[idval].height / 10}em`;
            box.style.zIndex = data.settings.report[idval].zindex;
            resize.style.display = "block";
            method
                .app
                .options(event);
        }
        textarea = body.getElementsByTagName("textarea");
        if (textarea.length === 1) {
            textarea[0].style.height = `${(body.clientHeight - 140) / 12}em`;
        }
    };
    //minimize report windows to the default size and location
    method.event.minimize = function dom_event_minimize(e) {
        const node = e.srcElement || e.target, growth = function dom_event_minimize_growth() {
            let width = 17, height = 3, leftTarget = 0, topTarget = 0, widthTarget = 0, heightTarget = 0, incW = 0, incH = 0, incL = 0, incT = 0, saveSpace = (save === true)
                ? 9.45
                : 6.45, grow = function dom_event_minimize_growth_grow() {
                width = width + incW;
                height = height + incH;
                left = left + incL;
                top = top + incT;
                body.style.width = `${width}em`;
                body.style.height = `${height}em`;
                heading.style.width = `${width - saveSpace}em`;
                box.style.left = `${left}em`;
                box.style.top = `${top}em`;
                if (width + incW < widthTarget || height + incH < heightTarget) {
                    setTimeout(dom_event_minimize_growth_grow, 1);
                }
                else {
                    box.style.left = `${leftTarget}em`;
                    box.style.top = `${topTarget}em`;
                    body.style.width = `${widthTarget}em`;
                    body.style.height = `${heightTarget}em`;
                    heading.style.width = `${widthTarget - saveSpace}em`;
                    method
                        .app
                        .options(e);
                    if (textarea.length === 1) {
                        textarea[0].style.display = "block";
                        textarea[0].style.height = `${(body.clientHeight - 140) / 12}em`;
                    }
                    return false;
                }
                return true;
            };
            method
                .app
                .zTop(box);
            buttonMin.innerHTML = "\u035f";
            parent.style.display = "block";
            box.style.borderWidth = ".1em";
            box.style.right = "auto";
            body.style.display = "block";
            heading.getElementsByTagName("button")[0].style.cursor = "move";
            heading.style.borderLeftStyle = "none";
            heading.style.borderTopStyle = "none";
            heading.style.margin = "-0.1em 1.7em -3.2em -0.1em";
            if (test.agent.indexOf("macintosh") > 0) {
                saveSpace = (save === true)
                    ? 8
                    : 5;
            }
            if (typeof data.settings.report[idval].left === "number") {
                leftTarget = (data.settings.report[idval].left / 10);
                topTarget = (data.settings.report[idval].top / 10);
                widthTarget = (data.settings.report[idval].width / 10);
                heightTarget = (data.settings.report[idval].height / 10);
            }
            else {
                top = top + 4;
                data.settings.report[idval].left = 200;
                data.settings.report[idval].top = (top * 10);
                data.settings.report[idval].width = 550;
                data.settings.report[idval].height = 450;
                leftTarget = 10;
                topTarget = 2;
                widthTarget = 55;
                heightTarget = 45;
            }
            widthTarget = widthTarget - 0.3;
            heightTarget = heightTarget - 3.55;
            if (step === 1) {
                box.style.left = `${leftTarget}em`;
                box.style.top = `${topTarget}em`;
                body.style.width = `${widthTarget}em`;
                body.style.height = `${heightTarget}em`;
                heading.style.width = `${widthTarget - saveSpace}em`;
                body.style.right = "auto";
                body.style.display = "block";
                box.getElementsByTagName("p")[0].style.display = "block";
                method
                    .app
                    .options(e);
                if (textarea.length === 1) {
                    textarea[0].style.display = "block";
                    textarea[0].style.height = `${(body.clientHeight - 140) / 12}em`;
                }
                return false;
            }
            incW = (widthTarget > width)
                ? ((widthTarget - width) / step)
                : ((width - widthTarget) / step);
            incH = (heightTarget > height)
                ? ((heightTarget - height) / step)
                : ((height - heightTarget) / step);
            incL = (leftTarget - left) / step;
            incT = (topTarget - top) / step;
            box.style.right = "auto";
            body.style.display = "block";
            grow();
            return false;
        }, shrinkage = function dom_event_minimize_shrinkage() {
            let width = body.clientWidth / 10, height = body.clientHeight / 10, incL = (((window.innerWidth / 10) - final - 17) - left) / step, incT = 0, incW = (width === 17)
                ? 0
                : (width > 17)
                    ? ((width - 17) / step)
                    : ((17 - width) / step), incH = height / step, shrink = function dom_event_minimize_shrinkage_shrink() {
                left = left + incL;
                top = top + incT;
                width = width - incW;
                height = height - incH;
                body.style.width = `${width}em`;
                heading.style.width = `${width}em`;
                body.style.height = `${height}em`;
                box.style.left = `${left}em`;
                box.style.top = `${top}em`;
                if (width - incW > 16.8) {
                    setTimeout(dom_event_minimize_shrinkage_shrink, 1);
                }
                else {
                    box.style.left = "auto";
                    box.style.top = "auto";
                    box.style.right = `${final}em`;
                    data.settings.report[idval].max = false;
                    body.style.display = "none";
                    heading.getElementsByTagName("button")[0].style.cursor = "pointer";
                    heading.style.margin = "-0.1em 0em -3.2em -0.1em";
                    box.style.zIndex = "2";
                    method
                        .app
                        .options(e);
                    return false;
                }
                return true;
            };
            parentNode = box.parentNode;
            incT = (((parentNode.offsetTop / 10) - top) / step);
            buttonMin.innerHTML = "\u2191";
            if (textarea.length === 1) {
                textarea[0].style.display = "none";
            }
            //if a maximized window is minimized
            if (buttonMax.innerHTML === "\u2191") {
                if (test.agent.indexOf("macintosh") > 0) {
                    data.settings.report[idval].top = box.offsetTop;
                    data.settings.report[idval].left = box.offsetLeft;
                    data.settings.report[idval].height = body.clientHeight - 17;
                    data.settings.report[idval].width = body.clientWidth - 17;
                }
                else {
                    data.settings.report[idval].top = box.offsetTop;
                    data.settings.report[idval].left = box.offsetLeft;
                    data.settings.report[idval].height = body.clientHeight;
                    data.settings.report[idval].width = body.clientWidth;
                }
                if (data.zIndex > 2) {
                    data.zIndex = data.zIndex - 3;
                    parent.style.zIndex = data.zIndex;
                }
            }
            else {
                buttonMax.innerHTML = "\u2191";
                data.settings.report[idval].top = data.settings.report[idval].top + 1;
                data.settings.report[idval].left = data.settings.report[idval].left - 7;
                data.settings.report[idval].height = data.settings.report[idval].height + 35.5;
                data.settings.report[idval].width = data.settings.report[idval].width + 3;
            }
            parent.style.display = "none";
            shrink();
            return false;
        };
        let parent = node.parentNode, parentNode, box, final = 0, idval = "", body, heading, buttons, save = false, buttonMin, buttonMax, left = 0, top = 0, buttonRes, textarea, step = (parent.style.display === "none" && (options.mode === "diff" || (options.mode === "beautify" && options.jsscope === "report" && options.lang === "javascript")))
            ? 1
            : 50;
        if (node.parentNode.nodeName.toLowerCase() === "h3") {
            heading = node.parentNode;
            box = heading.parentNode;
            parent = box.getElementsByTagName("p")[0];
        }
        else {
            parent = (node.parentNode.nodeName.toLowerCase() === "a")
                ? node.parentNode.parentNode
                : node.parentNode;
            box = parent.parentNode;
            heading = box.getElementsByTagName("h3")[0];
        }
        idval = box.getAttribute("id").replace("report", "");
        body = box.getElementsByTagName("div")[0];
        textarea = body.getElementsByTagName("textarea");
        buttons = parent.getElementsByTagName("button");
        save = (parent.innerHTML.indexOf("save") > -1);
        buttonMin = (save === true)
            ? buttons[1]
            : buttons[0];
        buttonMax = (save === true)
            ? buttons[2]
            : buttons[1];
        left = (box.offsetLeft / 10 > 1)
            ? box.offsetLeft / 10
            : 1;
        top = (box.offsetTop / 10 > 1)
            ? box.offsetTop / 10
            : 1;
        buttonRes = (save === true)
            ? buttons[3]
            : buttons[2];
        buttonRes.style.display = "block";
        if (box === report.feed.box) {
            if (test.filled.feed === true) {
                step = 1;
            }
            final = 38.8;
        }
        if (box === report.code.box) {
            if (test.filled.code === true) {
                step = 1;
            }
            final = 19.8;
        }
        if (box === report.stat.box) {
            if (test.filled.stat === true) {
                step = 1;
            }
            final = 0.8;
        }
        if (typeof e.preventDefault === "function") {
            e.preventDefault();
        }
        if (buttonMin.innerHTML === "\u035f") {
            shrinkage();
        }
        else {
            growth();
        }
        return false;
    };
    //toggles between modes
    method.event.modeToggle = function dom_event_modeToggle(mode) {
        const commentString = function dom_event_modeToggle_commentString() {
            const value = `mode: "${options.mode}"`;
            let a = data.commentString.length;
            if (a > 0) {
                do {
                    a = a - 1;
                    if (data.commentString[a].indexOf("mode:") === 0) {
                        data.commentString[a] = value;
                        break;
                    }
                    if (data.commentString[a] < "mode:") {
                        data.commentString.splice(a, 0, value);
                        break;
                    }
                } while (a > 0);
            }
            else {
                data.commentString.push(value);
            }
            method.app.commentString();
        }, cycleOptions = function dom_event_modeToggle_cycleOptions() {
            const li = id("addOptions").getElementsByTagName("li"), lilen = li.length, disable = function dom_event_modeToggle_cycleOptions_disable(parent, enable) {
                const inputs = parent.getElementsByTagName("input"), sels = parent.getElementsByTagName("select");
                if (sels.length > 0) {
                    if (enable === true) {
                        sels[0].disabled = false;
                    }
                    else {
                        sels[0].disabled = true;
                    }
                }
                else {
                    if (enable === true) {
                        inputs[0].disabled = false;
                    }
                    else {
                        inputs[0].disabled = true;
                    }
                    if (inputs.length > 1) {
                        if (enable === true) {
                            inputs[1].disabled = false;
                        }
                        else {
                            inputs[1].disabled = true;
                        }
                    }
                }
            };
            let a = 0, div, modeat;
            do {
                if (li[a].getAttribute("data-mode") !== "any") {
                    div = li[a].getElementsByTagName("div")[0];
                    modeat = li[a].getAttribute("data-mode");
                    if (modeat !== mode && mode !== "diff") {
                        div.innerHTML = `This option is not available in mode '${mode}'.`;
                        div.style.display = "block";
                        disable(li[a], false);
                    }
                    else if (mode === "diff" && modeat !== "diff" && modeat !== "beautify") {
                        div.innerHTML = `This option is not available in mode '${mode}'.`;
                        div.style.display = "block";
                        disable(li[a], false);
                    }
                    else {
                        div.style.display = "none";
                        disable(li[a], true);
                    }
                }
                a = a + 1;
            } while (a < lilen);
        }, makeChanges = function dom_event_modeToggle_makeChanges() {
            const text = mode.charAt(0).toUpperCase() + mode.slice(1), ci = id("codeInput"), cilabel = ci.getElementsByTagName("label"), input = id("input"), output = id("output"), outLabel = ci.getElementsByClassName("inputLabel")[1], sourceLabel = id("inputlabel").parentNode, outputLabel = id("outputlabel").parentNode, outputFile = id("outputfile").parentNode;
            if (mode === "diff") {
                ci.getElementsByTagName("h2")[0].innerHTML = "Compare Code";
                cilabel[0].innerHTML = "Base File";
                cilabel[2].innerHTML = "Compare code sample";
                cilabel[5].innerHTML = " Compare new code";
                outLabel.style.marginTop = "0";
                sourceLabel.style.display = "block";
                outputLabel.style.display = "block";
                outputFile.style.display = "block";
                id("slider").style.display = "none";
                if (options.color === "white") {
                    output.style.background = "#fff";
                }
                else if (options.color === "shadow") {
                    output.style.background = "transparent";
                }
                else if (options.color === "canvas") {
                    output.style.background = "#f2f2f2";
                }
                input.onkeyup = null;
                if (test.ace === true) {
                    aceStore.codeIn.onkeyup = null;
                    aceStore
                        .codeOut
                        .setReadOnly(false);
                    if (options.diff !== undefined && options.diff !== null) {
                        aceStore.codeOut.setValue(options.diff);
                    }
                    parent = output.parentNode;
                    parent.setAttribute("class", "output");
                }
                else {
                    output.readOnly = false;
                    if (options.diff !== undefined) {
                        output.value = options.diff;
                    }
                    parent = output.parentNode.parentNode;
                    parent.setAttribute("class", "output");
                }
            }
            else {
                ci.getElementsByTagName("h2")[0].innerHTML = text;
                cilabel[0].innerHTML = `${text} file`;
                cilabel[2].innerHTML = `${text} code sample`;
                cilabel[5].innerHTML = `${text} output`;
                parent = document.getElementById("inputfile").parentNode;
                outLabel.style.marginTop = `${(parent.clientHeight + 11.5) / 10}em`;
                sourceLabel.style.display = "none";
                outputLabel.style.display = "none";
                outputFile.style.display = "none";
                input.onkeyup = method.event.execute;
                if (options.mode === "beautify") {
                    id("slider").style.display = "block";
                }
                else {
                    id("slider").style.display = "none";
                }
                if (options.color === "white") {
                    output.style.background = "#f2f2f2";
                }
                else if (options.color === "shadow") {
                    output.style.background = "#111";
                }
                else if (options.color === "canvas") {
                    output.style.background = "#ccccc8";
                }
                if (test.ace === true) {
                    aceStore.codeOut.setValue("");
                    aceStore
                        .codeOut
                        .setReadOnly(true);
                    parent = output.parentNode;
                    parent.setAttribute("class", "readonly");
                }
                else {
                    output.readOnly = true;
                    output.value = "";
                    parent = output.parentNode.parentNode;
                    parent.setAttribute("class", "readonly");
                }
            }
        };
        let parent;
        options.mode = mode;
        makeChanges();
        cycleOptions();
        commentString();
    };
    //reset tool to default configuration
    method.event.reset = function dom_event_reset() {
        const comment = id("commentString");
        let nametry = "", name = "";
        localStorage.setItem("source", "");
        localStorage.setItem("diff", "");
        localStorage.setItem("commentString", "[]");
        if (data.settings === undefined || data.settings.knownname === undefined) {
            if (data.settings === undefined) {
                data.settings = {
                    feedback: {
                        newb: false,
                        veteran: false
                    }
                };
            }
            if (localStorage.getItem("settings") !== undefined && localStorage.getItem("settings") !== null) {
                nametry = JSON.stringify(localStorage.getItem("settings"));
            }
            if (localStorage.getItem("settings") === undefined || localStorage.getItem("settings") === null || nametry === "" || nametry.indexOf("knownname") < 0) {
                name = `"${Math
                    .random()
                    .toString()
                    .slice(2) + Math
                    .random()
                    .toString()
                    .slice(2)}"`;
            }
            data.settings.knownname = name;
        }
        if (data.settings.feedback === undefined) {
            data.settings.feedback = {
                newb: false,
                veteran: false
            };
        }
        localStorage.setItem("settings", `{"feedback":{"newb":${data.settings.feedback.newb},"veteran":${data.settings.feedback.veteran}},"report":{"code":{},"feed":{},"stat":{}},"knownname":${data.settings.knownname}}`);
        data.commentString = [];
        if (comment !== null) {
            comment.innerHTML = "/*prettydiff.com \u002a/";
        }
        id("modediff").checked = true;
        location.reload();
    };
    //resize report window to custom width and height on drag
    method.event.resize = function dom_event_resize(e) {
        let bodyWidth = 0, bodyHeight = 0;
        const node = e.srcElement || e.target, parent = node.parentNode, save = (parent.innerHTML.indexOf("save") > -1), box = parent.parentNode, body = box.getElementsByTagName("div")[0], offX = e.clientX, offY = e.clientY, heading = box.getElementsByTagName("h3")[0], mac = (test.agent.indexOf("macintosh") > 0), offsetw = (mac === true)
            ? 20
            : 4, offseth = (mac === true)
            ? 54
            : 36, drop = function dom_event_resize_drop() {
            document.onmousemove = null;
            bodyWidth = body.clientWidth;
            bodyHeight = body.clientHeight;
            method
                .app
                .options(e);
            document.onmouseup = null;
        }, boxsize = function dom_event_resize_boxsize(f) {
            body.style.width = `${(bodyWidth + ((f.clientX - offsetw) - offX)) / 10}em`;
            if (save === true) {
                heading.style.width = `${((bodyWidth + (f.clientX - offX)) / 10) - 10.15}em`;
            }
            else {
                heading.style.width = `${((bodyWidth + (f.clientX - offX)) / 10) - 7.15}em`;
            }
            body.style.height = `${(bodyHeight + ((f.clientY - offseth) - offY)) / 10}em`;
            document.onmouseup = drop;
        };
        bodyWidth = body.clientWidth,
            bodyHeight = body.clientHeight;
        method
            .app
            .zTop(box);
        document.onmousemove = boxsize;
        document.onmousedown = null;
    };
    //tell the browser to "save as"
    method.event.save = function dom_event_save() {
        let blob = new Blob([report.code.body.innerHTML], { type: "application/xhtml+xml;charset=utf-8" });
        prettydiff.saveAs(blob, "prettydiff.xhtml", { autoBom: true });
    };
    //analyzes combinations of consecutive key presses
    method.event.sequence = function dom_event_sequence(event) {
        let seq = test.keysequence;
        const len = seq.length, key = event.keyCode;
        if (len === 0 || len === 1) {
            if (key === 38) {
                seq.push(true);
            }
            else {
                test.keysequence = [];
                seq = test.keysequence;
            }
        }
        else if (len === 2 || len === 3) {
            if (key === 40) {
                seq.push(true);
            }
            else {
                test.keysequence = [];
                seq = test.keysequence;
            }
        }
        else if (len === 4 || len === 6) {
            if (key === 37) {
                seq.push(true);
            }
            else {
                test.keysequence = [];
                seq = test.keysequence;
            }
        }
        else if (len === 5 || len === 7) {
            if (key === 39) {
                seq.push(true);
            }
            else {
                test.keysequence = [];
                seq = test.keysequence;
            }
        }
        else if (len === 8) {
            if (key === 66) {
                seq.push(true);
            }
            else {
                test.keysequence = [];
                seq = test.keysequence;
            }
        }
        else if (len === 9) {
            if (key === 65) {
                if (data.audio !== undefined) {
                    data
                        .audio
                        .play();
                }
                const body = document.getElementsByTagName("body")[0], scroll = (document.documentElement.scrollTop > body.scrollTop)
                    ? document.documentElement.scrollTop
                    : body.scrollTop, color = id("option-color"), max = color
                    .getElementsByTagName("option")
                    .length - 1, change = function dom_event_sequence_colorChange_change() {
                    color.selectedIndex = ind;
                    method
                        .event
                        .colorScheme(event);
                };
                let ind = color.selectedIndex;
                ind = ind - 1;
                if (ind < 0) {
                    ind = max;
                }
                change();
                ind = ind + 1;
                if (ind > max) {
                    ind = 0;
                }
                setTimeout(change, 1500);
                document.documentElement.scrollTop = scroll;
                body.scrollTop = scroll;
            }
            test.keysequence = [];
        }
    };
    //intelligently raise the z-index of the report windows
    method.app.zTop = function dom_app_top(x) {
        const indexListed = data.zIndex, indexes = [
            (report.feed.box === null)
                ? 0
                : Number(report.feed.box.style.zIndex),
            (report.code.box === null)
                ? 0
                : Number(report.code.box.style.zIndex),
            (report.stat.box === null)
                ? 0
                : Number(report.stat.box.style.zIndex)
        ];
        let indexMax = Math.max(indexListed, indexes[0], indexes[1], indexes[2]) + 1;
        if (indexMax < 11) {
            indexMax = 11;
        }
        data.zIndex = indexMax;
        if (x.nodeType === 1) {
            x.style.zIndex = String(indexMax);
        }
    };
    // prettydiff dom insertion start
prettydiff=(function parse_init() {const parser = function parse_parser() {
        const langstore = [sparser.options.language, sparser.options.lexer];
        parse.count = -1;
        parse.data = {
            begin: [],
            ender: [],
            lexer: [],
            lines: [],
            stack: [],
            token: [],
            types: []
        };
        parse.datanames = [
            "begin",
            "ender",
            "lexer",
            "lines",
            "stack",
            "token",
            "types"
        ];
        parse.linesSpace = 0;
        parse.lineNumber = 1;
        parse.structure = [
            ["global", -1]
        ];
        parse.structure.pop = function parse_structure_pop() {
            const len = parse.structure.length - 1, arr = parse.structure[len];
            if (len > 0) {
                parse
                    .structure
                    .splice(len, 1);
            }
            return arr;
        };
        if (sparser.options.language === "auto" || sparser.options.lexer === "auto") {
            let lang = sparser.libs.language.auto(sparser.options.source, "javascript");
            if (sparser.options.language === "auto") {
                sparser.options.language = lang[0];
            }
            if (sparser.options.lexer === "auto") {
                sparser.options.lexer = lang[1];
            }
        }
        if (typeof sparser.lexers[sparser.options.lexer] === "function") {
            sparser.parseerror = "";
            // reset references data if sparser is used on multiple files
            parse.references = [[]];
            sparser.options.lexer_options = (sparser.options.lexer_options || {});
            Object.keys(sparser.lexers).forEach(function parse_lexers(value) {
                sparser.options.lexer_options[value] = (sparser.options.lexer_options[value] || {});
            });
            // This line parses the code using a lexer file
            sparser.lexers[sparser.options.lexer](`${sparser.options.source} `);
            // restore language and lexer values
        }
        else {
            sparser.parseerror = `Specified lexer, ${sparser.options.lexer}, is not a function.`;
        }
        // validate that all the data arrays are the same length
        (function parser_checkLengths() {
            let a = 0, b = 0;
            const keys = Object.keys(parse.data), c = keys.length;
            do {
                b = a + 1;
                do {
                    if (parse.data[keys[a]].length !== parse.data[keys[b]].length) {
                        sparser.parseerror = `"${keys[a]}" array is of different length than "${keys[b]}"`;
                        break;
                    }
                    b = b + 1;
                } while (b < c);
                a = a + 1;
            } while (a < c - 1);
        }());
        // fix begin values.  They must be reconsidered after reordering from object sort
        if (parse.data.begin.length > 0 && (sparser.options.lexer_options[sparser.options.lexer].object_sort === true || sparser.options.lexer_options.markup.tag_sort === true)) {
            parse.sortCorrection(0, parse.count + 1);
        }
        if (sparser.options.format === "csv") {
            let a = 0;
            const d = parse.data, data = ["index,begin,ender,lexer,lines,stack,token,types"], len = parse.count + 1;
            do {
                data.push([
                    a,
                    d.begin[a],
                    d.ender[a],
                    `"${d.lexer[a].replace(/"/g, "\"\"")}"`,
                    d.lines[a],
                    `"${d.stack[a].replace(/"/g, "\"\"")}"`,
                    `"${d.token[a].replace(/"/g, "\"\"")}"`,
                    `"${d.types[a].replace(/"/g, "\"\"")}"`
                ].join(","));
                a = a + 1;
            } while (a < len);
            return data.join("\r\n");
        }
        if (sparser.options.format === "markdown") {
            let a = 0, b = 0, strlen = 0, row = [], heading = "", line = "", str = "", begin = 0;
            const data = [], names = parse.datanames, longest = [1, 5, 5, 5, 5, 5, 5, 5], len = parse.count + 1;
            // first gather the string length of each data item
            longest[0] = String(parse.count).length;
            if (longest[0] < 5) {
                longest[0] = 5;
            }
            do {
                begin = String(parse.data.begin[a]).length;
                if (begin > longest[1]) {
                    longest[1] = begin;
                }
                begin = String(parse.data.ender[a]).length;
                if (begin > longest[2]) {
                    longest[2] = begin;
                }
                if (parse.data.lexer[a].length > longest[3]) {
                    longest[3] = parse.data.lexer[a].length;
                }
                begin = String(parse.data.lines[a]).length;
                if (begin > longest[4]) {
                    longest[4] = begin;
                }
                if (parse.data.stack[a].length > longest[5]) {
                    longest[5] = parse.data.stack[a].length;
                }
                if (parse.data.token[a].length > longest[6]) {
                    longest[6] = parse.data.token[a].length;
                }
                if (parse.data.types[a].length > longest[7]) {
                    longest[7] = parse.data.types[a].length;
                }
                a = a + 1;
            } while (a < len);
            names.splice(0, 0, "index");
            // second create the heading
            a = 0;
            do {
                row.push(parse.datanames[a]);
                if (longest[a] > 5) {
                    b = 5;
                    do {
                        row.push(" ");
                        b = b + 1;
                    } while (b < longest[a]);
                }
                row.push("|");
                a = a + 1;
            } while (a < 8);
            row.pop();
            heading = row.join("");
            row = [];
            // third create the line of dashes
            a = 0;
            do {
                b = 0;
                do {
                    row.push("-");
                    b = b + 1;
                } while (b < longest[a]);
                row.push("|");
                a = a + 1;
            } while (a < 8);
            row.pop();
            line = row.join("");
            row = [];
            // fourth create each data record
            a = 0;
            do {
                if (a % 100 === 0) {
                    data.push(heading);
                    data.push(line);
                }
                str = String(a);
                row.push(str);
                b = str.length;
                if (b < longest[0]) {
                    do {
                        row.push(" ");
                        b = b + 1;
                    } while (b < longest[0]);
                }
                row.push("|");
                b = 1;
                do {
                    str = String(parse.data[parse.datanames[b]][a]);
                    row.push(str);
                    strlen = str.length;
                    if (strlen < longest[b]) {
                        do {
                            row.push(" ");
                            strlen = strlen + 1;
                        } while (strlen < longest[b]);
                    }
                    row.push("|");
                    b = b + 1;
                } while (b < 8);
                row.pop();
                data.push(row.join(""));
                row = [];
                a = a + 1;
            } while (a < len);
            return data.join("\r\n");
        }
        if (sparser.options.format === "minimal") {
            let a = 0;
            const data = [], len = parse.count + 1;
            do {
                data.push([
                    parse.data.begin[a],
                    parse.data.ender[a],
                    parse.data.lexer[a],
                    parse.data.lines[a],
                    parse.data.stack[a],
                    parse.data.token[a],
                    parse.data.types[a]
                ]);
                a = a + 1;
            } while (a < len);
            return data;
        }
        if (sparser.options.format === "objects") {
            let a = 0;
            const data = [], len = parse.count + 1;
            do {
                data.push({
                    begin: parse.data.begin[a],
                    ender: parse.data.ender[a],
                    lexer: parse.data.lexer[a],
                    lines: parse.data.lines[a],
                    stack: parse.data.stack[a],
                    token: parse.data.token[a],
                    types: parse.data.types[a]
                });
                a = a + 1;
            } while (a < len);
            return data;
        }
        if (sparser.options.format === "testprep") {
            let a = 0;
            const data = [], len = parse.count + 1;
            if (sparser.parseerror !== "") {
                return sparser.parseerror;
            }
            do {
                data.push(JSON.stringify({
                    begin: parse.data.begin[a],
                    ender: parse.data.ender[a],
                    lexer: parse.data.lexer[a],
                    lines: parse.data.lines[a],
                    stack: parse.data.stack[a],
                    token: parse.data.token[a],
                    types: parse.data.types[a]
                }));
                a = a + 1;
            } while (a < len);
            return `[\n${data.join(",\n")}\n]`;
        }
        sparser.options.language = langstore[0];
        sparser.options.lexer = langstore[1];
        return parse.data;
    }, parse = {
        // stores the final index location of the data arrays
        count: -1,
        // stores the various data arrays of the parse table
        data: {
            begin: [],
            ender: [],
            lexer: [],
            lines: [],
            stack: [],
            token: [],
            types: []
        },
        // stores the name of the data arrays.  This is used for internal automation
        datanames: ["begin", "ender", "lexer", "lines", "stack", "token", "types"],
        // stores the current line number from the input string for logging parse errors
        lineNumber: 1,
        // stores the 'lines' value before the next token
        linesSpace: 0,
        // stores the declared variable names for the script lexer.  This must be stored outside the script lexer since some languages recursive use of the script lexer
        references: [[]],
        // stores the stack and begin values by stacking depth
        structure: [["global", -1]],
        // an extension of Array.prototype.concat to work across the data structure.  This is an expensive operation.
        concat: function parse_concat(data, array) {
            parse
                .datanames
                .forEach(function parse_concat_datanames(value) {
                data[value] = data[value].concat(array[value]);
            });
            if (data === parse.data) {
                parse.count = data.token.length - 1;
            }
        },
        // the function that sorts object properties
        object_sort: function parse_objectSort(data) {
            let cc = parse.count, global = (data.lexer[cc] === "style" && parse.structure[parse.structure.length - 1][0] === "global"), dd = parse.structure[parse.structure.length - 1][1], ee = 0, ff = 0, gg = 0, behind = 0, commaTest = true, front = 0, keyend = 0, keylen = 0;
            const keys = [], length = parse.count, begin = dd, stack = (global === true)
                ? "global"
                : parse.structure[parse.structure.length - 1][0], style = (data.lexer[cc] === "style"), delim = (style === true)
                ? [";", "separator"]
                : [",", "separator"], lines = parse.linesSpace, sort = function parse_objectSort_sort(x, y) {
                let xx = x[0], yy = y[0];
                if (data.types[xx] === "comment") {
                    do {
                        xx = xx + 1;
                    } while (xx < length && (data.types[xx] === "comment"));
                    if (data.token[xx] === undefined) {
                        return 1;
                    }
                }
                if (data.types[yy] === "comment") {
                    do {
                        yy = yy + 1;
                    } while (yy < length && (data.types[yy] === "comment"));
                    if (data.token[yy] === undefined) {
                        return 1;
                    }
                }
                if (style === true) {
                    if (data.token[xx].indexOf("@import") === 0 || data.token[yy].indexOf("@import") === 0) {
                        // JavaScript's standard array sort uses implementation specific algorithms.
                        // This simple numeric trick forces conformance.
                        if (xx < yy) {
                            return -1;
                        }
                        return 1;
                    }
                    if (data.types[xx] !== data.types[yy]) {
                        if (data.types[xx] === "function") {
                            return 1;
                        }
                        if (data.types[xx] === "variable") {
                            return -1;
                        }
                        if (data.types[xx] === "selector") {
                            return 1;
                        }
                        if (data.types[xx] === "property" && data.types[yy] !== "variable") {
                            return -1;
                        }
                        if (data.types[xx] === "mixin" && data.types[yy] !== "property" && data.types[yy] !== "variable") {
                            return -1;
                        }
                    }
                }
                if (data.token[xx].toLowerCase() > data.token[yy].toLowerCase()) {
                    return 1;
                }
                return -1;
            }, store = {
                begin: [],
                ender: [],
                lexer: [],
                lines: [],
                stack: [],
                token: [],
                types: []
            };
            behind = cc;
            do {
                if (data.begin[cc] === dd || (global === true && cc < behind && data.token[cc] === "}" && data.begin[data.begin[cc]] === -1)) {
                    if (data.types[cc].indexOf("template") > -1) {
                        return;
                    }
                    if (data.token[cc] === delim[0] || (style === true && data.token[cc] === "}" && data.token[cc + 1] !== ";")) {
                        commaTest = true;
                        front = cc + 1;
                    }
                    else if (style === true && data.token[cc - 1] === "}") {
                        commaTest = true;
                        front = cc;
                    }
                    if (front === 0 && data.types[0] === "comment") {
                        // keep top comments at the top
                        do {
                            front = front + 1;
                        } while (data.types[front] === "comment");
                    }
                    else if (data.types[front] === "comment" && data.lines[front] < 2) {
                        // if a comment follows code on the same line then keep the comment next to the code it follows
                        front = front + 1;
                    }
                    if (commaTest === true && (data.token[cc] === delim[0] || (style === true && data.token[cc - 1] === "}")) && front <= behind) {
                        if (style === true && "};".indexOf(data.token[behind]) < 0) {
                            behind = behind + 1;
                        }
                        else if (style === false && data.token[behind] !== ",") {
                            behind = behind + 1;
                        }
                        keys.push([front, behind]);
                        if (style === true && data.token[front] === "}") {
                            behind = front;
                        }
                        else {
                            behind = front - 1;
                        }
                    }
                }
                cc = cc - 1;
            } while (cc > dd);
            if (keys.length > 0 && keys[keys.length - 1][0] > cc + 1) {
                ee = keys[keys.length - 1][0] - 1;
                if (data.types[ee] === "comment" && data.lines[ee] > 1) {
                    do {
                        ee = ee - 1;
                    } while (ee > 0 && data.types[ee] === "comment");
                    keys[keys.length - 1][0] = ee + 1;
                }
                if (data.types[cc + 1] === "comment" && cc === -1) {
                    do {
                        cc = cc + 1;
                    } while (data.types[cc + 1] === "comment");
                }
                keys.push([
                    cc + 1,
                    ee
                ]);
            }
            if (keys.length > 1) {
                if (style === true || data.token[cc - 1] === "=" || data.token[cc - 1] === ":" || data.token[cc - 1] === "(" || data.token[cc - 1] === "[" || data.token[cc - 1] === "," || data.types[cc - 1] === "word" || cc === 0) {
                    keys.sort(sort);
                    keylen = keys.length;
                    commaTest = false;
                    dd = 0;
                    do {
                        keyend = keys[dd][1];
                        if (style === true) {
                            gg = keyend;
                            if (data.types[gg] === "comment") {
                                gg = gg - 1;
                            }
                            if (data.token[gg] === "}") {
                                keyend = keyend + 1;
                                delim[0] = "}";
                                delim[1] = "end";
                            }
                            else {
                                delim[0] = ";";
                                delim[1] = "separator";
                            }
                        }
                        ee = keys[dd][0];
                        if (style === true && data.types[keyend - 1] !== "end" && data.types[keyend] === "comment" && data.types[keyend + 1] !== "comment" && dd < keylen - 1) {
                            // missing a terminal comment causes many problems
                            keyend = keyend + 1;
                        }
                        if (ee < keyend) {
                            do {
                                if (style === false && dd === keylen - 1 && ee === keyend - 2 && data.token[ee] === "," && data.lexer[ee] === "script" && data.types[ee + 1] === "comment") {
                                    // do not include terminal commas that are followed by a comment
                                    ff = ff + 1;
                                }
                                else {
                                    parse.push(store, {
                                        begin: data.begin[ee],
                                        ender: data.begin[ee],
                                        lexer: data.lexer[ee],
                                        lines: data.lines[ee],
                                        stack: data.stack[ee],
                                        token: data.token[ee],
                                        types: data.types[ee]
                                    }, "");
                                    ff = ff + 1;
                                }
                                //remove extra commas
                                if (data.token[ee] === delim[0] && (style === true || data.begin[ee] === data.begin[keys[dd][0]])) {
                                    commaTest = true;
                                }
                                else if (data.token[ee] !== delim[0] && data.types[ee] !== "comment") {
                                    commaTest = false;
                                }
                                ee = ee + 1;
                            } while (ee < keyend);
                        }
                        // injecting the list delimiter
                        if (commaTest === false && store.token[store.token.length - 1] !== "x;" && (style === true || dd < keylen - 1)) {
                            ee = store.types.length - 1;
                            if (store.types[ee] === "comment") {
                                do {
                                    ee = ee - 1;
                                } while (ee > 0 && (store.types[ee] === "comment"));
                            }
                            ee = ee + 1;
                            parse.splice({
                                data: store,
                                howmany: 0,
                                index: ee,
                                record: {
                                    begin: begin,
                                    ender: parse.count,
                                    lexer: store.lexer[ee - 1],
                                    lines: 0,
                                    stack: stack,
                                    token: delim[0],
                                    types: delim[1]
                                }
                            });
                            ff = ff + 1;
                        }
                        dd = dd + 1;
                    } while (dd < keylen);
                    parse.splice({
                        data: data,
                        howmany: ff,
                        index: cc + 1
                    });
                    parse.linesSpace = lines;
                    parse.concat(data, store);
                    return;
                }
            }
            return;
        },
        // an extension of Array.prototype.pop to work across the data structure
        pop: function parse_pop(data) {
            const output = {
                begin: data.begin.pop(),
                ender: data.ender.pop(),
                lexer: data.lexer.pop(),
                lines: data.lines.pop(),
                stack: data.stack.pop(),
                token: data.token.pop(),
                types: data.types.pop()
            };
            if (data === parse.data) {
                parse.count = parse.count - 1;
            }
            return output;
        },
        // an extension of Array.prototype.push to work across the data structure
        push: function parse_push(data, record, structure) {
            const ender = function parse_push_ender() {
                let a = parse.count;
                const begin = data.begin[a];
                if ((data.lexer[a] === "markup" && sparser.options.lexer_options.markup.tag_sort === true) ||
                    ((data.lexer[a] === "script" || data.lexer[a] === "style") && sparser.options.lexer_options[data.lexer[a]].object_sort === true)) {
                    // sorting can result in a token whose begin value is greater than either
                    // its current index or the index of the end token, which results in an endless loop
                    //
                    // these end values are addressed at the end of the "parser" function with parse.sortCorrection
                    return;
                }
                do {
                    if (data.begin[a] === begin || (data.begin[data.begin[a]] === begin && data.types[a].indexOf("attribute") > -1 && data.types[a].indexOf("attribute_end") < 0)) {
                        data.ender[a] = parse.count;
                    }
                    else {
                        a = data.begin[a];
                    }
                    a = a - 1;
                } while (a > begin);
                if (a > -1) {
                    data.ender[a] = parse.count;
                }
            };
            parse
                .datanames
                .forEach(function parse_push_datanames(value) {
                data[value].push(record[value]);
            });
            if (data === parse.data) {
                parse.count = parse.count + 1;
                parse.linesSpace = 0;
                if (record.lexer !== "style") {
                    if (structure.replace(/(\{|\}|@|<|>|%|#|)/g, "") === "") {
                        if (record.types === "else") {
                            structure = "else";
                        }
                        else {
                            structure = record.token;
                        }
                    }
                    else if ((/^<\?(=|(php))/).test(structure) === false) {
                        structure = structure.replace(/(\{|\}|@|<|>|%|#|)\s*/g, "");
                    }
                }
                if (record.types === "start" || record.types.indexOf("_start") > 0) {
                    parse.structure.push([structure, parse.count]);
                }
                else if (record.types === "end" || record.types.indexOf("_end") > 0) {
                    // this big condition fixes language specific else blocks that are children of start/end blocks not associated with the if/else chain
                    let case_ender = 0;
                    if (parse.structure.length > 2 &&
                        (data.types[parse.structure[parse.structure.length - 1][1]] === "else" || data.types[parse.structure[parse.structure.length - 1][1]].indexOf("_else") > 0) &&
                        (data.types[parse.structure[parse.structure.length - 2][1]] === "start" || data.types[parse.structure[parse.structure.length - 2][1]].indexOf("_start") > 0) &&
                        (data.types[parse.structure[parse.structure.length - 2][1] + 1] === "else" || data.types[parse.structure[parse.structure.length - 2][1] + 1].indexOf("_else") > 0)) {
                        parse.structure.pop();
                        data.begin[parse.count] = parse.structure[parse.structure.length - 1][1];
                        data.stack[parse.count] = parse.structure[parse.structure.length - 1][0];
                        data.ender[parse.count - 1] = parse.count;
                        case_ender = data.ender[data.begin[parse.count] + 1];
                    }
                    ender();
                    if (case_ender > 0) {
                        data.ender[data.begin[parse.count] + 1] = case_ender;
                    }
                    parse.structure.pop();
                }
                else if (record.types === "else" || record.types.indexOf("_else") > 0) {
                    if (structure === "") {
                        structure = "else";
                    }
                    if (parse.count > 0 && (data.types[parse.count - 1] === "start" || data.types[parse.count - 1].indexOf("_start") > 0)) {
                        parse.structure.push([structure, parse.count]);
                    }
                    else {
                        ender();
                        if (structure === "") {
                            parse.structure[parse.structure.length - 1] = ["else", parse.count];
                        }
                        else {
                            parse.structure[parse.structure.length - 1] = [structure, parse.count];
                        }
                    }
                }
            }
        },
        // a custom sort tool that is a bit more intelligent and multidimensional than Array.prototype.sort
        safeSort: function parse_safeSort(array, operation, recursive) {
            let extref = function parse_safeSort_extref(item) {
                //worthless function for backwards compatibility with older versions of V8 node.
                return item;
            };
            const arTest = function parse_safeSort_arTest(item) {
                if (Array.isArray(item) === true) {
                    return true;
                }
                return false;
            }, normal = function parse_safeSort_normal(item) {
                let storeb = item;
                const done = [item[0]], child = function safeSort_normal_child() {
                    let a = 0;
                    const len = storeb.length;
                    if (a < len) {
                        do {
                            if (arTest(storeb[a]) === true) {
                                storeb[a] = parse_safeSort_normal(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                }, recurse = function parse_safeSort_normal_recurse(x) {
                    let a = 0;
                    const storea = [], len = storeb.length;
                    if (a < len) {
                        do {
                            if (storeb[a] !== x) {
                                storea.push(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                    storeb = storea;
                    if (storea.length > 0) {
                        done.push(storea[0]);
                        extref(storea[0]);
                    }
                    else {
                        if (recursive === true) {
                            child();
                        }
                        item = storeb;
                    }
                };
                extref = recurse;
                recurse(array[0]);
                return item;
            }, descend = function parse_safeSort_descend(item) {
                let c = 0;
                const len = item.length, storeb = item, child = function parse_safeSort_descend_child() {
                    let a = 0;
                    const lenc = storeb.length;
                    if (a < lenc) {
                        do {
                            if (arTest(storeb[a]) === true) {
                                storeb[a] = parse_safeSort_descend(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < lenc);
                    }
                }, recurse = function parse_safeSort_descend_recurse(value) {
                    let a = c, b = 0, d = 0, e = 0, ind = [], key = storeb[c], tstore = "";
                    const tkey = typeof key;
                    if (a < len) {
                        do {
                            tstore = typeof storeb[a];
                            if (storeb[a] > key || (tstore > tkey)) {
                                key = storeb[a];
                                ind = [a];
                            }
                            else if (storeb[a] === key) {
                                ind.push(a);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                    d = ind.length;
                    a = c;
                    b = d + c;
                    if (a < b) {
                        do {
                            storeb[ind[e]] = storeb[a];
                            storeb[a] = key;
                            e = e + 1;
                            a = a + 1;
                        } while (a < b);
                    }
                    c = c + d;
                    if (c < len) {
                        extref("");
                    }
                    else {
                        if (recursive === true) {
                            child();
                        }
                        item = storeb;
                    }
                    return value;
                };
                extref = recurse;
                recurse("");
                return item;
            }, ascend = function parse_safeSort_ascend(item) {
                let c = 0;
                const len = item.length, storeb = item, child = function parse_safeSort_ascend_child() {
                    let a = 0;
                    const lenc = storeb.length;
                    if (a < lenc) {
                        do {
                            if (arTest(storeb[a]) === true) {
                                storeb[a] = parse_safeSort_ascend(storeb[a]);
                            }
                            a = a + 1;
                        } while (a < lenc);
                    }
                }, recurse = function parse_safeSort_ascend_recurse(value) {
                    let a = c, b = 0, d = 0, e = 0, ind = [], key = storeb[c], tstore = "";
                    const tkey = typeof key;
                    if (a < len) {
                        do {
                            tstore = typeof storeb[a];
                            if (storeb[a] < key || tstore < tkey) {
                                key = storeb[a];
                                ind = [a];
                            }
                            else if (storeb[a] === key) {
                                ind.push(a);
                            }
                            a = a + 1;
                        } while (a < len);
                    }
                    d = ind.length;
                    a = c;
                    b = d + c;
                    if (a < b) {
                        do {
                            storeb[ind[e]] = storeb[a];
                            storeb[a] = key;
                            e = e + 1;
                            a = a + 1;
                        } while (a < b);
                    }
                    c = c + d;
                    if (c < len) {
                        extref("");
                    }
                    else {
                        if (recursive === true) {
                            child();
                        }
                        item = storeb;
                    }
                    return value;
                };
                extref = recurse;
                recurse("");
                return item;
            };
            if (arTest(array) === false) {
                return array;
            }
            if (operation === "normal") {
                return normal(array);
            }
            if (operation === "descend") {
                return descend(array);
            }
            return ascend(array);
        },
        // this functionality provides corrections to the "begin" and "ender" values after use of object_sort
        sortCorrection: function parse_sortCorrection(start, end) {
            let a = start, endslen = -1;
            const data = parse.data, ends = [], structure = (parse.structure.length < 2)
                ? [-1]
                : [parse.structure[parse.structure.length - 2][1]];
            // this first loop solves for the begin values
            do {
                if (a > 0 &&
                    data.types[a].indexOf("attribute") > -1 &&
                    data.types[a].indexOf("end") < 0 &&
                    data.types[a - 1].indexOf("start") < 0 &&
                    data.types[a - 1].indexOf("attribute") < 0 &&
                    data.lexer[a] === "markup") {
                    structure.push(a - 1);
                }
                if (a > 0 &&
                    data.types[a - 1].indexOf("attribute") > -1 &&
                    data.types[a].indexOf("attribute") < 0 &&
                    data.lexer[structure[structure.length - 1]] === "markup" &&
                    data.types[structure[structure.length - 1]].indexOf("start") < 0) {
                    structure.pop();
                }
                if (data.begin[a] !== structure[structure.length - 1]) {
                    if (structure.length > 0) {
                        data.begin[a] = structure[structure.length - 1];
                    }
                    else {
                        data.begin[a] = -1;
                    }
                }
                if (data.types[a].indexOf("else") > -1) {
                    if (structure.length > 0) {
                        structure[structure.length - 1] = a;
                    }
                    else {
                        structure.push(a);
                    }
                }
                if (data.types[a].indexOf("end") > -1) {
                    structure.pop();
                }
                if (data.types[a].indexOf("start") > -1) {
                    structure.push(a);
                }
                a = a + 1;
            } while (a < end);
            // and now for the ender values
            a = end;
            do {
                a = a - 1;
                if (data.types[a].indexOf("end") > -1) {
                    ends.push(a);
                    endslen = endslen + 1;
                }
                if (endslen > -1) {
                    data.ender[a] = ends[endslen];
                }
                else {
                    data.ender[a] = -1;
                }
                if (data.types[a].indexOf("start") > -1) {
                    ends.pop();
                    endslen = endslen - 1;
                }
            } while (a > start);
        },
        // a simple tool to take note of whitespace between tokens
        spacer: function parse_spacer(args) {
            // * array - the characters to scan
            // * index - the index to start scanning from
            // * end   - the length of the array, to break the loop
            parse.linesSpace = 1;
            do {
                if (args.array[args.index] === "\n") {
                    parse.linesSpace = parse.linesSpace + 1;
                    parse.lineNumber = parse.lineNumber + 1;
                }
                if ((/\s/).test(args.array[args.index + 1]) === false) {
                    break;
                }
                args.index = args.index + 1;
            } while (args.index < args.end);
            return args.index;
        },
        // an extension of Array.prototype.splice to work across the data structure
        splice: function parse_splice(spliceData) {
            const finalItem = [parse.data.begin[parse.count], parse.data.token[parse.count]];
            // * data    - The data object to alter
            // * howmany - How many indexes to remove
            // * index   - The index where to start
            // * record  - A new record to insert
            if (spliceData.record !== undefined && spliceData.record.token !== "") {
                parse
                    .datanames
                    .forEach(function parse_splice_datanames(value) {
                    spliceData
                        .data[value]
                        .splice(spliceData.index, spliceData.howmany, spliceData.record[value]);
                });
                if (spliceData.data === parse.data) {
                    parse.count = (parse.count - spliceData.howmany) + 1;
                    if (finalItem[0] !== parse.data.begin[parse.count] || finalItem[1] !== parse.data.token[parse.count]) {
                        parse.linesSpace = 0;
                    }
                }
                return;
            }
            parse
                .datanames
                .forEach(function parse_splice_datanames(value) {
                spliceData
                    .data[value]
                    .splice(spliceData.index, spliceData.howmany);
            });
            if (spliceData.data === parse.data) {
                parse.count = parse.count - spliceData.howmany;
                parse.linesSpace = 0;
            }
        },
        // parsing block comments and simultaneously applying word wrap
        wrapCommentBlock: function parse_wrapCommentBlock(config) {
            let a = config.start, b = 0, c = 0, d = 0, len = 0, lines = [], space = "", bline = "", spaceLine, emptyLine = false, bulletLine = false, numberLine = false, bigLine = false, output = "", terml = config.terminator.length - 1, term = config.terminator.charAt(terml), twrap = 0;
            const build = [], second = [], lf = (sparser.options.crlf === true)
                ? "\r\n"
                : "\n", sanitize = function parse_wrapCommentBlock_sanitize(input) {
                return `\\${input}`;
            }, regEsc = (/(\/|\\|\||\*|\[|\]|\{|\})/g), regEnd = new RegExp(`\\s*${config.terminator.replace(regEsc, sanitize)}$`), regIgnore = new RegExp(`^(${config.opening.replace(regEsc, sanitize)}\\s*parse-ignore-start)`), regStart = new RegExp(`(${config.opening.replace(regEsc, sanitize)}\\s*)`), wrap = sparser.options.wrap, emptyLines = function parse_wrapCommentBlock_emptyLines() {
                if ((/^\s+$/).test(lines[b + 1]) === true || lines[b + 1] === "") {
                    do {
                        b = b + 1;
                    } while (b < len && ((/^\s+$/).test(lines[b + 1]) === true || lines[b + 1] === ""));
                }
                if (b < len - 1) {
                    second.push("");
                }
            };
            do {
                build.push(config.chars[a]);
                if (config.chars[a] === "\n") {
                    parse.lineNumber = parse.lineNumber + 1;
                }
                if (config.chars[a] === term && config.chars.slice(a - terml, a + 1).join("") === config.terminator) {
                    break;
                }
                a = a + 1;
            } while (a < config.end);
            output = build.join("");
            if (regIgnore.test(output) === true) {
                let termination = "\n";
                a = a + 1;
                do {
                    build.push(config.chars[a]);
                    a = a + 1;
                } while (a < config.end && (config.chars[a - 1] !== "d" || (config.chars[a - 1] === "d" && build.slice(build.length - 16).join("") !== "parse-ignore-end")));
                b = a;
                terml = config.opening.length - 1;
                term = config.opening.charAt(terml);
                do {
                    if (config.opening === "/*" && config.chars[b - 1] === "/" && (config.chars[b] === "*" || config.chars[b] === "/")) {
                        break; // for script
                    }
                    if (config.opening !== "/*" && config.chars[b] === term && config.chars.slice(b - terml, b + 1).join("") === config.opening) {
                        break; // for markup
                    }
                    b = b - 1;
                } while (b > config.start);
                if (config.opening === "/*" && config.chars[b] === "*") {
                    termination = "\u002a/";
                }
                else if (config.opening !== "/*") {
                    termination = config.terminator;
                }
                terml = termination.length - 1;
                term = termination.charAt(terml);
                if (termination !== "\n" || config.chars[a] !== "\n") {
                    do {
                        build.push(config.chars[a]);
                        if (termination === "\n" && config.chars[a + 1] === "\n") {
                            break;
                        }
                        if (config.chars[a] === term && config.chars.slice(a - terml, a + 1).join("") === termination) {
                            break;
                        }
                        a = a + 1;
                    } while (a < config.end);
                }
                if (config.chars[a] === "\n") {
                    a = a - 1;
                }
                output = build.join("").replace(/\s+$/, "");
                return [output, a];
            }
            if (a === config.end || wrap < 1 || (output.length <= wrap && output.indexOf("\n") < 0) || sparser.options.preserve_comment === true || (config.opening === "/*" && output.indexOf("\n") > 0 && output.replace("\n", "").indexOf("\n") > 0 && (/\n(?!(\s*\*))/).test(output) === false)) {
                return [output, a];
            }
            b = config.start;
            if (b > 0 && config.chars[b - 1] !== "\n" && (/\s/).test(config.chars[b - 1]) === true) {
                do {
                    b = b - 1;
                } while (b > 0 && config.chars[b - 1] !== "\n" && (/\s/).test(config.chars[b - 1]) === true);
            }
            space = config.chars.slice(b, config.start).join("");
            spaceLine = new RegExp(`\n${space}`, "g");
            lines = output.replace(/\r\n/g, "\n").replace(spaceLine, "\n").split("\n");
            len = lines.length;
            lines[0] = lines[0].replace(regStart, "");
            lines[len - 1] = lines[len - 1].replace(regEnd, "");
            if (len < 2) {
                lines = lines[0].split(" ");
            }
            if (lines[0] === "") {
                lines[0] = config.opening;
            }
            else {
                lines.splice(0, 0, config.opening);
            }
            len = lines.length;
            b = 0;
            do {
                bline = (b < len - 1)
                    ? lines[b + 1].replace(/^\s+/, "")
                    : "";
                if ((/^\s+$/).test(lines[b]) === true || lines[b] === "") {
                    emptyLines();
                }
                else if (lines[b].slice(0, 4) === "    ") {
                    second.push(lines[b]);
                }
                else if (lines[b].replace(/^\s+/, "").length > wrap && lines[b].replace(/^\s+/, "").indexOf(" ") > wrap) {
                    lines[b] = lines[b].replace(/^\s+/, "");
                    c = lines[b].indexOf(" ");
                    second.push(lines[b].slice(0, c));
                    lines[b] = lines[b].slice(c + 1);
                    b = b - 1;
                }
                else {
                    if (config.opening === "/*" && lines[b].indexOf("/*") !== 0) {
                        lines[b] = `   ${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`;
                    }
                    else {
                        lines[b] = `${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`;
                    }
                    twrap = (b < 1)
                        ? wrap - (config.opening.length + 1)
                        : wrap;
                    c = lines[b].length;
                    d = lines[b].replace(/^\s+/, "").indexOf(" ");
                    if (c > twrap && d > 0 && d < twrap) {
                        c = twrap;
                        do {
                            c = c - 1;
                            if ((/\s/).test(lines[b].charAt(c)) === true && c <= wrap) {
                                break;
                            }
                        } while (c > 0);
                        if (lines[b].slice(0, 4) !== "    " && (/^\s*(\*|-)\s/).test(lines[b]) === true && (/^\s*(\*|-)\s/).test(lines[b + 1]) === false) {
                            lines.splice(b + 1, 0, "* ");
                        }
                        if (lines[b].slice(0, 4) !== "    " && (/^\s*\d+\.\s/).test(lines[b]) === true && (/^\s*\d+\.\s/).test(lines[b + 1]) === false) {
                            lines.splice(b + 1, 0, "1. ");
                        }
                        if (c < 4) {
                            second.push(lines[b]);
                            bigLine = true;
                        }
                        else if (b === len - 1) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bigLine = true;
                            b = b - 1;
                        }
                        else if ((/^\s+$/).test(lines[b + 1]) === true || lines[b + 1] === "") {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            emptyLine = true;
                            b = b - 1;
                        }
                        else if (lines[b + 1].slice(0, 4) !== "    " && (/^\s*(\*|-)\s/).test(lines[b + 1]) === true) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bulletLine = true;
                            b = b - 1;
                        }
                        else if (lines[b + 1].slice(0, 4) !== "    " && (/^\s*\d+\.\s/).test(lines[b + 1]) === true) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            numberLine = true;
                            b = b - 1;
                        }
                        else if (lines[b + 1].slice(0, 4) === "    ") {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bigLine = true;
                            b = b - 1;
                        }
                        else if (c + bline.length > wrap && bline.indexOf(" ") < 0) {
                            second.push(lines[b].slice(0, c));
                            lines[b] = lines[b].slice(c + 1);
                            bigLine = true;
                            b = b - 1;
                        }
                        else if (lines[b].replace(/^\s+/, "").indexOf(" ") < wrap) {
                            if (lines[b].length > wrap) {
                                lines[b + 1] = lines[b].slice(c + 1) + lf + lines[b + 1];
                            }
                            else {
                                lines[b + 1] = `${lines[b].slice(c + 1)} ${lines[b + 1]}`;
                            }
                        }
                        if (emptyLine === false && bulletLine === false && numberLine === false && bigLine === false) {
                            lines[b] = lines[b].slice(0, c);
                        }
                    }
                    else if (lines[b + 1] !== undefined && ((lines[b].length + bline.indexOf(" ") > wrap && bline.indexOf(" ") > 0) || (lines[b].length + bline.length > wrap && bline.indexOf(" ") < 0))) {
                        second.push(lines[b]);
                        b = b + 1;
                    }
                    else if (lines[b + 1] !== undefined && (/^\s+$/).test(lines[b + 1]) === false && lines[b + 1] !== "" && lines[b + 1].slice(0, 4) !== "    " && (/^\s*(\*|-|(\d+\.))\s/).test(lines[b + 1]) === false) {
                        lines[b + 1] = `${lines[b]} ${lines[b + 1]}`;
                        emptyLine = true;
                    }
                    if (bigLine === false && bulletLine === false && numberLine === false) {
                        if (emptyLine === true) {
                            emptyLine = false;
                        }
                        else if ((/^\s*(\*|-|(\d+\.))\s*$/).test(lines[b]) === false) {
                            if (b < len - 1 && lines[b + 1] !== "" && (/^\s+$/).test(lines[b]) === false && lines[b + 1].slice(0, 4) !== "    " && (/^\s*(\*|-|(\d+\.))\s/).test(lines[b + 1]) === false) {
                                lines[b] = `${lines[b]} ${lines[b + 1]}`;
                                lines.splice(b + 1, 1);
                                len = len - 1;
                                b = b - 1;
                            }
                            else {
                                if (config.opening === "/*" && lines[b].indexOf("/*") !== 0) {
                                    second.push(`   ${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`);
                                }
                                else {
                                    second.push(`${lines[b].replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")}`);
                                }
                            }
                        }
                    }
                    bigLine = false;
                    bulletLine = false;
                    numberLine = false;
                }
                b = b + 1;
            } while (b < len);
            if (second.length > 0) {
                if (second[second.length - 1].length > wrap - (config.terminator.length + 1)) {
                    second.push(config.terminator);
                }
                else {
                    second[second.length - 1] = `${second[second.length - 1]} ${config.terminator}`;
                }
                output = second.join(lf);
            }
            else {
                lines[lines.length - 1] = lines[lines.length - 1] + config.terminator;
                output = lines.join(lf);
            }
            return [output, a];
        },
        // parsing line comments and simultaneously applying word wrap
        wrapCommentLine: function parse_wrapCommentLine(config) {
            let a = config.start, b = 0, output = "", build = [];
            const wrap = sparser.options.wrap, recurse = function parse_wrapCommentLine_recurse() {
                let line = "";
                do {
                    b = b + 1;
                    if (config.chars[b + 1] === "\n") {
                        return;
                    }
                } while (b < config.end && (/\s/).test(config.chars[b]) === true);
                if (config.chars[b] + config.chars[b + 1] === "//") {
                    build = [];
                    do {
                        build.push(config.chars[b]);
                        b = b + 1;
                    } while (b < config.end && config.chars[b] !== "\n");
                    line = build.join("");
                    if ((/^\/\/ (\*|-|(\d+\.))/).test(line) === false && line.slice(0, 6) !== "//    " && (/^\/\/\s*$/).test(line) === false) {
                        output = `${output} ${line.replace(/(^\/\/\s*)/, "").replace(/\s+$/, "")}`;
                        a = b - 1;
                        parse_wrapCommentLine_recurse();
                    }
                }
            }, wordWrap = function parse_wrapCommentLine_wordWrap() {
                let c = 0, d = 0;
                const lines = [], record = (parse.count > -1)
                    ? {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: config.lexer,
                        lines: parse.linesSpace,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: parse.data.token[parse.count],
                        types: "comment"
                    }
                    : {
                        begin: -1,
                        ender: -1,
                        lexer: config.lexer,
                        lines: parse.linesSpace,
                        stack: "global",
                        token: "",
                        types: "comment"
                    };
                output = output.replace(/\s+/g, " ").replace(/\s+$/, "");
                d = output.length;
                if (wrap > d) {
                    return;
                }
                do {
                    c = wrap;
                    if (output.charAt(c) !== " ") {
                        do {
                            c = c - 1;
                        } while (c > 0 && output.charAt(c) !== " ");
                        if (c < 3) {
                            c = wrap;
                            do {
                                c = c + 1;
                            } while (c < d - 1 && output.charAt(c) !== " ");
                        }
                    }
                    lines.push(output.slice(0, c));
                    output = `// ${output.slice(c).replace(/^\s+/, "")}`;
                    d = output.length;
                } while (wrap < d);
                c = 0;
                d = lines.length;
                do {
                    record.token = lines[c];
                    parse.push(parse.data, record, "");
                    record.lines = 2;
                    parse.linesSpace = 2;
                    c = c + 1;
                } while (c < d);
            };
            do {
                build.push(config.chars[a]);
                a = a + 1;
            } while (a < config.end && config.chars[a] !== "\n");
            if (a === config.end) {
                // necessary because the wrapping logic expects line termination
                config.chars.push("\n");
            }
            else {
                a = a - 1;
            }
            output = build.join("").replace(/\s+$/, "");
            if ((/^(\/\/\s*parse-ignore\u002dstart)/).test(output) === true) {
                let termination = "\n";
                a = a + 1;
                do {
                    build.push(config.chars[a]);
                    a = a + 1;
                } while (a < config.end && (config.chars[a - 1] !== "d" || (config.chars[a - 1] === "d" && build.slice(build.length - 16).join("") !== "parse-ignore-end")));
                b = a;
                do {
                    b - b - 1;
                } while (b > config.start && config.chars[b - 1] === "/" && (config.chars[b] === "*" || config.chars[b] === "/"));
                if (config.chars[b] === "*") {
                    termination = "\u002a/";
                }
                if (termination !== "\n" || config.chars[a] !== "\n") {
                    do {
                        build.push(config.chars[a]);
                        if (termination === "\n" && config.chars[a + 1] === "\n") {
                            break;
                        }
                        a = a + 1;
                    } while (a < config.end && (termination === "\n" || (termination === "\u002a/" && (config.chars[a - 1] !== "*" || config.chars[a] !== "/"))));
                }
                if (config.chars[a] === "\n") {
                    a = a - 1;
                }
                output = build.join("").replace(/\s+$/, "");
                return [output, a];
            }
            if (output === "//" || output.slice(0, 6) === "//    " || sparser.options.preserve_comment === true) {
                return [output, a];
            }
            output = output.replace(/(\/\/\s*)/, "// ");
            if (wrap < 1 || (a === config.end - 1 && parse.data.begin[parse.count] < 1)) {
                return [output, a];
            }
            b = a + 1;
            recurse();
            wordWrap();
            return [output, a];
        }
    }, sparser = {
        lexers: {},
        libs: {},
        options:{"lexer_options":{"markup":{"attribute_sort":false,"attribute_sort_list":"","parse_space":false,"preserve_text":false,"quote_convert":"none","tag_merge":false,"tag_sort":false,"unformatted":false},"script":{"end_comma":"none","object_sort":false,"quote_convert":"none","variable_list":"none"},"style":{"no_lead_zero":false,"object_sort":false,"quote_convert":"none"}},"correct":false,"crlf":false,"format":"arrays","language":"auto","lexer":"auto","preserve_comment":false,"source":"","wrap":0},
        parse: parse,
        parser: parser,
        parseerror: "",
        version:{date:"18 Aug 2019",number:"1.4.12"}
    },prettydiff=function mode(diffmeta) {
    const pdcomment = function mode_pdcomment() {
        const ops = prettydiff.sparser.options;
        let sindex = options.source.search(/((\/(\*|\/))|<!--*)\s*prettydiff\.com/), dindex = options.diff.search(/((\/(\*|\/))|<!--*)\s*prettydiff\.com/), a = 0, b = 0, keys, def, len;
        // parses the prettydiff settings comment
        //
        // - Source Priorities:
        // * the prettydiff comment is only accepted if it occurs before non-comments (near the top)
        // * options.source is the priority material for reading the comment
        // * the prettydiff comment will be processed from options.diff only if it present there, missing from options.source, and options.mode is diff
        //
        // - Examples:
        //    /*prettydiff.com width:80 preserve:4*/
        //    /* prettydiff.com width:80 preserve:4 */
        //    /*prettydiff.com width=80 preserve=4 */
        //    // prettydiff.com width=80 preserve:4
        //    <!-- prettydiff.com width:80 preserve=4 -->
        //    <!--prettydiff.com width:40 preserve:2-->
        //
        // - Parsing Considerations:
        // * there may be any amount of space at the start or end of the comment
        // * "prettydiff.com" must exist at the start of the comment
        // * comment must exist prior to non-comment tokens (near top of code)
        // * parameters are name value pairs separated by white space
        // * the delimiter separating name and value is either ":" or "=" characters
        if ((sindex > -1 && (sindex === 0 || "\"':".indexOf(options.source.charAt(sindex - 1)) < 0)) || (options.mode === "diff" && dindex > -1 && (dindex === 0 || "\"':".indexOf(options.diff.charAt(dindex - 1)) < 0))) {
            let pdcom = sindex, a = (pdcom > -1)
                ? pdcom
                : dindex, b = 0, quote = "", item = "", lang = "", lex = "", valkey = [], op = [];
            const ops = [], source = (pdcom > -1)
                ? options.source
                : options.diff, len = source.length, comment = (source.charAt(a) === "<")
                ? "<!--"
                : (source.charAt(a + 1) === "/")
                    ? "//"
                    : "/\u002a", esc = function mode_pdcomment_esc() {
                if (source.charAt(a - 1) !== "\\") {
                    return false;
                }
                let x = a;
                do {
                    x = x - 1;
                } while (x > 0 && source.charAt(x) === "\\");
                if ((a - x) % 2 === 0) {
                    return true;
                }
                return false;
            };
            do {
                if (source.slice(a - 3, a) === "com") {
                    break;
                }
                a = a + 1;
            } while (a < len);
            do {
                if (esc() === false) {
                    if (quote === "") {
                        if (source.charAt(a) === "\"") {
                            quote = "\"";
                            if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                b = a;
                            }
                        }
                        else if (source.charAt(a) === "'") {
                            quote = "'";
                            if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                b = a;
                            }
                        }
                        else if (source.charAt(a) === "`") {
                            quote = "`";
                            if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                b = a;
                            }
                        }
                        else if ((/\s/).test(source.charAt(a)) === false && b === 0) {
                            b = a;
                        }
                        else if (source.charAt(a) === "," || ((/\s/).test(source.charAt(a)) === true && b > 0)) {
                            item = source.slice(b, a);
                            if (ops.length > 0) {
                                if (ops.length > 0 && (item === ":" || item === "=") && ops[ops.length - 1].indexOf("=") < 0 && ops[ops.length - 1].indexOf(":") < 0) {
                                    // for cases where white space is between option name and assignment operator
                                    ops[ops.length - 1] = ops[ops.length - 1] + item;
                                    b = a;
                                }
                                else if (ops.length > 0 && (ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === ":" || ops[ops.length - 1].charAt(ops[ops.length - 1].length - 1) === "=")) {
                                    // for cases where white space is between assignment operator and value
                                    ops[ops.length - 1] = ops[ops.length - 1] + item;
                                    b = 0;
                                }
                                else {
                                    ops.push(item);
                                    b = 0;
                                }
                            }
                            else {
                                ops.push(item);
                                b = 0;
                            }
                        }
                        if (comment === "<!--" && source.slice(a - 2, a + 1) === "-->") {
                            break;
                        }
                        if (comment === "//" && source.charAt(a) === "\n") {
                            break;
                        }
                        if (comment === "/\u002a" && source.slice(a - 1, a + 1) === "\u002a/") {
                            break;
                        }
                    }
                    else if (source.charAt(a) === quote && quote !== "${") {
                        quote = "";
                    }
                    else if (quote === "`" && source.slice(a, a + 2) === "${") {
                        quote = "${";
                    }
                    else if (quote === "${" && source.charAt(a) === "}") {
                        quote = "`";
                    }
                }
                a = a + 1;
            } while (a < len);
            if (b > 0) {
                quote = source.slice(b, a + 1);
                if (comment === "<!--") {
                    quote = quote.replace(/\s*-+>$/, "");
                }
                else if (comment === "//") {
                    quote = quote.replace(/\s+$/, "");
                }
                else {
                    quote = quote.replace(/\s*\u002a\/$/, "");
                }
                ops.push(quote);
            }
            a = ops.length;
            if (a > 0) {
                do {
                    a = a - 1;
                    if (ops[a].indexOf("=") > 0 && ops[a].indexOf(":") > 0) {
                        if (ops[a].indexOf("=") < ops[a].indexOf(":")) {
                            op = [ops[a].slice(0, ops[a].indexOf("=")), ops[a].slice(ops[a].indexOf("=") + 1)];
                        }
                    }
                    else if (ops[a].indexOf("=") > 0) {
                        op = [ops[a].slice(0, ops[a].indexOf("=")), ops[a].slice(ops[a].indexOf("=") + 1)];
                    }
                    else if (ops[a].indexOf(":") > 0) {
                        op = [ops[a].slice(0, ops[a].indexOf(":")), ops[a].slice(ops[a].indexOf(":") + 1)];
                    }
                    else if (prettydiff.api.optionDef[ops[a]] !== undefined && prettydiff.api.optionDef[ops[a]].type === "boolean") {
                        options[ops[a]] = true;
                    }
                    if (op.length === 2 && prettydiff.api.optionDef[op[0]] !== undefined) {
                        if ((op[1].charAt(0) === "\"" || op[1].charAt(0) === "'" || op[1].charAt(0) === "`") && op[1].charAt(op[1].length - 1) === op[1].charAt(0)) {
                            op[1] = op[1].slice(1, op[1].length - 1);
                        }
                        if (prettydiff.api.optionDef[op[0]].type === "number" && isNaN(Number(op[1])) === false) {
                            options[op[0]] = Number(op[1]);
                        }
                        else if (prettydiff.api.optionDef[op[0]].type === "boolean") {
                            if (op[1] === "true") {
                                options[op[0]] = true;
                            }
                            else if (op[1] === "false") {
                                options[op[0]] = false;
                            }
                        }
                        else {
                            if (prettydiff.api.optionDef[op[0]].values !== undefined) {
                                valkey = Object.keys(prettydiff.api.optionDef[op[0]].values);
                                b = valkey.length;
                                do {
                                    b = b - 1;
                                    if (valkey[b] === op[1]) {
                                        options[op[0]] = op[1];
                                        break;
                                    }
                                } while (b > 0);
                            }
                            else {
                                if (op[0] === "language") {
                                    lang = op[1];
                                }
                                else if (op[0] === "lexer") {
                                    lex = op[1];
                                }
                                options[op[0]] = op[1];
                            }
                        }
                    }
                } while (a > 0);
                if (lex === "" && lang !== "") {
                    lex = prettydiff.api.language.setlexer(lang);
                }
            }
        }
        if (options.mode === "diff") {
            modeValue = "beautify";
        }
        if (options.mode === "minify" && options.minify_wrap === false) {
            options.wrap = -1;
        }
        if (options.lexer === "script") {
            let styleguide = {
                airbnb: function mode_pdcomment_styleairbnb() {
                    options.brace_padding = true;
                    options.correct = true;
                    options.lexerOptions.script.end_comma = "always";
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.variable_list = "each";
                    options.wrap = 80;
                },
                crockford: function mode_pdcomment_stylecrockford() {
                    options.brace_padding = false;
                    options.correct = true;
                    options.else_line = false;
                    options.lexerOptions.script.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 4;
                    options.no_case_indent = true;
                    options.space = true;
                    options.variable_list = "each";
                    options.vertical = false;
                },
                google: function mode_pdcomment_stylegoogle() {
                    options.correct = true;
                    options.indent_char = " ";
                    options.indent_size = 4;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.vertical = false;
                    options.wrap = -1;
                },
                jquery: function mode_pdcomment_stylejquery() {
                    options.brace_padding = true;
                    options.correct = true;
                    options.indent_char = "\u0009";
                    options.indent_size = 1;
                    options.quote_convert = "double";
                    options.variable_list = "each";
                    options.wrap = 80;
                },
                jslint: function mode_pdcomment_stylejslint() {
                    options.brace_padding = false;
                    options.correct = true;
                    options.else_line = false;
                    options.lexerOptions.script.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 4;
                    options.no_case_indent = true;
                    options.space = true;
                    options.variable_list = "each";
                    options.vertical = false;
                },
                mrdoobs: function mode_pdcomment_stylemrdoobs() {
                    options.brace_line = true;
                    options.brace_padding = true;
                    options.correct = true;
                    options.indent_char = "\u0009";
                    options.indent_size = 1;
                    options.vertical = false;
                },
                mediawiki: function mode_pdcomment_stylemediawiki() {
                    options.brace_padding = true;
                    options.correct = true;
                    options.indent_char = "\u0009";
                    options.indent_size = 1;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.space = false;
                    options.wrap = 80;
                },
                meteor: function mode_pdcomment_stylemeteor() {
                    options.correct = true;
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.wrap = 80;
                },
                semistandard: function mode_pdcomment_stylessemistandard() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = false;
                    options.correct = true;
                    options.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.new_line = false;
                    options.no_semicolon = false;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.space = true;
                    options.ternary_line = false;
                    options.variable_list = "each";
                    options.vertical = false;
                    options.wrap = 0;
                },
                standard: function mode_pdcomment_stylestandard() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = false;
                    options.correct = true;
                    options.end_comma = "never";
                    options.indent_char = " ";
                    options.indent_size = 2;
                    options.new_line = false;
                    options.no_semicolon = true;
                    options.preserve = 1;
                    options.quote_convert = "single";
                    options.space = true;
                    options.ternary_line = false;
                    options.variable_list = "each";
                    options.vertical = false;
                    options.wrap = 0;
                },
                yandex: function mode_pdcomment_styleyandex() {
                    options.brace_padding = false;
                    options.correct = true;
                    options.quote_convert = "single";
                    options.variable_list = "each";
                    options.vertical = false;
                }
            }, brace_style = {
                collapse: function mode_pdcomment_collapse() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = false;
                    options.format_object = "indent";
                    options.never_flatten = true;
                },
                "collapse-preserve-inline": function mode_pdcomment_collapseInline() {
                    options.brace_line = false;
                    options.brace_padding = true;
                    options.braces = false;
                    options.format_object = "inline";
                    options.never_flatten = false;
                },
                expand: function mode_pdcomment_expand() {
                    options.brace_line = false;
                    options.brace_padding = false;
                    options.braces = true;
                    options.format_object = "indent";
                    options.never_flatten = true;
                }
            };
            if (styleguide[options.styleguide] !== undefined) {
                styleguide[options.styleguide]();
            }
            if (brace_style[options.brace_style] !== undefined) {
                brace_style[options.brace_style]();
            }
            if (options.language === "json") {
                options.wrap = 0;
            }
            else if (options.language === "titanium") {
                options.correct = false;
            }
            if (options.language !== "javascript" && options.language !== "typescript" && options.language !== "jsx") {
                options.jsscope = "none";
            }
        }
        if (options.lexer !== "markup" || options.language === "text") {
            options.diff_rendered_html = false;
        }
        else if (options.api === "node" && options.read_method !== "file") {
            options.diff_rendered_html = false;
        }
        def = prettydiff.sparser.libs.optionDef;
        keys = Object.keys(def);
        len = keys.length;
        do {
            if (options[keys[a]] !== undefined) {
                if (def[keys[a]].lexer[0] === "all") {
                    ops[keys[a]] = options[keys[a]];
                }
                else {
                    b = def[keys[a]].lexer.length;
                    do {
                        b = b - 1;
                        if (keys[a] !== "parse_space" || (options.mode === "parse" && keys[a] === "parse_space" && options[keys[a]] === true)) {
                            ops.lexer_options[def[keys[a]].lexer[b]][keys[a]] = options[keys[a]];
                        }
                    } while (b > 0);
                }
            }
            a = a + 1;
        } while (a < len);
    }, options = prettydiff.options, lf = (options.crlf === true)
        ? "\r\n"
        : "\n";
    let modeValue = options.mode, result = "";
    if (options.api === "node" && (options.read_method === "directory" || options.read_method === "subdirectory")) {
        if (options.mode === "parse" && options.parse_format === "table") {
            return "Error: option parse_format with value 'table' is not available with read_method directory or subdirectory.";
        }
    }
    if (options.language === "text" && options.mode !== "diff") {
        options.language = "auto";
    }
    if (options.lexer === "text" && options.mode !== "diff") {
        options.lexer = "auto";
    }
    if (options.language === "text" || options.lexer === "text") {
        options.language = "text";
        options.language_name = "Plain Text";
        options.lexer = "text";
    }
    else if (options.language === "auto" || options.lexer === "auto") {
        const def = (options.language_default === "" || options.language_default === null || options.language_default === undefined)
            ? "javascript"
            : options.language_default;
        let lang = prettydiff.api.language.auto(options.source, def);
        if (lang[0] === "text") {
            if (options.mode === "diff") {
                lang[2] = "Plain Text";
            }
            else {
                lang = ["javascript", "script", "JavaScript"];
            }
        }
        else if (lang[0] === "csv") {
            lang[2] = "CSV";
        }
        if (options.language === "auto") {
            options.language = lang[0];
            options.language_name = lang[2];
        }
        if (options.lexer === "auto") {
            options.lexer = lang[1];
        }
    }
    pdcomment();
    if (options.mode === "parse") {
        const parse_format = (options.parse_format === "htmltable")
            ? "table"
            : options.parse_format, api = (options.parse_format === "htmltable")
            ? "dom"
            : options.api;
        options.parsed = prettydiff.sparser.parser();
        if (parse_format === "table") {
            if (api === "dom") {
                const parsLen = options.parsed.token.length, keys = Object.keys(options.parsed), keylen = keys.length, headingString = (function mode_parseHeading() {
                    const hout = ["<tr><th>index</th>"];
                    let b = 0;
                    do {
                        if (keys[b] !== "token") {
                            hout.push(`<th>${keys[b]}</th>`);
                        }
                        b = b + 1;
                    } while (b < keylen);
                    hout.push("<th>token</th></tr>");
                    return hout.join("");
                }()), row = function mode_parseRow() {
                    const hout = ["<tr>"];
                    let b = 0;
                    hout.push(`<td>${a}</td>`);
                    do {
                        if (keys[b] !== "token") {
                            hout.push(`<td>${options.parsed[keys[b]][a].toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</td>`);
                        }
                        b = b + 1;
                    } while (b < keylen);
                    hout.push(`<td>${options.parsed.token[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}</td></tr>`);
                    return hout.join("");
                }, parsOut = [];
                parsOut.push(`<p><strong>${parsLen}</strong> total parsed tokens</p>`);
                parsOut.push("<table><thead>");
                parsOut.push(headingString);
                parsOut.push("</thead><tbody>");
                let a = 0;
                do {
                    if (a % 100 === 0 && a > 0) {
                        parsOut.push(headingString);
                    }
                    parsOut.push(row());
                    a = a + 1;
                } while (a < parsLen);
                parsOut.push("</tbody></table>");
                result = parsOut.join("");
            }
            else {
                let a = 0, str = [];
                const outputArrays = options.parsed, nodeText = {
                    angry: "\u001b[1m\u001b[31m",
                    blue: "\u001b[34m",
                    bold: "\u001b[1m",
                    cyan: "\u001b[36m",
                    green: "\u001b[32m",
                    nocolor: "\u001b[39m",
                    none: "\u001b[0m",
                    purple: "\u001b[35m",
                    red: "\u001b[31m",
                    underline: "\u001b[4m",
                    yellow: "\u001b[33m"
                }, output = [], b = outputArrays.token.length, pad = function mode_parsePad(x, y) {
                    const cc = x
                        .toString()
                        .replace(/\s/g, " ");
                    let dd = y - cc.length;
                    str.push(cc);
                    if (dd > 0) {
                        do {
                            str.push(" ");
                            dd = dd - 1;
                        } while (dd > 0);
                    }
                    str.push(" | ");
                }, heading = "index | begin | ender | lexer  | lines | stack       | types       | token", bar = "------|-------|-------|--------|-------|-------------|-------------|------";
                output.push("");
                output.push(heading);
                output.push(bar);
                do {
                    if (a % 100 === 0 && a > 0) {
                        output.push("");
                        output.push(heading);
                        output.push(bar);
                    }
                    str = [];
                    if (outputArrays.lexer[a] === "markup") {
                        str.push(nodeText.red);
                    }
                    else if (outputArrays.lexer[a] === "script") {
                        str.push(nodeText.green);
                    }
                    else if (outputArrays.lexer[a] === "style") {
                        str.push(nodeText.yellow);
                    }
                    pad(a.toString(), 5);
                    pad(outputArrays.begin[a].toString(), 5);
                    pad(outputArrays.ender[a].toString(), 5);
                    pad(outputArrays.lexer[a].toString(), 5);
                    pad(outputArrays.lines[a].toString(), 5);
                    pad(outputArrays.stack[a].toString(), 11);
                    pad(outputArrays.types[a].toString(), 11);
                    str.push(outputArrays.token[a].replace(/\s/g, " "));
                    str.push(nodeText.none);
                    output.push(str.join(""));
                    a = a + 1;
                } while (a < b);
                result = output.join(lf);
            }
        }
        else {
            result = JSON.stringify(options.parsed);
        }
    }
    else {
        if (prettydiff[modeValue][options.lexer] === undefined && ((options.mode !== "diff" && options.language === "text") || options.language !== "text")) {
            result = `Error: Library prettydiff.${modeValue}.${options.lexer} does not exist.`;
        }
        else if (options.mode === "diff") {
            let diffoutput;
            if (options.diff_format === "json") {
                options.complete_document = false;
            }
            if (options.language === "text") {
                diffoutput = prettydiff.api.diffview(options);
                result = diffoutput[0];
            }
            else {
                const ind = options.indent;
                if (options.diff_rendered_html === true) {
                    const lexers = {
                        del: 0,
                        insert: 0,
                        replace: 0
                    }, typeIgnore = [
                        "attribute",
                        "cdata",
                        "comment",
                        "conditional",
                        "ignore",
                        "jsx_attribute_end",
                        "jsx_attribute_start",
                        "script",
                        "sgml",
                        "style",
                        "xml"
                    ], tab = function mode_diffhtmlTab(indentation) {
                        const tabout = (options.crlf === true)
                            ? ["\r\n"]
                            : ["\n"];
                        let a = 0, b = options.indent_size * indentation;
                        if (b > 1) {
                            do {
                                tabout.push(options.indent_char);
                                a = a + 1;
                            } while (a < b);
                        }
                        else {
                            tabout.push(options.indent_char);
                            tabout.push(options.indent_char);
                        }
                        return tabout.join("");
                    }, css = [
                        `${tab(2)}<style type="text/css">`,
                        "#prettydiff_summary{background:#eef8ff;border:2px solid #069}",
                        ".prettydiff_rendered{border-style:solid;border-width:2px;display:inline-block}",
                        ".prettydiff_delete{background:#ffd8d8;border-color:#c44}",
                        ".prettydiff_insert{background:#d8ffd8;border-color:#090}",
                        ".prettydiff_replace{background:#fec;border-color:#a86}"
                    ], insert = function mode_insert() {
                        const inject = [`<span class="prettydiff_rendered prettydiff_insert">`];
                        if (json[a + 1][0] === "+") {
                            do {
                                inject.push(json[a][1]);
                                count[1] = count[1] + 1;
                                a = a + 1;
                            } while (json[a + 1][0] === "+");
                        }
                        inject.push(json[a][1]);
                        inject.push("</span>");
                        options.parsed.token[count[0]] = `${inject.join("")} ${options.parsed.token[count[0]]}`;
                        lexers.insert = lexers.insert + 1;
                    }, del = function mode_del() {
                        const symb = json[a][0], change = (symb === "-")
                            ? "delete"
                            : "replace";
                        options.parsed.token[count[0]] = `<span class="prettydiff_rendered prettydiff_${change}">${options.parsed.token[count[0]]}`;
                        if (json[a + 1][0] === symb) {
                            do {
                                count[0] = count[0] + 1;
                                if (change === "replace") {
                                    count[1] = count[1] + 1;
                                }
                                a = a + 1;
                            } while (json[a + 1][0] === symb);
                        }
                        options.parsed.token[count[0]] = `${options.parsed.token[count[0]]}</span>`;
                        if (change === "delete") {
                            lexers.del = lexers.del + 1;
                        }
                        else {
                            lexers.replace = lexers.replace + 1;
                        }
                    }, summary = function mode_summary() {
                        const keys = Object.keys(lexers), len = keys.length, output = [], lex = [];
                        let a = 0, lextest = false;
                        output.push(`<div id="prettydiff_summary"><h1>Pretty Diff - Summary</h1>`);
                        output.push("<p>This is the count of identified differences starting with visual differences colored in the document first.</p><ul>");
                        output.push(`<li>Deletions - <strong>${lexers.del}</strong></li>`);
                        output.push(`<li>Insertions - <strong>${lexers.insert}</strong></li>`);
                        output.push(`<li>Replacements - <strong>${lexers.replace}</strong></li>`);
                        output.push("</ul>");
                        if (len > 3) {
                            lexers.del = 0;
                            lexers.insert = 0;
                            lexers.replace = 0;
                            lex.push("<hr/><p>This list of differences is not visible in the rendered HTML.</p><ul>");
                            do {
                                if (lexers[keys[a]] > 0) {
                                    lextest = true;
                                    lex.push(`<li>${keys[a]} - ${lexers[keys[a]]}</li>`);
                                }
                                a = a + 1;
                            } while (a < len);
                            lex.push("</ul>");
                        }
                        if (lextest === true) {
                            output.push(lex.join(""));
                        }
                        output.push("</div>");
                        options.parsed.token[body] = `${options.parsed.token[body]} ${output.join("")}`;
                    };
                    let diff_parsed, json, a = 0, count = [0, 0], len = 0, body = 0, head = false;
                    options.diff_format = "json";
                    options.parsed = prettydiff.sparser.parser();
                    options.source = options.parsed.token;
                    prettydiff.start = 0;
                    prettydiff.end = 0;
                    options.indent_level = ind;
                    prettydiff.sparser.options.source = options.diff;
                    diff_parsed = prettydiff.sparser.parser();
                    options.diff = diff_parsed.token;
                    diffoutput = prettydiff.api.diffview(options);
                    json = JSON.parse(diffoutput[0]).diff;
                    len = json.length;
                    do {
                        if (head === false && options.parsed.types[count[0]] === "start" && options.parsed.lexer[count[0]] === "markup" && json[a][1].toLowerCase().indexOf("<head") === 0) {
                            options.parsed.token[count[0]] = `${options.parsed.token[count[0]] + css.join(tab(3)) + tab(2)}</style>${tab(0)}`;
                            head = true;
                        }
                        else if (body < 1 && options.parsed.types[count[0]] === "start" && options.parsed.lexer[count[0]] === "markup" && options.parsed.token[count[0]].toLowerCase().indexOf("<body") === 0) {
                            body = count[0];
                        }
                        if (json[a][0] === "=") {
                            count[0] = count[0] + 1;
                            count[1] = count[1] + 1;
                        }
                        else if (body > 1 &&
                            options.parsed.lexer[count[0]] === "markup" &&
                            options.parsed.token[count[0]].indexOf(`<span class="prettydiff_`) !== 0 &&
                            ((json[a][0] === "+" && typeIgnore.indexOf(diff_parsed.types[count[1]]) < 0) || (json[a][0] !== "+" && typeIgnore.indexOf(options.parsed.types[count[0]]) < 0))) {
                            if (json[a][0] === "+") {
                                insert();
                            }
                            else {
                                del();
                            }
                        }
                        else {
                            if (json[a][0] === "-") {
                                count[0] = count[0] + 1;
                            }
                            else if (json[a][0] === "+") {
                                count[1] = count[1] + 1;
                            }
                            else {
                                count[0] = count[0] + 1;
                                count[1] = count[1] + 1;
                            }
                            if (lexers[options.parsed.lexer[count[0]]] === undefined) {
                                lexers[options.parsed.lexer[count[0]]] = 1;
                            }
                            else {
                                lexers[options.parsed.lexer[count[0]]] = lexers[options.parsed.lexer[count[0]]] + 1;
                            }
                        }
                        a = a + 1;
                    } while (a < len);
                    summary();
                    result = prettydiff.beautify.markup(options);
                }
                else {
                    options.parsed = prettydiff.sparser.parser();
                    options.source = prettydiff.beautify[options.lexer](options);
                    prettydiff.start = 0;
                    prettydiff.end = 0;
                    options.indent_level = ind;
                    // diff text formatting
                    prettydiff.sparser.options.source = options.diff;
                    options.parsed = prettydiff.sparser.parser();
                    options.diff = prettydiff.beautify[options.lexer](options);
                    // comparison
                    diffoutput = prettydiff.api.diffview(options);
                    result = diffoutput[0];
                }
            }
            if (diffmeta !== undefined) {
                diffmeta.differences = diffoutput[1];
                diffmeta.lines = diffoutput[2];
            }
        }
        else {
            options.parsed = prettydiff.sparser.parser();
            result = prettydiff[modeValue][options.lexer](options);
        }
    }
    if (options.new_line === true) {
        result = result.replace(/\s*$/, lf);
    }
    else {
        result = result.replace(/\s+$/, "");
    }
    if (options.complete_document === true && options.jsscope !== "report") {
        let finalFile = prettydiff.api.finalFile;
        finalFile.order[7] = options.color;
        finalFile.order[10] = result;
        if (options.crlf === true) {
            finalFile.order[12] = "\r\n";
            finalFile.order[15] = "\r\n";
        }
        if (options.mode === "diff") {
            finalFile.order[13] = finalFile.script.diff;
        }
        else if (options.mode === "beautify" && options.language === "javascript" && options.jsscope !== "none") {
            finalFile.order[13] = finalFile.script.beautify;
        }
        else {
            finalFile.order[13] = finalFile.script.minimal;
        }
        // escape changes characters that result in xml wellformedness errors
        prettydiff.end = 0;
        prettydiff.start = 0;
        return finalFile.order.join("");
    }
    prettydiff.end = 0;
    prettydiff.start = 0;
    return result;
};prettydiff.api={};prettydiff.beautify={};prettydiff.end=0;prettydiff.iterator=0;prettydiff.meta={error:"",lang:["","",""],time:"",insize:0,outsize:0,difftotal:0,difflines:0};prettydiff.minify={};prettydiff.options={"attribute_sort":false,"attribute_sort_list":"","brace_line":false,"brace_padding":false,"brace_style":"none","braces":false,"case_space":false,"color":"white","comment_line":false,"comments":false,"complete_document":false,"compressed_css":false,"conditional":false,"config":"","content":false,"correct":false,"crlf":false,"css_insert_lines":false,"diff":"","diff_comments":false,"diff_context":-1,"diff_format":"text","diff_label":"New Sample","diff_rendered_html":false,"diff_space_ignore":false,"diff_view":"sidebyside","else_line":false,"end_comma":"never","end_quietly":"default","force_attribute":false,"force_indent":false,"format_array":"default","format_object":"default","function_name":false,"help":80,"indent_char":" ","indent_level":0,"indent_size":4,"jsscope":"none","language":"auto","language_default":"text","language_name":"JavaScript","lexer":"auto","list_options":false,"method_chain":3,"minify_keep_comments":false,"minify_wrap":false,"mode":"diff","never_flatten":false,"new_line":false,"no_case_indent":false,"no_lead_zero":false,"no_semicolon":false,"node_error":false,"object_sort":false,"output":"","parse_format":"parallel","parse_space":false,"preserve":0,"preserve_comment":false,"preserve_text":false,"quote":false,"quote_convert":"none","read_method":"auto","selector_list":false,"semicolon":false,"source":"","source_label":"Source Sample","space":true,"space_close":false,"styleguide":"none","summary_only":false,"tag_merge":false,"tag_sort":false,"ternary_line":false,"top_comments":false,"unformatted":false,"variable_list":"none","version":false,"vertical":false,"wrap":0,"lexerOptions":{}};prettydiff.scopes=[];prettydiff.start=0;
    (function options_init() {
    
    const optionDef = {
        attribute_sort: {
            default: false,
            definition: "Alphanumerically sort markup attributes. Sorting is ignored if a given tag contains an attribute with instructions for a different language such as a template scheme, child markup tag, or start of a code structure.",
            label: "Sort Attributes",
            lexer: ["markup"],
            type: "boolean"
        },
        attribute_sort_list: {
            default: "",
            definition: "A comma separated list of attribute names. Attributes will be sorted according to this list and then alphanumerically. This option requires 'attribute_sort' have a value of true.",
            label: "Sort Attribute List",
            lexer: ["markup"],
            type: "string"
        },
        correct: {
            default: false,
            definition: "Automatically correct sloppiness in code. If false missing syntax will be included starting with 'x', such as 'x;' for missing simicolons.",
            label: "Correct",
            lexer: ["all"],
            type: "boolean"
        },
        crlf: {
            default: false,
            definition: "If line termination should be crlf (Windows) otherwise line termination is lf (Unix).",
            label: "CRLF",
            lexer: ["all"],
            type: "boolean"
        },
        end_comma: {
            default: "none",
            definition: "Whether terminal commas in objects and arrays should be added or eliminated.",
            label: "End Comma",
            lexer: ["script"],
            type: "string",
            values: {
                "always": "Adds terminal commas if they are missing.",
                "never": "Removes terminal commas if they are present.",
                "none": "Ignores this option."
            }
        },
        format: {
            default: "arrays",
            definition: "Defines the output format of the parser.",
            label: "Output Format",
            lexer: ["all"],
            type: "string",
            values: {
                "arrays": "The output format is an object of arrays such that the same index of all the arrays represents one data record, for example: {begin:[],ender:[],lexer:[],lines[],stack:[],token:[],types:[]}.",
                "csv": "The output format is comma separated value format.",
                "markdown": "Generates the output in a markdown table.",
                "minimal": "The output format is an array of arrays which is structurally similar to the objects format but without key names, for example: [[-1,-1,\"script\",0,\"global\",\"const\",\"word\"]].",
                "objects": "The output format is an array of objects such that each array index is one data record, for example: [{begin:-1,ender:-1,lexer:\"script\",lines:0,stack:\"global\",token:\"const\",types:\"word\"}]."
            }
        },
        language: {
            default: "auto",
            definition: "The language to parse.  The value auto will result in language auto detection.",
            label: "Language",
            lexer: ["all"],
            type: "string"
        },
        lexer: {
            default: "auto",
            definition: "The lexer used to perform the parsing.  The value auto will result in language auto detection.",
            label: "Lexer",
            lexer: ["all"],
            type: "string"
        },
        no_lead_zero: {
            default: false,
            definition: "Whether the zero to the left of the decimal point should be removed from numbers between 0 and 1.",
            label: "No Lead Zero",
            lexer: ["style"],
            type: "boolean"
        },
        object_sort: {
            default: false,
            definition: "Where style properties should be sorted by type and then alphabetically and whether script object properties should be sorted alphabetically.",
            label: "Object Sort",
            lexer: ["script", "style"],
            type: "boolean"
        },
        parse_space: {
            default: false,
            definition: "Whether white space should be parsed as content tokens.",
            label: "Parse Markup White Space",
            lexer: ["markup"],
            type: "boolean"
        },
        preserve_comment: {
            default: false,
            definition: "Whether comments should be ignored from manipulation, such as word wrap.",
            label: "Preserve Comment",
            lexer: ["all"],
            type: "boolean"
        },
        preserve_text: {
            default: false,
            definition: "Whether text content should be preserved from manipulation, such as word wrap.",
            label: "Preserve Text",
            lexer: ["markup"],
            type: "boolean"
        },
        quote_convert: {
            default: "none",
            definition: "If quote characters should be converted from single quotes to double quotes or the opposite. This option does take into account escaped quote characters.",
            label: "Quote Convert",
            lexer: ["markup", "script", "style"],
            type: "string",
            values: {
                "double": "Converts single quote characters to double quote characters.",
                "none": "Ignores this option.",
                "single": "Converts double quote characters to single quote characters."
            }
        },
        source: {
            default: "",
            definition: "The source code to parse.",
            label: "Source",
            lexer: ["all"],
            type: "string"
        },
        tag_merge: {
            default: false,
            definition: "If adjacent start and end tags in markup should be merged into one singleton tag.",
            label: "Tag Merge",
            lexer: ["markup"],
            type: "boolean"
        },
        tag_sort: {
            default: false,
            definition: "Whether markup tags should be alphabetically sorted amonst their siblings.",
            label: "Tag Sort",
            lexer: ["markup"],
            type: "boolean"
        },
        unformatted: {
            default: false,
            definition: "If tags in markup code should be preserved from any manner of alteration.",
            label: "Tag Unformatted",
            lexer: ["markup"],
            type: "boolean"
        },
        variable_list: {
            default: "none",
            definition: "Whether consecutive variable declarations should be separate statements or a comma separated list. Use of this option respects the different types of declarations: var, const, let.",
            label: "Variable List",
            lexer: ["script"],
            type: "string",
            values: {
                "each": "Separates variable declarations into separate statements.",
                "list": "Combines consecutive variable declaration statements into a single comma separated list.",
                "none": "Ignores this option."
            }
        },
        wrap: {
            default: 0,
            definition: "The character distance in which to apply word wrap. A value of less than 1 eliminates word wrap.",
            label: "Wrap",
            lexer: ["all"],
            type: "number"
        }
    };
    sparser.libs.optionDef = optionDef;
}());
(function language_init() {
    
    const language = {
        setlexer: function language_setlexer(input) {
            const langmap = {
                c_cpp: "script",
                coldfusion: "markup",
                csharp: "script",
                css: "style",
                csv: "csv",
                dustjs: "markup",
                ejs: "markup",
                go: "markup",
                handlebars: "markup",
                html: "markup",
                html_ruby: "markup",
                java: "script",
                javascript: "script",
                json: "script",
                jsp: "markup",
                jsx: "script",
                less: "style",
                markdown: "markdown",
                markup: "markup",
                php: "script",
                phphtml: "markup",
                qml: "style",
                scss: "style",
                silverstripe: "markup",
                "styled-jsx": "script",
                "styled-components": "script",
                swig: "markup",
                text: "text",
                titanium: "script",
                tss: "script",
                twig: "markup",
                typescript: "script",
                vapor: "markup",
                velocity: "markup",
                xhtml: "markup",
                xml: "markup"
            };
            if (typeof input !== "string") {
                return "script";
            }
            if (input.indexOf("html") > -1) {
                return "markup";
            }
            if (langmap[input] === undefined) {
                return "script";
            }
            return langmap[input];
        },
        nameproper: function language_nameproper(input) {
            const langmap = {
                c_cpp: "C++ (Not yet supported)",
                coldfusion: "ColdFusion",
                csharp: "C#",
                dustjs: "Dust.js",
                ejs: "EJS Template",
                elm: "Elm Template",
                go: "Go Lang Template",
                handlebars: "Handlebars Template",
                html_ruby: "ERB (Ruby) Template",
                java: "Java",
                javascript: "JavaScript",
                jsp: "JSTL (JSP)",
                jsx: "React JSX",
                liquid: "Liquid Template",
                markdown: "markdown",
                markup: "markup",
                phphtml: "HTML/PHP",
                scss: "SCSS",
                silverstripe: "SilverStripe",
                text: "Plain Text",
                titanium: "Titanium Stylesheets",
                tss: "Titanium Stylesheets",
                twig: "HTML TWIG Template",
                typescript: "TypeScript",
                vapor: "Vapor Leaf",
                velocity: "Apache Velocity",
                volt: "Volt Template"
            };
            if (typeof input !== "string" || langmap[input] === undefined) {
                return input.toUpperCase();
            }
            return langmap[input];
        },
        // * [0] = language value
        // * [1] = lexer value
        // * [2] = pretty formatting for text output to user
        auto: function language_auto(sample, defaultLang) {
            let b = [], c = 0;
            const vartest = ((/(((var)|(let)|(const)|(function)|(import))\s+(\w|\$)+[a-zA-Z0-9]*)/).test(sample) === true && (/@import/).test(sample) === false), finalstatic = (/((((final)|(public)|(private))\s+static)|(static\s+void))/).test(sample), output = function language_auto_output(langname) {
                if (langname === "unknown") {
                    return [defaultLang, language.setlexer(defaultLang), "unknown"];
                }
                if (langname === "xhtml" || langname === "markup") {
                    return ["xml", language.setlexer("xml"), "XHTML"];
                }
                if (langname === "tss") {
                    return ["tss", language.setlexer("tss"), "Titanium Stylesheets"];
                }
                if (langname === "phphtml") {
                    return ["php", language.setlexer(langname), language.nameproper(langname)];
                }
                return [langname, language.setlexer(langname), language.nameproper(langname)];
            }, cssA = function language_auto_cssA() {
                if ((/\n\s*#+\s+/).test(sample) === true || (/^#+\s+/).test(sample) === true) {
                    return output("markdown");
                }
                if ((/\$[a-zA-Z]/).test(sample) === true || (/\{\s*(\w|\.|\$|#)+\s*\{/).test(sample) === true) {
                    return output("scss");
                }
                if ((/@[a-zA-Z]/).test(sample) === true || (/\{\s*(\w|\.|@|#)+\s*\{/).test(sample) === true) {
                    return output("less");
                }
                return output("css");
            }, notmarkup = function language_auto_notmarkup() {
                let d = 1, join = "", flaga = false, flagb = false;
                const publicprivate = (/((public)|(private))\s+(static\s+)?(((v|V)oid)|(class)|(final))/).test(sample), javascriptA = function language_auto_notmarkup_javascriptA() {
                    if (sample.indexOf("(") > -1 || sample.indexOf("=") > -1 || (sample.indexOf(";") > -1 && sample.indexOf("{") > -1)) {
                        if (vartest === false && ((/\n\s+#region\s/).test(sample) === true || (/\[\w+:/).test(sample) === true)) {
                            return output("csharp");
                        }
                        if (finalstatic === true || (/\w<\w+(,\s+\w+)*>/).test(sample) === true) {
                            if ((/:\s*((number)|(string))/).test(sample) === false && (finalstatic === true || publicprivate === true)) {
                                return output("java");
                            }
                            return output("typescript");
                        }
                        if ((/final\s+static/).test(sample) === true) {
                            return output("java");
                        }
                        if ((/<\/\w+>/).test(sample) === true && (/<\w+((\s+\w)|>)/).test(sample) === true) {
                            return output("jsx");
                        }
                        if ((/((var)|(let)|(const))\s+\w+\s*:/).test(sample) === true || (/=\s*<\w+/).test(sample) === true) {
                            return output("typescript");
                        }
                        return output("javascript");
                    }
                    return output("unknown");
                }, cssOrJavaScript = function language_auto_notmarkup_cssOrJavaScript() {
                    if ((/:\s*((number)|(string))/).test(sample) === true && (/((public)|(private))\s+/).test(sample) === true) {
                        return output("typescript");
                    }
                    if ((/import\s+java(\.|(fx))/).test(sample) === true || (/((public)|(private))\s+static\s+/).test(sample) === true) {
                        return output("java");
                    }
                    if ((/\sclass\s+\w/).test(sample) === false && (/<[a-zA-Z]/).test(sample) === true && (/<\/[a-zA-Z]/).test(sample) === true && ((/\s?\{%/).test(sample) === true || (/\{(\{|#)(?!(\{|#|=))/).test(sample) === true)) {
                        return output("twig");
                    }
                    if ((/^(\s*(\$|@))/).test(sample) === false && (/(\};?\s*)$/).test(sample) === true) {
                        if ((/export\s+default\s+\{/).test(sample) === true || (/(\?|:)\s*(\{|\[)/).test(sample) === true || (/(\{|\s|;)render\s*\(\)\s*\{/).test(sample) === true || (/^(\s*return;?\s*\{)/).test(sample) === true) {
                            return output("javascript");
                        }
                    }
                    if ((/\{\{#/).test(sample) === true && (/\{\{\//).test(sample) === true && (/<\w/).test(sample) === true) {
                        return output("handlebars");
                    }
                    if ((/\{\s*(\w|\.|@|#)+\s*\{/).test(sample) === true) {
                        return output("less");
                    }
                    if ((/\$(\w|-)/).test(sample) === true) {
                        return output("scss");
                    }
                    if ((/(;|\{|:)\s*@\w/).test(sample) === true) {
                        return output("less");
                    }
                    if ((/class\s+\w+\s+\{/).test(sample) === true) {
                        return output("java");
                    }
                    return output("css");
                };
                if (d < c) {
                    do {
                        if (flaga === false) {
                            if (b[d] === "*" && b[d - 1] === "/") {
                                b[d - 1] = "";
                                flaga = true;
                            }
                            else if (flagb === false && b[d] === "f" && d < c - 6 && b[d + 1] === "i" && b[d + 2] === "l" && b[d + 3] === "t" && b[d + 4] === "e" && b[d + 5] === "r" && b[d + 6] === ":") {
                                flagb = true;
                            }
                        }
                        else if (flaga === true && b[d] === "*" && d !== c - 1 && b[d + 1] === "/") {
                            flaga = false;
                            b[d] = "";
                            b[d + 1] = "";
                        }
                        else if (flagb === true && b[d] === ";") {
                            flagb = false;
                            b[d] = "";
                        }
                        if (flaga === true || flagb === true) {
                            b[d] = "";
                        }
                        d = d + 1;
                    } while (d < c);
                }
                join = b.join("");
                if ((/\s\/\//).test(sample) === false && (/\/\/\s/).test(sample) === false && (/^(\s*(\{|\[)(?!%))/).test(sample) === true && (/((\]|\})\s*)$/).test(sample) && sample.indexOf(",") !== -1) {
                    return output("json");
                }
                if ((/((\}?(\(\))?\)*;?\s*)|([a-z0-9]("|')?\)*);?(\s*\})*)$/i).test(sample) === true && (vartest === true || publicprivate === true || (/console\.log\(/).test(sample) === true || (/export\s+default\s+class\s+/).test(sample) === true || (/document\.get/).test(sample) === true || (/((=|(\$\())\s*function)|(\s*function\s+(\w*\s+)?\()/).test(sample) === true || sample.indexOf("{") === -1 || (/^(\s*if\s+\()/).test(sample) === true)) {
                    return javascriptA();
                }
                // * u007b === {
                // * u0024 === $
                // * u002e === .
                if (sample.indexOf("{") > -1 && ((/^(\s*[\u007b\u0024\u002e#@a-z0-9])/i).test(sample) === true || (/^(\s*\/(\*|\/))/).test(sample) === true || (/^(\s*\*\s*\{)/).test(sample) === true) && (/^(\s*if\s*\()/).test(sample) === false && (/=\s*(\{|\[|\()/).test(join) === false && (((/(\+|-|=|\?)=/).test(join) === false || (/\/\/\s*=+/).test(join) === true) || ((/=+('|")?\)/).test(sample) === true && (/;\s*base64/).test(sample) === true)) && (/function(\s+\w+)*\s*\(/).test(join) === false) {
                    if ((/\s*#((include)|(define)|(endif))\s+/).test(sample)) {
                        return output("c_cpp");
                    }
                    return cssOrJavaScript();
                }
                if ((/"\s*:\s*\{/).test(sample) === true) {
                    return output("tss");
                }
                if (sample.indexOf("{%") > -1) {
                    return output("twig");
                }
                return output("unknown");
            }, markup = function language_auto_markup() {
                const html = function language_auto_markup_html() {
                    if ((/<%\s*\}/).test(sample) === true) {
                        return output("ejs");
                    }
                    if ((/<%\s+end_((if)|(with)|(loop)|(control)|(cached)|(uncached))/).test(sample) === true) {
                        return output("silverstripe");
                    }
                    if ((/<%\s*end/).test(sample) === true) {
                        return output("html_ruby");
                    }
                    if ((/\{\{(#|\/|\{)/).test(sample) === true) {
                        return output("handlebars");
                    }
                    if ((/\{\{end\}\}/).test(sample) === true) {
                        //place holder for Go lang templates
                        return output("html");
                    }
                    if ((/\s?\{%/).test(sample) === true && (/\{(\{|#)(?!(\{|#|=))/).test(sample) === true) {
                        return output("twig");
                    }
                    if ((/<\?/).test(sample) === true) {
                        if ((/^\s*<\?/).test(sample) === true && (/\?>\s*$/).test(sample) === true) {
                            return output("php");
                        }
                        return output("phphtml");
                    }
                    if ((/<jsp:include\s/).test(sample) === true || (/<c:((set)|(if))\s/).test(sample) === true) {
                        return output("jsp");
                    }
                    if ((/\{(#|\?|\^|@|<|\+|~)/).test(sample) === true && (/\{\//).test(sample) === true && sample.indexOf("<![CDATA[") < 0) {
                        return output("dustjs");
                    }
                    if ((/#((if)|(for)|(set))?\(/).test(sample) === true) {
                        return output("vapor");
                    }
                    return output("html");
                };
                if ((/<cfset\s/i).test(sample) === true || (/<cfif\s/i).test(sample) === true) {
                    return output("coldfusion");
                }
                if ((/^(\s*<!doctype\s+html>)/i).test(sample) === true ||
                    (/^(\s*<html)/i).test(sample) === true ||
                    ((/<form\s/i).test(sample) === true &&
                        (/<label\s/i).test(sample) === true &&
                        (/<input\s/i).test(sample) === true) ||
                    (/<((img)|(IMG))(\s+\w+=("|')?\S+("|')?)*\s+src\s*=/).test(sample) === true ||
                    ((/^(\s*<!DOCTYPE\s+((html)|(HTML))\s+PUBLIC\s+)/).test(sample) === true &&
                        (/XHTML\s+1\.1/).test(sample) === false &&
                        (/XHTML\s+1\.0\s+(S|s)((trict)|(TRICT))/).test(sample) === false)) {
                    return html();
                }
                if ((/<jsp:include\s/).test(sample) === true || (/<c:((set)|(if))\s/).test(sample) === true) {
                    return output("jsp");
                }
                if ((/<%\s*\}/).test(sample) === true) {
                    return output("ejs");
                }
                if ((/<%\s+end_((if)|(with)|(loop)|(control)|(cached)|(uncached))/).test(sample) === true) {
                    return output("silverstripe");
                }
                if ((/<%\s*end/).test(sample) === true) {
                    return output("html_ruby");
                }
                if ((/\{\{(#|\/|\{)/).test(sample) === true) {
                    return output("handlebars");
                }
                if ((/\{\{end\}\}/).test(sample) === true) {
                    //place holder for Go lang templates
                    return output("xml");
                }
                if ((/\s?\{%/).test(sample) === true && (/\{\{(?!(\{|#|=))/).test(sample) === true) {
                    return output("twig");
                }
                if ((/<\?(?!(xml))/).test(sample) === true) {
                    if ((/^\s*<\?/).test(sample) === true && (/\?>\s*$/).test(sample) === true) {
                        return output("php");
                    }
                    return output("phphtml");
                }
                if ((/\{(#|\?|\^|@|<|\+|~)/).test(sample) === true && (/\{\//).test(sample) === true) {
                    return output("dustjs");
                }
                if ((/<jsp:include\s/).test(sample) === true || (/<c:((set)|(if))\s/).test(sample) === true) {
                    return output("jsp");
                }
                if ((/#((if)|(for)|(set))?\(/).test(sample) === true) {
                    return output("vapor");
                }
                return output("xml");
            };
            if (sample === null || sample.replace(/\s+/g, "") === "") {
                return output("unknown");
            }
            if (((/\n\s*#{1,6}\s+/).test(sample) === true || ((/\n\s*(\*|-|(\d+\.))\s/).test(sample) === true) && (/\/\*/).test(sample) === false) &&
                ((/\[( |x|X)\]/).test(sample) === true || (/\s\*\*?\S\D/).test(sample) === true || (/\n\s*```/).test(sample) === true || ((/-+\|(-+\|)+/).test(sample) === true && (/<!--/).test(sample) === false))) {
                return output("markdown");
            }
            if ((/^(\s*<!DOCTYPE\s+html>)/i).test(sample) === true) {
                return markup();
            }
            if ((/^\s*@((charset)|(import)|(include)|(keyframes)|(media)|(namespace)|(page))/).test(sample) === true) {
                return cssA();
            }
            if (finalstatic === false &&
                (/=(>|=|-|\+|\*)/).test(sample) === false &&
                (/^(\s*((if)|(for)|(function))\s*\()/).test(sample) === false &&
                (/(\s|;|\})((if)|(for)|(function\s*\w*))\s*\(/).test(sample) === false &&
                vartest === false && (/return\s*\w*\s*(;|\})/).test(sample) === false &&
                (sample === undefined ||
                    (/^(\s*#(?!(!\/)))/).test(sample) === true ||
                    ((/\n\s*(\.|@)\w+(\(|(\s*:))/).test(sample) === true && (/>\s*<\w/).test(sample) === false))) {
                return cssA();
            }
            b = sample
                .replace(/\[[a-zA-Z][\w-]*=("|')?[a-zA-Z][\w-]*("|')?\]/g, "")
                .split("");
            c = b.length;
            if ((/^(\s*(\{|<)(%|#|\{))/).test(sample) === true) {
                return markup();
            }
            if (((/^([\s\w-]*<)/).test(sample) === false && (/(>[\s\w-]*)$/).test(sample) === false) || finalstatic === true) {
                return notmarkup();
            }
            if ((((/(>[\w\s:]*)?<(\/|!|#)?[\w\s:\-[]+/).test(sample) === true || ((/^\s*</).test(sample) === true && (/<\/\w+(\w|\d)+>\s*$/).test(sample) === true) || (/^(\s*<\?xml)/).test(sample) === true) && ((/^([\s\w]*<)/).test(sample) === true || (/(>[\s\w]*)$/).test(sample) === true)) || ((/^(\s*<s((cript)|(tyle)))/i).test(sample) === true && (/(<\/s((cript)|(tyle))>\s*)$/i).test(sample) === true)) {
                if ((/^([\s\w]*<)/).test(sample) === false || (/(>[\s\w]*)$/).test(sample) === false) {
                    return notmarkup();
                }
                return markup();
            }
            return output("unknown");
        }
    };sparser.libs.language=language;prettydiff.api.language=language;
}());
(function style_init() {
    
    const style = function lexer_style(source) {
        let a = 0, ltype = "", ltoke = "";
        const parse = sparser.parse, data = parse.data, options = sparser.options, colors = [], colorNames = {
            aliceblue: 0.9288006825347457,
            antiquewhite: 0.8464695170775405,
            aqua: 0.7874,
            aquamarine: 0.8078549208338043,
            azure: 0.9726526495416643,
            beige: 0.8988459998705021,
            bisque: 0.8073232737297876,
            black: 0,
            blanchedalmond: 0.8508443960815607,
            blue: 0.0722,
            blueviolet: 0.12622014321946043,
            brown: 0.09822428787651079,
            burlywood: 0.5155984453389335,
            cadetblue: 0.29424681085422044,
            chartreuse: 0.7603202590262282,
            chocolate: 0.23898526114557292,
            coral: 0.3701793087292368,
            cornflowerblue: 0.30318641994179363,
            cornsilk: 0.9356211037296492,
            crimson: 0.16042199953025577,
            cyan: 0.7874,
            darkblue: 0.018640801980939217,
            darkcyan: 0.2032931783904645,
            darkgoldenrod: 0.27264703559992554,
            darkgray: 0.39675523072562674,
            darkgreen: 0.09114342904757505,
            darkgrey: 0.39675523072562674,
            darkkhaki: 0.45747326349994155,
            darkmagenta: 0.07353047651207048,
            darkolivegreen: 0.12651920884889156,
            darkorange: 0.40016167026523863,
            darkorchid: 0.1341314217485677,
            darkred: 0.05488967453113126,
            darksalmon: 0.4054147156338075,
            darkseagreen: 0.43789249325969054,
            darkslateblue: 0.06579284622798763,
            darkslategray: 0.06760815192804355,
            darkslategrey: 0.06760815192804355,
            darkturquoise: 0.4874606277449034,
            darkviolet: 0.10999048339343433,
            deeppink: 0.2386689582827583,
            deepskyblue: 0.444816033955754,
            dimgray: 0.14126329114027164,
            dimgrey: 0.14126329114027164,
            dodgerblue: 0.2744253699145608,
            firebrick: 0.10724525535015225,
            floralwhite: 0.9592248482500424,
            forestgreen: 0.18920812076002244,
            fuchsia: 0.2848,
            gainsboro: 0.7156935005064806,
            ghostwhite: 0.9431126188632283,
            gold: 0.6986087742815887,
            goldenrod: 0.41919977809568404,
            gray: 0.21586050011389915,
            green: 0.15438342968146068,
            greenyellow: 0.8060947261145331,
            grey: 0.21586050011389915,
            honeydew: 0.9633653555478173,
            hotpink: 0.3465843816971475,
            indianred: 0.21406134963884,
            indigo: 0.031075614863369846,
            ivory: 0.9907127060061531,
            khaki: 0.7701234339412052,
            lavendar: 0.8031875051452125,
            lavendarblush: 0.9017274863104644,
            lawngreen: 0.7390589312496334,
            lemonchiffon: 0.9403899224562171,
            lightblue: 0.6370914128080659,
            lightcoral: 0.35522120733134843,
            lightcyan: 0.9458729349482863,
            lightgoldenrodyellow: 0.9334835101829635,
            lightgray: 0.651405637419824,
            lightgreen: 0.6909197995686475,
            lightgrey: 0.651405637419824,
            lightpink: 0.5856615273489745,
            lightsalmon: 0.47806752252059587,
            lightseagreen: 0.3505014511704197,
            lightskyblue: 0.5619563761833096,
            lightslategray: 0.23830165007286924,
            lightslategrey: 0.23830165007286924,
            lightyellow: 0.9816181839288161,
            lime: 0.7152,
            limegreen: 0.44571042246097864,
            linen: 0.8835734098437936,
            magenta: 0.2848,
            maroon: 0.04589194232421496,
            mediumaquamarine: 0.4938970331080111,
            mediumblue: 0.04407778021232784,
            mediumorchid: 0.21639251153773428,
            mediumpurple: 0.22905858091648004,
            mediumseagreen: 0.34393112338131226,
            mediumslateblue: 0.20284629471622434,
            mediumspringgreen: 0.7070430819418444,
            mediumturquois: 0.5133827926447991,
            mediumvioletred: 0.14371899849357186,
            midnightblue: 0.020717866350860484,
            mintcream: 0.9783460494758793,
            mistyrose: 0.8218304785918541,
            moccasin: 0.8008300099156694,
            navajowhite: 0.7651968234278562,
            navy: 0.015585128108223519,
            oldlace: 0.9190063340554899,
            olive: 0.20027537200567563,
            olivedrab: 0.2259315095192918,
            orange: 0.48170267036309605,
            orangered: 0.2551624375341641,
            orchid: 0.3134880676143873,
            palegoldenrod: 0.7879264788761452,
            palegreen: 0.7793675900635259,
            paleturquoise: 0.764360779217138,
            palevioletred: 0.2875499411788909,
            papayawhip: 0.8779710019983541,
            peachpuff: 0.7490558987825108,
            peru: 0.3011307487793569,
            pink: 0.6327107070246611,
            plum: 0.4573422158796909,
            powderblue: 0.6825458650060524,
            purple: 0.061477070432438476,
            red: 0.2126,
            rosyblue: 0.3231945764940708,
            royalblue: 0.16663210743188323,
            saddlebrown: 0.09792228502052071,
            salmon: 0.3697724152759545,
            sandybrown: 0.46628543696283414,
            seagreen: 0.1973419970627483,
            seashell: 0.927378622069223,
            sienna: 0.13697631337097677,
            silver: 0.527115125705813,
            skyblue: 0.5529166851818412,
            slateblue: 0.14784278062136097,
            slategray: 0.20896704076536138,
            slategrey: 0.20896704076536138,
            slightsteelblue: 0.5398388828466575,
            snow: 0.9653334183484877,
            springgreen: 0.7305230606852947,
            steelblue: 0.20562642207624846,
            tan: 0.48237604163921527,
            teal: 0.1699685577896842,
            thistle: 0.5681840109373312,
            tomato: 0.3063861271941505,
            turquoise: 0.5895536427577983,
            violet: 0.40315452986676303,
            wheat: 0.7490970282048214,
            white: 1,
            whitesmoke: 0.913098651793419,
            yellow: 0.9278,
            yellowgreen: 0.5076295720870697
        }, b = source.split(""), len = source.length, mapper = [], nosort = [], recordPush = function lexer_style_recordPush(structure) {
            const record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "style",
                lines: parse.linesSpace,
                stack: parse.structure[parse.structure.length - 1][0],
                token: ltoke,
                types: ltype
            };
            parse.push(data, record, structure);
        }, esctest = function lexer_style_esctest(index) {
            const slashy = index;
            do {
                index = index - 1;
            } while (b[index] === "\\" && index > 0);
            if ((slashy - index) % 2 === 1) {
                return true;
            }
            return false;
        }, 
        // Since I am already identifying value types this is a good place to do some
        // quick analysis and clean up on certain value conditions. These things are
        // being corrected:
        // * fractional values missing a leading 0 are    provided a leading 0
        // * 0 values with a dimension indicator    (px, em) have the dimension
        // indicator    removed
        // * eliminate unnecessary leading 0s
        // * url values that are not quoted are wrapped    in double quote characters
        // * color values are set to lowercase and    reduced from 6 to 3 digits if
        // appropriate
        value = function lexer_style_value(val) {
            const x = val.replace(/\s*!important/, " !important").split(""), values = [], transition = (/-?transition$/).test(data.token[parse.count - 2]), colorPush = function lexer_style_value_colorPush(value) {
                const vl = value.toLowerCase();
                if ((/^(#[0-9a-f]{3,6})$/).test(vl) === true) {
                    colors.push(value);
                }
                else if ((/^(rgba?\()/).test(vl) === true) {
                    colors.push(value);
                }
                else if (colorNames[vl] !== undefined) {
                    colors.push(value);
                }
                return value;
            }, valueSpace = function lexer_style_value_valueSpace(find) {
                find = find.replace(/\s*/g, "");
                if ((/\/\d/).test(find) === true && val.indexOf("url(") === 0) {
                    return find;
                }
                return ` ${find.charAt(0)} ${find.charAt(1)}`;
            }, zerofix = function lexer_style_value_zerofix(find) {
                if (options.lexer_options.style.no_lead_zero === true) {
                    const scrub = function lexer_style_value_zerofix_scrub(search) {
                        return search.replace(/0+/, "");
                    };
                    return find.replace(/^-?\D0+(\.|\d)/, scrub);
                }
                if ((/0*\./).test(find) === true) {
                    return find.replace(/0*\./, "0.");
                }
                if ((/0+/).test((/\d+/).exec(find)[0]) === true) {
                    if ((/^\D*0+\D*$/).test(find) === true) {
                        return find.replace(/0+/, "0");
                    }
                    return find.replace((/\d+/).exec(find)[0], (/\d+/).exec(find)[0].replace(/^0+/, ""));
                }
                return find;
            }, commaspace = function lexer_style_value_commaspace(find) {
                return find.replace(",", ", ");
            }, diFix = function lexer_style_value_diFix(di) {
                return `${di} `;
            }, slash = function lexer_style_value_slash() {
                const start = cc - 1;
                let xx = start;
                if (start < 1) {
                    return true;
                }
                do {
                    xx = xx - 1;
                } while (xx > 0 && x[xx] === "\\");
                // report true for odd numbers (escaped)
                if ((start - xx) % 2 === 1) {
                    return true;
                }
                return false;
            }, zerodotstart = (/^-?0+\.\d+[a-z]/), dotstart = (/^-?\.\d+[a-z]/), zerodot = (/(\s|\(|,)-?0+\.?\d+([a-z]|\)|,|\s)/g), dot = (/(\s|\(|,)-?\.?\d+([a-z]|\)|,|\s)/g), dimensions = "%|cap|ch|cm|deg|dpcm|dpi|dppx|em|ex|fr|grad|Hz|ic|in|kHz|lh|mm|ms|mS|pc|pt|px|Q|rad|rem|rlh|s|turn|vb|vh|vi|vmax|vmin|vw";
            let cc = 0, dd = 0, block = "", leng = x.length, items = [];
            // this loop identifies containment so that tokens/sub-tokens are correctly
            // taken
            if (cc < leng) {
                do {
                    items.push(x[cc]);
                    if (x[cc - 1] !== "\\" || slash() === false) {
                        if (block === "") {
                            if (x[cc] === "\"") {
                                block = "\"";
                                dd = dd + 1;
                            }
                            else if (x[cc] === "'") {
                                block = "'";
                                dd = dd + 1;
                            }
                            else if (x[cc] === "(") {
                                block = ")";
                                dd = dd + 1;
                            }
                            else if (x[cc] === "[") {
                                block = "]";
                                dd = dd + 1;
                            }
                        }
                        else if ((x[cc] === "(" && block === ")") || (x[cc] === "[" && block === "]")) {
                            dd = dd + 1;
                        }
                        else if (x[cc] === block) {
                            dd = dd - 1;
                            if (dd === 0) {
                                block = "";
                            }
                        }
                    }
                    if (block === "" && x[cc] === " ") {
                        items.pop();
                        values.push(colorPush(items.join("")));
                        items = [];
                    }
                    cc = cc + 1;
                } while (cc < leng);
            }
            values.push(colorPush(items.join("")));
            leng = values.length;
            //This is where the rules mentioned above are applied
            cc = 0;
            if (cc < leng) {
                do {
                    if (options.lexer_options.style.no_lead_zero === true && zerodotstart.test(values[cc]) === true) {
                        values[cc] = values[cc].replace(/0+\./, ".");
                    }
                    else if ((options.lexer_options.style.no_lead_zero === false || options.lexer_options.style.no_lead_zero === undefined) && dotstart.test(values[cc]) === true) {
                        values[cc] = values[cc].replace(".", "0.");
                    }
                    else if (zerodot.test(values[cc]) === true || dot.test(values[cc]) === true) {
                        values[cc] = values[cc].replace(zerodot, zerofix).replace(dot, zerofix);
                    }
                    else if ((/^(0+([a-z]{2,3}|%))$/).test(values[cc]) === true && transition === false) {
                        values[cc] = "0";
                    }
                    else if ((/^(0+)/).test(values[cc]) === true) {
                        values[cc] = values[cc].replace(/0+/, "0");
                        if ((/\d/).test(values[cc].charAt(1)) === true) {
                            values[cc] = values[cc].substr(1);
                        }
                    }
                    else if ((/^url\((?!('|"))/).test(values[cc]) === true && values[cc].charAt(values[cc].length - 1) === ")") {
                        block = values[cc].charAt(values[cc].indexOf("url(") + 4);
                        if (block !== "@" && block !== "{" && block !== "<") {
                            if (options.lexer_options.style.quote_convert === "double") {
                                values[cc] = values[cc]
                                    .replace(/url\(/, "url(\"")
                                    .replace(/\)$/, "\")");
                            }
                            else {
                                values[cc] = values[cc]
                                    .replace(/url\(/, "url('")
                                    .replace(/\)$/, "')");
                            }
                        }
                    }
                    if ((/^(\+|-)?\d+(\.\d+)?(e-?\d+)?\D+$/).test(values[cc]) === true) {
                        if (dimensions.indexOf(values[cc].replace(/(\+|-)?\d+(\.\d+)?(e-?\d+)?/, "")) < 0) {
                            values[cc] = values[cc].replace(/(\+|-)?\d+(\.\d+)?(e-?\d+)?/, diFix);
                        }
                    }
                    if ((/^\w+\(/).test(values[cc]) === true &&
                        values[cc].charAt(values[cc].length - 1) === ")" &&
                        (values[cc].indexOf("url(") !== 0 || (values[cc].indexOf("url(") === 0 && values[cc].indexOf(" ") > 0))) {
                        values[cc] = values[cc].replace(/,\S/g, commaspace);
                    }
                    cc = cc + 1;
                } while (cc < leng);
            }
            block = values.join(" ");
            return block.charAt(0) + block.slice(1)
                .replace(/\s*(\/|\+|\*)\s*(\d|\$)/, valueSpace);
        }, 
        //the generic token builder
        buildtoken = function lexer_style_build() {
            let aa = a, bb = 0, out = [], outy = "", funk = null, mappy = 0;
            const block = [], qc = (options.lexer_options.style.quote_convert === undefined)
                ? "none"
                : options.lexer_options.style.quote_convert, spacestart = function lexer_style_build_spacestart() {
                out.push(b[aa]);
                if ((/\s/).test(b[aa + 1]) === true) {
                    do {
                        aa = aa + 1;
                    } while (aa < len && (/\s/).test(b[aa + 1]) === true);
                }
            };
            if (aa < len) {
                //this loop accounts for grouping mechanisms
                do {
                    if (b[aa] === "\"" || b[aa] === "'") {
                        if (funk === null) {
                            funk = false;
                        }
                        if (block[block.length - 1] === b[aa] && (b[aa - 1] !== "\\" || esctest(aa - 1) === false)) {
                            block.pop();
                            if (qc === "double") {
                                b[aa] = "\"";
                            }
                            else if (qc === "single") {
                                b[aa] = "'";
                            }
                        }
                        else if (block[block.length - 1] !== "\"" && block[block.length - 1] !== "'" && (b[aa - 1] !== "\\" || esctest(aa - 1) === false)) {
                            block.push(b[aa]);
                            if (qc === "double") {
                                b[aa] = "\"";
                            }
                            else if (qc === "single") {
                                b[aa] = "'";
                            }
                        }
                        else if (b[aa - 1] === "\\" && qc !== "none") {
                            if (esctest(aa - 1) === true) {
                                if (qc === "double" && b[aa] === "'") {
                                    out.pop();
                                }
                                else if (qc === "single" && b[aa] === "\"") {
                                    out.pop();
                                }
                            }
                        }
                        else if (qc === "double" && b[aa] === "\"") {
                            b[aa] = "\\\"";
                        }
                        else if (qc === "single" && b[aa] === "'") {
                            b[aa] = "\\'";
                        }
                        out.push(b[aa]);
                    }
                    else if (b[aa - 1] !== "\\" || esctest(aa - 1) === false) {
                        if (b[aa] === "(") {
                            if (funk === null) {
                                funk = true;
                            }
                            mappy = mappy + 1;
                            block.push(")");
                            spacestart();
                        }
                        else if (b[aa] === "[") {
                            funk = false;
                            block.push("]");
                            spacestart();
                        }
                        else if ((b[aa] === "#" || b[aa] === "@") && b[aa + 1] === "{") {
                            funk = false;
                            out.push(b[aa]);
                            aa = aa + 1;
                            block.push("}");
                            spacestart();
                        }
                        else if (b[aa] === block[block.length - 1]) {
                            out.push(b[aa]);
                            block.pop();
                        }
                        else {
                            out.push(b[aa]);
                        }
                    }
                    else {
                        out.push(b[aa]);
                    }
                    if (parse.structure[parse.structure.length - 1][0] === "map" && block.length === 0 && (b[aa + 1] === "," || b[aa + 1] === ")")) {
                        if (b[aa + 1] === ")" && data.token[parse.count] === "(") {
                            parse.pop(data);
                            parse.structure.pop();
                            out.splice(0, 0, "(");
                        }
                        else {
                            break;
                        }
                    }
                    if (b[aa + 1] === ":") {
                        bb = aa;
                        if ((/\s/).test(b[bb]) === true) {
                            do {
                                bb = bb - 1;
                            } while ((/\s/).test(b[bb]) === true);
                        }
                        outy = b
                            .slice(bb - 6, bb + 1)
                            .join("");
                        if (outy.indexOf("filter") === outy.length - 6 || outy.indexOf("progid") === outy.length - 6) {
                            outy = "filter";
                        }
                    }
                    if (block.length === 0) {
                        if ((b[aa + 1] === ";" && esctest(aa + 1) === true) ||
                            (b[aa + 1] === ":" &&
                                b[aa] !== ":" &&
                                b[aa + 2] !== ":" &&
                                outy !== "filter" &&
                                outy !== "progid") ||
                            b[aa + 1] === "}" ||
                            b[aa + 1] === "{" ||
                            (b[aa + 1] === "/" && (b[aa + 2] === "*" || b[aa + 2] === "/"))) {
                            bb = out.length - 1;
                            if ((/\s/).test(out[bb]) === true) {
                                do {
                                    bb = bb - 1;
                                    aa = aa - 1;
                                    out.pop();
                                } while ((/\s/).test(out[bb]) === true);
                            }
                            break;
                        }
                        if (b[aa + 1] === ",") {
                            break;
                        }
                    }
                    aa = aa + 1;
                } while (aa < len);
            }
            a = aa;
            if (parse.structure[parse.structure.length - 1][0] === "map" && out[0] === "(") {
                mapper[mapper.length - 1] = mapper[mapper.length - 1] - 1;
            }
            ltoke = out
                .join("")
                .replace(/\s+/g, " ")
                .replace(/^\s/, "")
                .replace(/\s$/, "");
            if (funk === true) {
                ltoke = ltoke.replace(/\s+\(/g, "(").replace(/\s+\)/g, ")").replace(/,\(/g, ", (");
            }
            if (parse.count > -1 && data.token[parse.count].indexOf("extend(") === 0) {
                ltype = "pseudo";
            }
            else if (funk === true &&
                (/\d/).test(ltoke.charAt(0)) === false &&
                (/^rgba?\(/).test(ltoke) === false &&
                ltoke.indexOf("url(") !== 0 &&
                (ltoke.indexOf(" ") < 0 || ltoke.indexOf(" ") > ltoke.indexOf("(")) &&
                ltoke.charAt(ltoke.length - 1) === ")") {
                if (data.token[parse.count] === ":") {
                    ltype = "value";
                }
                else {
                    ltoke = ltoke.replace(/,\u0020?/g, ", ");
                    ltype = "function";
                }
                ltoke = value(ltoke);
            }
            else if (parse.count > -1 && "\"'".indexOf(data.token[parse.count].charAt(0)) > -1 && data.types[parse.count] === "variable") {
                ltype = "item";
            }
            else if (out[0] === "@" || out[0] === "$") {
                if (data.types[parse.count] === "colon" && options.language === "css" && (data.types[parse.count - 1] === "property" || data.types[parse.count - 1] === "variable")) {
                    ltype = "value";
                }
                else if (parse.count > -1) {
                    ltype = "item";
                    outy = data.token[parse.count];
                    aa = outy.indexOf("(");
                    if (outy.charAt(outy.length - 1) === ")" && aa > 0) {
                        outy = outy.slice(aa + 1, outy.length - 1);
                        data.token[parse.count] = data
                            .token[parse.count]
                            .slice(0, aa + 1) + value(outy) + ")";
                    }
                }
                ltoke = value(ltoke);
            }
            else {
                ltype = "item";
            }
            recordPush("");
        }, 
        // Some tokens receive a generic type named 'item' because their type is unknown
        // until we know the following syntax.  This function replaces the type 'item'
        // with something more specific.
        item = function lexer_style_item(type) {
            let aa = parse.count, bb = 0, first = "";
            const comsa = [], priors = function lexer_style_item_priors() {
                //backtrack through immediately prior comments to find the correct token
                if (data.types[aa] === "comment" || data.types[aa] === "ignore") {
                    do {
                        aa = aa - 1;
                        comsa.push(data.token[aa]);
                    } while (aa > 0 && data.lexer[aa] === "style" && (data.types[aa] === "comment" || data.types[aa] === "ignore"));
                }
                bb = aa - 1;
                if (data.types[bb] === "comment" || data.types[bb] === "ignore") {
                    do {
                        bb = bb - 1;
                    } while (bb > 0 && data.lexer[aa] === "style" && (data.types[bb] === "comment" || data.types[bb] === "ignore"));
                }
                first = data.token[aa].charAt(0);
            }, selectorPretty = function lexer_style_item_selectorPretty(index) {
                let cc = index, dd = data.begin[cc];
                data.token[index] = data.token[index]
                    .replace(/\s*&/, " &")
                    .replace(/(\s*>\s*)/g, " > ")
                    .replace(/:\s+/g, ": ")
                    .replace(/^(\s+)/, "")
                    .replace(/(\s+)$/, "")
                    .replace(/\s+::\s+/, "::");
                if (data.token[cc - 1] === "," || data.token[cc - 1] === ":" || data.types[cc - 1] === "comment") {
                    do {
                        cc = cc - 1;
                        if (data.begin[cc] === dd) {
                            if (data.token[cc] === ";") {
                                break;
                            }
                            if (data.token[cc] !== "," && data.types[cc] !== "comment") {
                                data.types[cc] = "selector";
                            }
                            if (data.token[cc] === ":") {
                                data.token[cc - 1] = `${data.token[cc - 1]}:${data.token[cc + 1]}`;
                                parse.splice({
                                    data: data,
                                    howmany: 2,
                                    index: cc
                                });
                            }
                        }
                        else {
                            break;
                        }
                    } while (cc > 0);
                }
                // sorts comma separated lists of selectors
                cc = parse.count;
                if (options.lexer_options.style.object_sort === true && data.token[cc - 1] === ",") {
                    const store = [data.token[cc]];
                    do {
                        cc = cc - 1;
                        if (data.types[cc] === "comment" || data.types[cc] === "ignore") {
                            do {
                                cc = cc - 1;
                            } while (cc > 0 && (data.types[cc] === "comment" || data.types[cc] === "ignore"));
                        }
                        if (data.token[cc] === ",") {
                            cc = cc - 1;
                        }
                        store.push(data.token[cc]);
                    } while (cc > 0 && (data.token[cc - 1] === "," || data.types[cc - 1] === "selector" || data.types[cc - 1] === "comment" || data.types[cc - 1] === "ignore"));
                    store.sort();
                    cc = parse.count;
                    data.token[cc] = store.pop();
                    do {
                        cc = cc - 1;
                        if (data.types[cc] === "comment" || data.types[cc] === "ignore") {
                            do {
                                cc = cc - 1;
                            } while (cc > 0 && (data.types[cc] === "comment" || data.types[cc] === "ignore"));
                        }
                        if (data.token[cc] === ",") {
                            cc = cc - 1;
                        }
                        data.token[cc] = store.pop();
                    } while (cc > 0 && (data.token[cc - 1] === "," || data.token[cc - 1] === "selector" || data.types[cc - 1] === "comment" || data.types[cc - 1] === "ignore"));
                }
                aa = parse.count;
                priors();
            };
            priors();
            //if the last non-comment type is 'item' then id it
            if (type === "start" && (data.types[aa] === "value" || data.types[aa] === "variable")) {
                data.types[aa] = "item";
            }
            if (data.lexer[parse.count - 1] !== "style" || bb < 0) {
                if (type === "colon") {
                    if (first === "$" || first === "@") {
                        data.types[aa] = "variable";
                    }
                    else {
                        data.types[aa] = "property";
                    }
                }
                else if (data.lexer[aa] === "style") {
                    data.types[aa] = "selector";
                    selectorPretty(aa);
                }
            }
            else if (type === "start" && data.types[aa] === "function" && data.lexer[aa] === "style") {
                data.types[aa] = "selector";
                selectorPretty(aa);
            }
            else if (data.types[aa] === "item" && data.lexer[aa] === "style") {
                if (type === "start") {
                    selectorPretty(aa);
                    data.types[aa] = "selector";
                    if (data.token[aa] === ":") {
                        data.types[bb] = "selector";
                    }
                    if (data.token[aa].indexOf("=\u201c") > 0) {
                        sparser.parseerror = `Quote looking character (\u201c, \\201c) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                    else if (data.token[aa].indexOf("=\u201d") > 0) {
                        sparser.parseerror = `Quote looking character (\u201d, \\201d) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                }
                else if (type === "end") {
                    if (first === "$" || first === "@") {
                        data.types[aa] = "variable";
                    }
                    else {
                        data.types[aa] = "value";
                    }
                    data.token[aa] = value(data.token[aa]);
                }
                else if (type === "separator") {
                    if (data.types[bb] === "colon" || data.token[bb] === "," || data.token[bb] === "{") {
                        if (b[a] !== ";" && (data.types[bb] === "selector" || data.token[bb] === "{")) {
                            data.types[aa] = "selector";
                            selectorPretty(aa);
                        }
                        else if (data.token[aa].charAt(0) === "$" || data.token[aa].charAt(0) === "@") {
                            data.types[aa] = "variable";
                        }
                        else {
                            data.types[aa] = "value";
                        }
                        data.token[aa] = value(data.token[aa]);
                        if (data.token[aa].charAt(0) === "\u201c") {
                            sparser.parseerror = `Quote looking character (\u201c, \\201c) used instead of actual quotes on line number ${parse.lineNumber}`;
                        }
                        else if (data.token[aa].charAt(0) === "\u201d") {
                            sparser.parseerror = `Quote looking character (\u201d, \\201d) used instead of actual quotes on line number ${parse.lineNumber}`;
                        }
                    }
                    else {
                        if (first === "$" || first === "@") {
                            data.types[aa] = "variable";
                        }
                        else if (data.types[bb] === "value" || data.types[bb] === "variable") {
                            data.token[bb] = data.token[bb] + data.token[aa];
                            parse.pop(data);
                        }
                        else {
                            data.types[aa] = "value";
                        }
                    }
                }
                else if (type === "colon") {
                    if (first === "$" || first === "@") {
                        data.types[aa] = "variable";
                    }
                    else {
                        data.types[aa] = "property";
                    }
                }
                else if (data.token[bb].charAt(0) === "@" && ((data.types[bb - 2] !== "variable" && data.types[bb - 2] !== "property") || data.types[bb - 1] === "separator")) {
                    data.types[bb] = "variable";
                    ltype = "variable";
                    data.token[bb] = value(data.token[bb]);
                }
            }
        }, semiComment = function lexer_style_separatorComment() {
            let x = parse.count;
            do {
                x = x - 1;
            } while (x > 0 && (data.types[x] === "comment"));
            if (data.token[x] === ";") {
                return;
            }
            parse.splice({
                data: data,
                howmany: 0,
                index: x + 1,
                record: {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "style",
                    lines: parse.linesSpace,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: ";",
                    types: "separator"
                }
            });
        }, template = function lexer_style_template(open, end) {
            let quote = "", name = "", start = open.length, endlen = 0;
            const store = [], exit = function lexer_style_template_exit(typename) {
                const endtype = data.types[parse.count - 1];
                if (ltype === "item") {
                    if (endtype === "colon") {
                        data.types[parse.count] = "value";
                    }
                    else {
                        item(endtype);
                    }
                }
                ltype = typename;
                if (ltype.indexOf("start") > -1 || ltype.indexOf("else") > -1) {
                    recordPush(ltoke);
                }
                else {
                    recordPush("");
                }
            };
            nosort[nosort.length - 1] = true;
            if (a < len) {
                do {
                    store.push(b[a]);
                    if (quote === "") {
                        if (b[a] === "\"") {
                            quote = "\"";
                        }
                        else if (b[a] === "'") {
                            quote = "'";
                        }
                        else if (b[a] === "/") {
                            if (b[a + 1] === "/") {
                                quote = "/";
                            }
                            else if (b[a + 1] === "*") {
                                quote = "*";
                            }
                        }
                        else if (b[a + 1] === end.charAt(0)) {
                            do {
                                endlen = endlen + 1;
                                a = a + 1;
                                store.push(b[a]);
                            } while (a < len && endlen < end.length && b[a + 1] === end.charAt(endlen));
                            if (endlen === end.length) {
                                quote = store.join("");
                                if ((/\s/).test(quote.charAt(start)) === true) {
                                    do {
                                        start = start + 1;
                                    } while ((/\s/).test(quote.charAt(start)) === true);
                                }
                                endlen = start;
                                do {
                                    endlen = endlen + 1;
                                } while (endlen < end.length && (/\s/).test(quote.charAt(endlen)) === false);
                                if (endlen === quote.length) {
                                    endlen = endlen - end.length;
                                }
                                if (open === "{%") {
                                    if (quote.indexOf("{%-") === 0) {
                                        quote = quote
                                            .replace(/^(\{%-\s*)/, "{%- ")
                                            .replace(/(\s*-%\})$/, " -%}");
                                        name = quote.slice(4);
                                    }
                                    else {
                                        quote = quote
                                            .replace(/^(\{%\s*)/, "{% ")
                                            .replace(/(\s*%\})$/, " %}");
                                        name = quote.slice(3);
                                    }
                                }
                                if (open === "{{") {
                                    quote = quote
                                        .replace(/^(\{\{\s+)/, "{{")
                                        .replace(/(\s+\}\})$/, "}}");
                                }
                                if (ltype === "item" && data.types[parse.count - 1] === "colon" && (data.types[parse.count - 2] === "property" || data.types[parse.count - 2] === "variable")) {
                                    ltype = "value";
                                    data.types[parse.count] = "value";
                                    if (Number.isNaN(Number(data.token[parse.count])) === true && data.token[parse.count].charAt(data.token[parse.count].length - 1) !== ")") {
                                        data.token[parse.count] = data.token[parse.count] + quote;
                                    }
                                    else {
                                        data.token[parse.count] = data.token[parse.count] + " " + quote;
                                    }
                                    return;
                                }
                                ltoke = quote;
                                if (open === "{%") {
                                    const templateNames = [
                                        "autoescape",
                                        "block",
                                        "capture",
                                        "case",
                                        "comment",
                                        "embed",
                                        "filter",
                                        "for",
                                        "form",
                                        "if",
                                        "macro",
                                        "paginate",
                                        "raw",
                                        "sandbox",
                                        "spaceless",
                                        "tablerow",
                                        "unless",
                                        "verbatim"
                                    ];
                                    let namesLen = templateNames.length - 1;
                                    name = name.slice(0, name.indexOf(" "));
                                    if (name.indexOf("(") > 0) {
                                        name = name.slice(0, name.indexOf("("));
                                    }
                                    if (name === "else" || name === "elseif" || name === "when" || name === "elif") {
                                        exit("template_else");
                                        return;
                                    }
                                    namesLen = templateNames.length - 1;
                                    if (namesLen > -1) {
                                        do {
                                            if (name === templateNames[namesLen]) {
                                                exit("template_start");
                                                return;
                                            }
                                            if (name === "end" + templateNames[namesLen]) {
                                                exit("template_end");
                                                return;
                                            }
                                            namesLen = namesLen - 1;
                                        } while (namesLen > -1);
                                    }
                                }
                                else if (open === "{{") {
                                    let group = quote.slice(2), ending = group.length, begin = 0;
                                    do {
                                        begin = begin + 1;
                                    } while (begin < ending && (/\s/).test(group.charAt(begin)) === false && group.charAt(start) !== "(");
                                    group = group.slice(0, begin);
                                    if (group.charAt(group.length - 2) === "}") {
                                        group = group.slice(0, group.length - 2);
                                    }
                                    if (group === "end") {
                                        exit("template_end");
                                        return;
                                    }
                                    if (group === "block" || group === "define" || group === "form" || group === "if" || group === "range" || group === "with") {
                                        exit("template_start");
                                        return;
                                    }
                                }
                                if ((/\{\s*\?>$/).test(ltoke) === true) {
                                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                                        exit("template_else");
                                        return;
                                    }
                                    exit("template_start");
                                    return;
                                }
                                if ((/^<\?(=|(php))\s*\}/).test(ltoke) === true) {
                                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                                        exit("template_else");
                                        return;
                                    }
                                    exit("template_end");
                                    return;
                                }
                                exit("template");
                                return;
                            }
                            endlen = 0;
                        }
                    }
                    else if (quote === b[a]) {
                        if (quote === "\"" || quote === "'") {
                            quote = "";
                        }
                        else if (quote === "/" && (b[a] === "\r" || b[a] === "\n")) {
                            quote = "";
                        }
                        else if (quote === "*" && b[a + 1] === "/") {
                            quote = "";
                        }
                    }
                    a = a + 1;
                } while (a < len);
            }
        }, 
        //finds comments including those JS looking '//' comments
        comment = function lexer_style_comment(line) {
            let comm = (line === true)
                ? parse.wrapCommentLine({
                    chars: b,
                    end: len,
                    lexer: "style",
                    opening: "//",
                    start: a,
                    terminator: "\n"
                })
                : parse.wrapCommentBlock({
                    chars: b,
                    end: len,
                    lexer: "style",
                    opening: "/*",
                    start: a,
                    terminator: "\u002a/"
                });
            ltoke = comm[0];
            ltype = ((/^(\/\*\s*parse-ignore-start)/).test(ltoke) === true)
                ? "ignore"
                : "comment";
            recordPush("");
            a = comm[1];
        }, 
        //consolidate margin and padding values
        margin_padding = function lexer_style_marginPadding() {
            const lines = parse.linesSpace, props = {
                data: {
                    margin: ["", "", "", "", false],
                    padding: ["", "", "", "", false]
                },
                last: {
                    margin: 0,
                    padding: 0
                },
                removes: []
            }, begin = parse.structure[parse.structure.length - 1][1], populate = function lexer_style_marginPadding_populate(prop) {
                if (data.token[aa - 2] === prop) {
                    const values = data.token[aa].replace(/\s*!important\s*/g, "").split(" "), vlen = values.length;
                    if (data.token[aa].indexOf("!important") > -1) {
                        props.data[prop[4]] = true;
                    }
                    if (vlen > 3) {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[1];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[2];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[3];
                        }
                    }
                    else if (vlen > 2) {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[1];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[2];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[1];
                        }
                    }
                    else if (vlen > 1) {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[1];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[0];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[1];
                        }
                    }
                    else {
                        if (props.data[prop][0] === "") {
                            props.data[prop][0] = values[0];
                        }
                        if (props.data[prop][1] === "") {
                            props.data[prop][1] = values[0];
                        }
                        if (props.data[prop][2] === "") {
                            props.data[prop][2] = values[0];
                        }
                        if (props.data[prop][3] === "") {
                            props.data[prop][3] = values[0];
                        }
                    }
                }
                else if (data.token[aa - 2] === `${prop}-bottom`) {
                    if (props.data[prop][2] === "") {
                        props.data[prop][2] = data.token[aa];
                    }
                }
                else if (data.token[aa - 2] === `${prop}-left`) {
                    if (props.data[prop][3] === "") {
                        props.data[prop][3] = data.token[aa];
                    }
                }
                else if (data.token[aa - 2] === `${prop}-right`) {
                    if (props.data[prop][1] === "") {
                        props.data[prop][1] = data.token[aa];
                    }
                }
                else if (data.token[aa - 2] === `${prop}-top`) {
                    if (props.data[prop][0] === "") {
                        props.data[prop][0] = data.token[aa];
                    }
                }
                else {
                    return;
                }
                props.removes.push([aa, prop]);
                props.last[prop] = aa;
            }, removes = function lexer_style_marginPadding_removes() {
                let cc = 0, values = "";
                const zero = (/^(0+([a-z]+|%))/), bb = props.removes.length, tmargin = (props.data.margin[0] !== "" && props.data.margin[1] !== "" && props.data.margin[2] !== "" && props.data.margin[3] !== ""), tpadding = (props.data.padding[0] !== "" && props.data.padding[1] !== "" && props.data.padding[2] !== "" && props.data.padding[3] !== ""), applyValues = function lexer_style_marginPadding_removes_applyValues(prop) {
                    if (zero.test(props.data[prop][0]) === true) {
                        props.data[prop][0] = "0";
                    }
                    if (zero.test(props.data[prop][1]) === true) {
                        props.data[prop][1] = "0";
                    }
                    if (zero.test(props.data[prop][2]) === true) {
                        props.data[prop][2] = "0";
                    }
                    if (zero.test(props.data[prop][3]) === true) {
                        props.data[prop][3] = "0";
                    }
                    if (props.data[prop][0] === props.data[prop][1] && props.data[prop][0] === props.data[prop][2] && props.data[prop][0] === props.data[prop][3]) {
                        values = props.data[prop][0];
                    }
                    else if (props.data[prop][0] === props.data[prop][2] && props.data[prop][1] === props.data[prop][3] && props.data[prop][0] !== props.data[prop][1]) {
                        values = `${props.data[prop][0]} ${props.data[prop][1]}`;
                    }
                    else if (props.data[prop][1] === props.data[prop][3] && props.data[prop][0] !== props.data[prop][2]) {
                        values = `${props.data[prop][0]} ${props.data[prop][1]} ${props.data[prop][2]}`;
                    }
                    else {
                        values = `${props.data[prop][0]} ${props.data[prop][1]} ${props.data[prop][2]} ${props.data[prop][3]}`;
                    }
                    if (props.data[prop[4]] === true) {
                        values = `${values.replace(" !important", "")} !important`;
                    }
                    if (props.last[prop] > parse.count) {
                        cc = (begin < 1)
                            ? 1
                            : begin + 1;
                        do {
                            if (data.begin[cc] === begin && data.types[cc] === "value" && data.token[cc - 2].indexOf(prop) === 0) {
                                props.last[prop] = cc;
                                break;
                            }
                            cc = cc + 1;
                        } while (cc < parse.count);
                    }
                    data.token[props.last[prop]] = values;
                    data.token[props.last[prop] - 2] = prop;
                };
                if (bb > 1 && (tmargin === true || tpadding === true)) {
                    do {
                        if (props.removes[cc][0] !== props.last.margin && props.removes[cc][0] !== props.last.padding && ((tmargin === true && props.removes[cc][1] === "margin") || (tpadding === true && props.removes[cc][1] === "padding"))) {
                            parse.splice({
                                data: data,
                                howmany: (data.types[props.removes[cc][0] + 1] === "separator")
                                    ? 4
                                    : 3,
                                index: props.removes[cc][0] - 2
                            });
                        }
                        cc = cc + 1;
                    } while (cc < bb - 1);
                }
                if (tmargin === true) {
                    applyValues("margin");
                }
                if (tpadding === true) {
                    applyValues("padding");
                }
                // this is necessary to fix the "begin" values of descendent blocks
                if (endtest === true) {
                    if (begin < 0) {
                        sparser.parseerror = "Brace mismatch.  There appears to be more closing braces than starting braces.";
                    }
                    else {
                        parse.sortCorrection(begin, parse.count + 1);
                    }
                }
            };
            let aa = parse.count, endtest = false;
            do {
                aa = aa - 1;
                if (data.begin[aa] === begin) {
                    if (data.types[aa] === "value" && data.types[aa - 2] === "property") {
                        if (data.token[aa - 2].indexOf("margin") === 0) {
                            populate("margin");
                        }
                        else if (data.token[aa - 2].indexOf("padding") === 0) {
                            populate("padding");
                        }
                    }
                }
                else {
                    endtest = true;
                    aa = data.begin[aa];
                }
            } while (aa > begin);
            removes();
            parse.linesSpace = lines;
        };
        //token building loop
        do {
            if ((/\s/).test(b[a]) === true) {
                a = parse.spacer({ array: b, end: len, index: a });
            }
            else if (b[a] === "/" && b[a + 1] === "*") {
                comment(false);
            }
            else if (b[a] === "/" && b[a + 1] === "/") {
                comment(true);
            }
            else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "p" && b[a + 3] === "h" && b[a + 4] === "p") {
                //php
                template("<?php", "?>");
            }
            else if (b[a] === "<" && b[a + 1] === "?" && b[a + 2] === "=") {
                //php
                template("<?=", "?>");
            }
            else if (b[a] === "<" && b[a + 1] === "%") {
                //asp
                template("<%", "%>");
            }
            else if (b[a] === "{" && b[a + 1] === "%") {
                //asp
                template("{%", "%}");
            }
            else if (b[a] === "{" && b[a + 1] === "{" && b[a + 2] === "{") {
                //mustache
                template("{{{", "}}}");
            }
            else if (b[a] === "{" && b[a + 1] === "{") {
                //handlebars
                template("{{", "}}");
            }
            else if (b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] === "#") {
                //ssi
                template("<!--#", "-->");
            }
            else if (b[a] === "@" && b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (b[a + 5] === "{" || (/\s/).test(b[a + 5]) === true)) {
                ltoke = "@else";
                ltype = "template_else";
                recordPush("");
                a = a + 4;
            }
            else if (b[a] === "{" || (b[a] === "(" && data.token[parse.count] === ":" && data.types[parse.count - 1] === "variable")) {
                item("start");
                ltype = "start";
                ltoke = b[a];
                if (b[a] === "(") {
                    recordPush("map");
                    mapper.push(0);
                }
                else if (data.types[parse.count] === "selector" || data.types[parse.count] === "variable") {
                    recordPush(data.token[parse.count]);
                }
                else if (data.types[parse.count] === "colon") {
                    recordPush(data.token[parse.count - 1]);
                }
                else {
                    recordPush("block");
                }
                nosort.push(false);
            }
            else if (b[a] === "}" || (b[a] === ")" && parse.structure[parse.structure.length - 1][0] === "map" && mapper[mapper.length - 1] === 0)) {
                if (b[a] === "}" && data.types[parse.count] === "item" && data.token[parse.count - 1] === "{" && data.token[parse.count - 2] !== undefined && data.token[parse.count - 2].charAt(data.token[parse.count - 2].length - 1) === "@") {
                    data.token[parse.count - 2] = data.token[parse.count - 2] + "{" + data.token[parse.count] +
                        "}";
                    parse.pop(data);
                    parse.pop(data);
                    parse.structure.pop();
                }
                else {
                    if (b[a] === ")") {
                        mapper.pop();
                    }
                    item("end");
                    if (b[a] === "}" && data.token[parse.count] !== ";") {
                        if (data.types[parse.count] === "value" || data.types[parse.count] === "function" || (data.types[parse.count] === "variable" && (data.token[parse.count - 1] === ":" || data.token[parse.count - 1] === ";"))) {
                            if (options.correct === true) {
                                ltoke = ";";
                            }
                            else {
                                ltoke = "x;";
                            }
                            ltype = "separator";
                            recordPush("");
                        }
                        else if (data.types[parse.count] === "comment") {
                            semiComment();
                        }
                    }
                    ltype = "end";
                    nosort.pop();
                    ltoke = b[a];
                    ltype = "end";
                    if (b[a] === "}") {
                        margin_padding();
                    }
                    if (options.lexer_options.style.object_sort === true && b[a] === "}") {
                        parse.object_sort(data);
                    }
                    recordPush("");
                }
            }
            else if (b[a] === ";" || b[a] === ",") {
                if (data.types[parse.count - 1] === "selector" || (data.token[parse.count - 1] === "}" && data.types[parse.count] !== "function")) {
                    item("start");
                }
                else {
                    item("separator");
                }
                if (data.types[parse.count] !== "separator" && esctest(a) === true) {
                    ltoke = b[a];
                    ltype = "separator";
                    recordPush("");
                }
            }
            else if (b[a] === ":" && data.types[parse.count] !== "end") {
                item("colon");
                ltoke = ":";
                ltype = "colon";
                recordPush("");
            }
            else {
                if (parse.structure[parse.structure.length - 1][0] === "map" && b[a] === "(") {
                    mapper[mapper.length - 1] = mapper[mapper.length - 1] + 1;
                }
                buildtoken();
            }
            a = a + 1;
        } while (a < len);
        if (options.lexer_options.style.object_sort === true) {
            parse.object_sort(data);
        }
        return data;
    };
    sparser.lexers.style = style;
}());
(function markdown_init() {
    
    const markdown = function lexer_markdown(source) {
        let a = 0, b = 0, bc1 = 0, bc2 = 0, quote = "", stack = [];
        const parse = sparser.parse, data = parse.data, options = sparser.options, lines = (options.crlf === true)
            // eslint-disable-next-line
            ? source.replace(/\u0000/g, "\ufffd").split("\r\n")
            // eslint-disable-next-line
            : source.replace(/\u0000/g, "\ufffd").split("\n"), frontspace = function lexer_markdown_frontspace(index) {
            const space = (/^\s+/).exec(lines[index]);
            if (space === null) {
                return "";
            }
            return space[0];
        }, hr = function lexer_markdown_hr() {
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<hr/>",
                types: "singleton"
            }, "");
        }, text = function lexer_markdown_text(item, tag, listrecurse) {
            const headerId = function lexer_markdown_text_headerId(tag) {
                if ((/<\/h\d>/).test(tag) === false) {
                    return tag;
                }
                const store = [], parent = parse.structure[parse.structure.length - 1];
                let aa = parent[1] + 1, id = "";
                do {
                    if (data.types[aa] === "content") {
                        store.push(data.token[aa]);
                    }
                    aa = aa + 1;
                } while (aa < parse.count);
                if (store.length > 0) {
                    id = `id="${store.join(" ").replace(/\s+/g, "-").replace(/\.|\(|\)|:|\?|#|=|\{|\}|\[|\]/g, "").replace(/-+/g, "-").replace(/^-/, "").replace(/-$/, "").toLowerCase()}"`;
                    parse.splice({
                        data: data,
                        howmany: 0,
                        index: parent[1] + 1,
                        record: {
                            begin: parent[1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parent[0],
                            token: id,
                            types: "attribute"
                        }
                    });
                }
                return tag;
            };
            let tagend = tag.replace("<", "</"), struct = tag.replace("<", "").replace(/(\/?>)$/, "");
            // line containing strong, em, or inline code
            if (item.indexOf("*") > -1 || item.indexOf("_") > -1 || item.indexOf("`") > -1 || (item.indexOf("[") > -1 && item.indexOf("](") > -1)) {
                const esctest = function lexer_markdown_text_esctest() {
                    let bb = aa - 1;
                    if (str[bb] === "\\") {
                        do {
                            bb = bb - 1;
                        } while (str[bb] === "\\");
                        if ((aa - bb) % 2 === 1) {
                            return true;
                        }
                        return false;
                    }
                    return false;
                }, underscore = function lexer_markdown_text_underscore() {
                    const numb = (str[aa + 1] === "_")
                        ? 2
                        : 1;
                    if ((/\s/).test(str[aa - 1]) === true || aa === 0 || aa === bb - numb || (/\s/).test(str[aa + numb]) === true) {
                        return true;
                    }
                    return false;
                }, gencontent = function lexer_markdown_text_gencontent() {
                    return itemx.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "").replace(/\\(?!(\\))/g, "").replace(/\\{2}/g, "\\");
                };
                let stray = "", str = item.split(""), content = "", itemx = [], square = 0, aa = 0, bb = str.length, cc = 0;
                if (tag !== "multiline") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: tag,
                        types: "start"
                    }, struct);
                }
                do {
                    if (str[aa] === "[" && esctest() === false) {
                        cc = aa;
                        square = 0;
                        do {
                            if (str[cc] === "[") {
                                square = square + 1;
                            }
                            else if (str[cc] === "]") {
                                square = square - 1;
                                if (square < 1 && str[cc + 1] === "(") {
                                    content = itemx.join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                                    if (content !== "") {
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 0,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: content,
                                            types: "content"
                                        }, "");
                                    }
                                    itemx = [];
                                    stack.push("[");
                                    if (str[aa - 1] === "!") {
                                        content = "img";
                                    }
                                    else {
                                        content = "a";
                                    }
                                    if (content === "img") {
                                        if (data.token[parse.count] === "!") {
                                            parse.pop(data);
                                        }
                                        else if (data.types[parse.count] === "content") {
                                            data.token[parse.count] = data.token[parse.count].slice(0, data.token[parse.count].length - 1).replace(/(\s)$/, "");
                                        }
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 1,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "<img/>",
                                            types: "singleton"
                                        }, "");
                                        content = str.slice(aa + 1, cc).join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                                        if (content !== "") {
                                            parse.push(data, {
                                                begin: parse.structure[parse.structure.length - 1][1],
                                                ender: -1,
                                                lexer: "markdown",
                                                lines: 0,
                                                stack: parse.structure[parse.structure.length - 1][0],
                                                token: "alt=\"" + content + "\"",
                                                types: "attribute"
                                            }, "");
                                        }
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 1,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "src=\"",
                                            types: "attribute"
                                        }, "");
                                        aa = cc - 1;
                                    }
                                    else {
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 1,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "<a>",
                                            types: "start"
                                        }, "a");
                                        parse.push(data, {
                                            begin: parse.structure[parse.structure.length - 1][1],
                                            ender: -1,
                                            lexer: "markdown",
                                            lines: 0,
                                            stack: parse.structure[parse.structure.length - 1][0],
                                            token: "href=\"",
                                            types: "attribute"
                                        }, "");
                                    }
                                    break;
                                }
                            }
                            cc = cc + 1;
                        } while (cc < bb);
                    }
                    else if (str[aa] === "]" && str[aa + 1] === "(" && esctest() === false && stack[stack.length - 1] === "[") {
                        content = gencontent();
                        if (content !== "" && content.length > 1 && parse.structure[parse.structure.length - 1][0] !== "img") {
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: content,
                                types: "content"
                            }, "");
                        }
                        cc = aa + 1;
                        square = 0;
                        do {
                            if (str[cc] === "(") {
                                square = square + 1;
                            }
                            else if (str[cc] === ")") {
                                square = square - 1;
                                if (square === 0) {
                                    content = str.slice(aa + 2, cc).join("").replace(/\s+/g, " ").replace(/^\s/, "").replace(/\s$/, "");
                                    aa = cc;
                                    str[cc] = "";
                                    itemx = [];
                                    cc = (parse.structure[parse.structure.length - 1][0] === "a")
                                        ? parse.structure[parse.structure.length - 1][1] + 1
                                        : parse.count;
                                    if (content === "") {
                                        data.token[cc] = data.token[cc] + "\"";
                                    }
                                    else {
                                        data.token[cc] = data.token[cc] + content + "\"";
                                    }
                                    break;
                                }
                            }
                            cc = cc + 1;
                        } while (cc < bb);
                        stack.pop();
                        if (parse.structure[parse.structure.length - 1][0] === "a") {
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: "</a>",
                                types: "end"
                            }, "");
                        }
                    }
                    else if ((str[aa] === "*" || (str[aa] === "_" && underscore() === true) || str[aa] === "~") &&
                        esctest() === false &&
                        stack[stack.length - 1] !== "`" &&
                        ((quote === "" && ((/\s/).test(str[aa - 1]) === true ||
                            aa === 0)) || quote !== "")) {
                        if (str[aa] === "~") {
                            quote = "~";
                            do {
                                str[aa] = "";
                                aa = aa + 1;
                            } while (str[aa] === "~");
                        }
                        else if (str[aa] === "*" && str[aa + 1] === "*") {
                            quote = "**";
                            str[aa + 1] = "";
                        }
                        else if (str[aa] === "_" && str[aa + 1] === "_") {
                            quote = "__";
                            str[aa + 1] = "";
                        }
                        else if (str[aa] === "_") {
                            quote = "_";
                        }
                        else if (str[aa] !== "_") {
                            quote = "*";
                        }
                        str[aa] = "";
                        if (quote === stack[stack.length - 1]) {
                            let midtag = "</em>";
                            content = gencontent();
                            if (content !== "") {
                                parse.push(data, {
                                    begin: parse.structure[parse.structure.length - 1][1],
                                    ender: -1,
                                    lexer: "markdown",
                                    lines: 0,
                                    stack: parse.structure[parse.structure.length - 1][0],
                                    token: content,
                                    types: "content"
                                }, "");
                            }
                            itemx = [];
                            if (quote === "~") {
                                midtag = "</strike>";
                            }
                            else if (quote === "**" || quote === "__") {
                                midtag = "</strong>";
                            }
                            stack.pop();
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: midtag,
                                types: "end"
                            }, "");
                            quote = "";
                            stack = [];
                        }
                        else {
                            let midtag = "em";
                            content = gencontent();
                            if (content !== "") {
                                parse.push(data, {
                                    begin: parse.structure[parse.structure.length - 1][1],
                                    ender: -1,
                                    lexer: "markdown",
                                    lines: 0,
                                    stack: parse.structure[parse.structure.length - 1][0],
                                    token: content,
                                    types: "content"
                                }, "");
                            }
                            itemx = [];
                            if (quote === "~") {
                                midtag = "strike";
                            }
                            else if (quote === "**" || quote === "__") {
                                midtag = "strong";
                            }
                            stack.push(quote);
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 1,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: `<${midtag}>`,
                                types: "start"
                            }, midtag);
                        }
                    }
                    else if (str[aa] === "`" && esctest() === false) {
                        content = gencontent();
                        if (content !== "") {
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: content,
                                types: "content"
                            }, "");
                        }
                        itemx = [];
                        if (stack[stack.length - 1] === "`") {
                            str[aa] = "";
                            stack.pop();
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 0,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: "</code>",
                                types: "end"
                            }, "");
                            quote = "";
                            stack = [];
                        }
                        else {
                            stack.push("`");
                            parse.push(data, {
                                begin: parse.structure[parse.structure.length - 1][1],
                                ender: -1,
                                lexer: "markdown",
                                lines: 1,
                                stack: parse.structure[parse.structure.length - 1][0],
                                token: "<code>",
                                types: "start"
                            }, "code");
                        }
                    }
                    if (str[aa] !== stack[stack.length - 1] && str[aa - 1] + str[aa] !== stack[stack.length - 1]) {
                        itemx.push(str[aa]);
                    }
                    aa = aa + 1;
                } while (aa < bb);
                content = gencontent();
                if (tag !== "multiline" && data.types[parse.count] === "start" && data.token[parse.count] !== tag) {
                    stray = data.token[parse.count];
                    parse.pop(data);
                    parse.structure.pop();
                    if (stray === "<code>") {
                        stray = "`";
                    }
                    else if (stray === "<em>") {
                        stray = "*";
                    }
                    else if (stray === "<strong>") {
                        stray = "**";
                    }
                    else if (stray === "<strike>") {
                        stray = "~";
                    }
                    if (data.types[parse.count] === "start") {
                        content = item;
                    }
                    else {
                        data.token[parse.count] = data.token[parse.count] + stray;
                    }
                }
                if (content !== "") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 1,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: content,
                        types: "content"
                    }, "");
                }
                if (listrecurse === true) {
                    list();
                }
                if (tag !== "multiline") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: headerId(tagend),
                        types: "end"
                    }, "");
                    quote = "";
                    stack = [];
                }
                return;
            }
            if (struct.indexOf(" ") > 0) {
                struct = struct.slice(0, struct.indexOf(" "));
            }
            if (tag !== "multiline") {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: tag,
                    types: "start"
                }, struct);
            }
            if (listrecurse === true) {
                list();
            }
            else {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: item.replace(/^(\s+)/, "").replace(/(\s+)$/, ""),
                    types: "content"
                }, "");
            }
            if (tag !== "multiline") {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: headerId(tagend),
                    types: "end"
                }, "");
                quote = "";
                stack = [];
            }
        }, comtest = function lexer_markdown_comtest(index) {
            return (/^(\s{0,3}<!--)/).test(lines[index]);
        }, hrtest = function lexer_markdown_hrtest(index) {
            return (/^(\s*((-\s*){3,}|(_\s*){3,}|(\*\s*){3,})\s*)$/).test(lines[index]);
        }, codetest = function lexer_markdown_codetest(index) {
            return ((/^(\u0020{4,}\s*\S)/).test(lines[index]) === true || (/^(\s*\t\s*\S)/).test(lines[index]) === true);
        }, codeblocktest = function lexer_markdown_codeblocktest(index) {
            return (/^(\s{0,3}((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[index]);
        }, listtest = function lexer_markdown_listtest(index) {
            const listy = (/^(\s*(\*|-|\+|(\d{1,9}(\)|\.))))/);
            if (listy.test(lines[index]) === true) {
                const listr = lines[index].replace(listy, "");
                if (listr === "") {
                    lines[index] = lines[index] + " ";
                }
                else if ((/\s/).test(listr.charAt(0)) === false) {
                    return false;
                }
                return true;
            }
            return false;
        }, comment = function lexer_markdown_comment() {
            const com = [];
            let comment = "";
            if (lines[a].indexOf("-->") < 0) {
                do {
                    com.push(lines[a]);
                    a = a + 1;
                } while (a < b && lines[a].indexOf("-->") < 0);
            }
            else {
                com.push(lines[a]);
            }
            if (options.crlf === true) {
                comment = com.join("\r\n").replace(/^(\s*<!--+\s*)/, "").replace(/\s*-+->/, "-->");
            }
            else {
                comment = com.join("\n").replace(/^(\s*<!--+\s*)/, "").replace(/\s*-+->/, "-->");
            }
            comment = comment.slice(0, comment.indexOf("-->"));
            if (lines[a] !== undefined) {
                lines[a] = lines[a].slice(lines[a].indexOf("-->") + 3);
                if (lines[a].replace(/\s+/, "") !== "") {
                    a = a - 1;
                }
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: comment,
                types: "comment"
            }, "");
        }, code = function lexer_markdown_code(codetext, language, fourspace) {
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<p>",
                types: "start"
            }, "p");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<code>",
                types: "start"
            }, "code");
            if (language !== "") {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "class=\"language-" + language + "\"",
                    types: "attribute"
                }, "");
            }
            if (codetext !== "") {
                if (fourspace === true) {
                    if (codetext.indexOf("    ") === 0) {
                        codetext = codetext.replace(/^(\u0020{4})/, "");
                    }
                    else {
                        codetext = codetext.replace(/^(\s*\t)/, "");
                    }
                }
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: codetext,
                    types: "content"
                }, "");
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</code>",
                types: "end"
            }, "");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</p>",
                types: "end"
            }, "");
        }, codeblock = function lexer_markdown_codeblock(ticks, blockyquote, fourspace) {
            const indentstr = (function lexer_markdown_codeblock() {
                let inumb = (ticks === true)
                    ? (/^(\s*)/).exec(lines[a])[0].length
                    : 0;
                if (inumb > 3) {
                    return 0;
                }
                return inumb;
            }()), indent = new RegExp(`^(\\s{0,${indentstr}})`), open = (function lexer_markdown_codeblock_open() {
                const op = lines[a].replace(/^\s*/, "");
                let aa = 0;
                do {
                    aa = aa + 1;
                } while (op.charAt(aa) === op.charAt(0));
                return op.slice(0, aa);
            }()), language = (ticks === true)
                ? lines[a].replace(/(\s*((`+)|(~+))\s*)/, "").replace(/(\s*)/g, "")
                : "", endgate = new RegExp(`^\\s{0,3}${open.charAt(0)}{${open.length},}\\s*$`), codes = [];
            if (ticks === true) {
                a = a + 1;
                if (endgate.test(lines[a]) === true) {
                    code("", language, false);
                    return;
                }
            }
            do {
                if (lines[a] === undefined) {
                    break;
                }
                if (ticks === true) {
                    if (endgate.test(lines[a]) === true) {
                        break;
                    }
                    codes.push(lines[a].replace(indent, ""));
                }
                else if (lines[a] !== "") {
                    codes.push(lines[a].replace(/^(\u0020{4})/, "").replace(/^(\s*\t)/, ""));
                    if (lines[a + 1] !== "" && codetest(a + 1) === false) {
                        break;
                    }
                    if (lines[a + 1] === "" && codetest(a + 2) === false) {
                        a = a + 1;
                        break;
                    }
                }
                else {
                    if (codetest(a + 1) === false) {
                        break;
                    }
                    codes.push("");
                }
                if (blockyquote === true && (/^(\s*>)/).test(lines[a + 1]) === false) {
                    break;
                }
                a = a + 1;
            } while (a < b);
            if (options.crlf === true) {
                code(codes.join("\r\n"), language, fourspace);
            }
            else {
                code(codes.join("\n"), language, fourspace);
            }
        }, parabuild = function lexer_markdown_parabuild() {
            let x = a, tag = "<p>";
            const test = function lexer_markdown_parabuild_test(index) {
                if (lines[index] === undefined) {
                    return false;
                }
                if ((/^(\s{0,3}((=+)|(-+))\s*)$/).test(lines[index]) === true) {
                    if (lines[index].indexOf("=") > -1) {
                        tag = "<h1>";
                    }
                    else {
                        tag = "<h2>";
                    }
                    return false;
                }
                if (hrtest(index) === true) {
                    return false;
                }
                if ((/^(\s*((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[index]) === true) {
                    return false;
                }
                if (lines[index] === "") {
                    return false;
                }
                if ((/^(\s*>)/).test(lines[index]) === true) {
                    return false;
                }
                if ((/^(\s*#{1,6}\s)/).test(lines[index]) === true) {
                    return false;
                }
                if (listtest(index) === true && parse.structure[parse.structure.length - 1][0] !== "blockquote") {
                    return false;
                }
                return true;
            }, fixquote = function lexer_markdown_parabuild_fixquote() {
                let key = "", x = parse.count;
                if (quote === "*" || quote === "_") {
                    key = "<em>";
                }
                else if (quote === "**" || quote === "__") {
                    key = "<strong>";
                }
                else if (quote === "~") {
                    key = "<strike>";
                }
                parse.structure.pop();
                if (data.token[x] !== key) {
                    do {
                        data.begin[x] = parse.structure[parse.structure.length - 1][1];
                        data.stack[x] = parse.structure[parse.structure.length - 1][0];
                        x = x - 1;
                    } while (x > 0 && data.token[x] !== key);
                }
                if (data.types[x + 1] === "content") {
                    data.token[x + 1] = `${quote} ${data.token[x + 1]}`;
                    parse.splice({
                        data: data,
                        howmany: 1,
                        index: x
                    });
                }
                else if (data.types[x - 1] === "content") {
                    data.token[x - 1] = data.token[x - 1] + quote;
                    parse.splice({
                        data: data,
                        howmany: 1,
                        index: x
                    });
                }
                else {
                    data.token[x] = quote;
                    data.types[x] = "content";
                }
                quote = "";
            };
            if (test(a + 1) === true) {
                do {
                    x = x + 1;
                } while (x < b && test(x) === true);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: tag,
                    types: "start"
                }, tag.replace("<", "").replace(">", ""));
                if (x === a + 1) {
                    text(lines[a], tag, false);
                }
                else {
                    do {
                        text(lines[a], "multiline", false);
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "<br/>",
                            types: "singleton"
                        }, "");
                        a = a + 1;
                    } while (a < x);
                    parse.pop(data);
                    if (quote !== "") {
                        fixquote();
                    }
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: tag.replace("<", "</"),
                        types: "end"
                    }, "");
                }
            }
            else {
                text(lines[a], tag, false);
                if (tag !== "<p>") {
                    a = a + 1;
                }
            }
            quote = "";
            stack = [];
        }, heading = function lexer_markdown_heading() {
            let hash = (/^(\s*#+\s+)/).exec(lines[a])[0].replace(/\s+/g, ""), hashes = function lexer_markdown_heading_hasheds(escapes) {
                return escapes.replace(/\\/g, "").replace(/\s+/g, "");
            }, content = lines[a].replace(/^(\s*#+\s+)/, "").replace(/(\s+#+\s*)$/, "").replace(/((\\?#)+\s*)$/, hashes);
            if (content === "" || (/^(#+)$/).test(content) === true) {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<h" + hash.length + ">",
                    types: "start"
                }, "h" + hash.length);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</h" + hash.length + ">",
                    types: "end"
                }, "");
            }
            else {
                text(content, "<h" + hash.length + ">", false);
            }
        }, blockquote = function lexer_markdown_blockquote() {
            let x = a;
            bc1 = bc1 + 1;
            bc2 = bc1;
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<blockquote>",
                types: "start"
            }, "blockquote");
            do {
                lines[x] = lines[x].replace(/^(\s*>\u0020?)/, "");
                if (listtest(x + 1) === true) {
                    break;
                }
                if (lines[x].replace(/\s+/, "") === "") {
                    lines[x] = "";
                    if ((/^(\s*>)/).test(lines[x + 1]) === false) {
                        break;
                    }
                }
                if ((/^(\s{0,3}((-{3,})|(={3,}))\s*)$/).test(lines[x + 1]) === true) {
                    break;
                }
                x = x + 1;
            } while (x < b && lines[x] !== "" && codetest(x) === false && hrtest(x) === false);
            if (x < b - 1 && x > 0) {
                if (listtest(x) === true) {
                    lines.splice(x + 1, 0, "");
                    b = b + 1;
                }
                else if (lines[x].replace(/\s+/, "") !== "") {
                    x = x - 1;
                }
            }
            do {
                if ((/^(\s*>)/).test(lines[a]) === true) {
                    blockquote();
                }
                else if ((/^(\s*((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[a]) === true) {
                    if (a + 1 < x) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "<p>",
                            types: "start"
                        }, "p");
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "<code>",
                            types: "start"
                        }, "code");
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "</code>",
                            types: "end"
                        }, "");
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "</p>",
                            types: "end"
                        }, "");
                        lines[a] = "";
                        break;
                    }
                    codeblock(true, true, false);
                }
                else if (codetest(a) === true) {
                    codeblock(false, true, true);
                }
                else if ((/^(\s*#{1,6}\s)/).test(lines[a]) === true) {
                    heading();
                }
                else if (listtest(a) === true) {
                    list();
                }
                else if (a > x && (/^(\s{0,3}((-{3,})|(={3,}))\s*)$/).test(lines[a + 1]) === true) {
                    text(lines[a], "<p>", false);
                }
                else if (lines[a].replace(/\s+/, "") !== "") {
                    parabuild();
                }
                a = a + 1;
            } while (a < x);
            if (lines[a - 1] === "" || lines[a] !== "" || (a > x && (/^(\s{0,3}((-{3,})|(={3,}))\s*)$/).test(lines[a]) === true)) {
                a = a - 1;
            }
            bc1 = bc1 - 1;
            if (bc1 === 0) {
                do {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</blockquote>",
                        types: "end"
                    }, "");
                    bc2 = bc2 - 1;
                } while (bc2 > 0);
            }
        }, list = function lexer_markdown_list() {
            let paraForce = false, ind = 0, sym = lines[a].replace(/^(\s+)/, "").charAt(0), record = {
                begin: -1,
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: "",
                token: "",
                types: ""
            }, numb = "", lasttext = "", y = 0, z = 0, order = false, end;
            const tabs = function lexer_markdown_list_tabs(spaces) {
                let output = spaces.split(""), uu = 0;
                const tt = output.length;
                do {
                    if (output[uu] === "\t") {
                        output[uu] = "    ";
                    }
                    uu = uu + 1;
                } while (uu < tt);
                return output.join("");
            }, checktest = function lexer_markdown_list_checktest() {
                return ((/^(\s*(\*|-|\+)?\s{0,3}\[( |x)\]\s*)$/).test(lines[a]) === true || (/^(\s*(\*|-|\+)?\s{0,3}\[( |x)\]\s+\S)/).test(lines[a]) === true);
            }, indentation = (/^(\s*(\*|-|\+)?\s*)/), indlen = function lexer_markdown_list_indlen(index) {
                if (lines[index] === undefined) {
                    return 0;
                }
                return indentation.exec(lines[index].replace(indentation, tabs))[0].length;
            }, space = function lexer_markdown_list_space(index, emptyLine) {
                let xind = indlen(index), xsym = (lines[index] === undefined)
                    ? ""
                    : lines[index].replace(/^(\s+)/, "").charAt(0);
                if (lines[index] === undefined) {
                    return 0;
                }
                if (order === true) {
                    xind = (/(^(\s*(\d+(\)|\.)))?\s*)/).exec(lines[index])[0].length;
                    xsym = lines[index].replace(/^(\s*\d+)/, "").charAt(0);
                }
                if (order === false && "*-+".indexOf(xsym) > -1 && xsym !== sym && xind - ind < 2 && (/\s/).test(lines[index].replace(/^(\s+)/, "").charAt(1)) === true) {
                    return -1;
                }
                if (xind - ind < 0) {
                    return xind;
                }
                if (xsym !== sym && listtest(index) === true && (emptyLine === false || (emptyLine === true && xind - ind < 2))) {
                    return 10;
                }
                return xind;
            };
            if ((/^(\s*\d{1,9}(\)|\.)\s)/).test(lines[a]) === true) {
                order = true;
                ind = (/(^(\s*(\d+(\)|\.)))?\s*)/).exec(lines[a])[0].length;
                sym = lines[a].replace(/^(\s*\d+)/, "").charAt(0);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<ol>",
                    types: "start"
                }, "ol");
                numb = (/\d{1,9}/).exec(lines[a])[0].replace(/^(0+)/, "");
                if (numb !== "1") {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "start=\"" + numb + "\"",
                        types: "attribute"
                    }, "");
                }
            }
            else {
                ind = indlen(a);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<ul>",
                    types: "start"
                }, "ul");
            }
            do {
                paraForce = false;
                // lists do not contain comments
                if (comtest(a) === true) {
                    a = a - 1;
                    break;
                }
                // an ordered list may not have unordered list items
                if (order === true && (/^(\s{0,3}(\*|-|\+)\s)/).test(lines[a]) === true) {
                    if (frontspace(a) !== "") {
                        lexer_markdown_list();
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else {
                        lines.splice(a, 0, "");
                        b = b + 1;
                        break;
                    }
                }
                // an unordered list may not have ordered list items
                if (order === false && (/^(\s{0,3}\d{1,9}(\)|\.)\s)/).test(lines[a]) === true) {
                    if (frontspace(a) !== "") {
                        lexer_markdown_list();
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else {
                        lines.splice(a, 0, "");
                        b = b + 1;
                        break;
                    }
                }
                numb = lines[a];
                lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, "");
                //recursive list item
                if (listtest(a) === true) {
                    parse.structure.push(["ul", parse.count - 3]);
                    lexer_markdown_list();
                    record.begin = parse.structure[parse.structure.length - 1][1];
                    record.stack = parse.structure[parse.structure.length - 1][0];
                    record.token = "<li>";
                    record.types = "start";
                    y = parse.count - 1;
                    do {
                        data.begin[y] = data.begin[y] - 1;
                        y = y - 1;
                    } while (y > 0 && data.token[y + 1] !== "<li>");
                    parse.splice({
                        data: data,
                        howmany: 0,
                        index: y,
                        record: record
                    });
                    y = y + 1;
                    do {
                        if (data.types[y] === "start") {
                            data.begin[y] = y - 1;
                            data.stack[y] = data.token[y - 1].replace("<", "").replace(">", "");
                            z = y;
                        }
                        else {
                            data.begin[y] = z;
                            if (data.types[y] === "end") {
                                z = z - 1;
                            }
                        }
                        y = y + 1;
                    } while (y < parse.count + 1);
                    record.begin = z;
                    record.stack = "li";
                    record.token = "</li>";
                    record.types = "end";
                    parse.push(data, record, "");
                }
                else if (lines[a] === "") {
                    y = space(a + 1, true) - ind;
                    if (y < 0) {
                        break;
                    }
                    if (y > 1 && a < b - 1 && lines[a + 1].replace(/\s+/, "").charAt(0) !== sym && (/^(\s{0,3}>)/).test(lines[a + 1]) === false) {
                        paraForce = true;
                    }
                    else if (codetest(a + 1) === false && (parse.structure.join("").indexOf("blockquote") > 0 || y !== 0) && a < b - 1) {
                        break;
                    }
                }
                else {
                    lines[a] = numb;
                    y = space(a, false) - ind;
                    if (y < -1 || y > 9 || hrtest(a) === true) {
                        z = (lines[a + 1] === "")
                            ? a + 2
                            : a + 1;
                        if (z !== b && codetest(z) === false && listtest(z) === false && (/^\s*>/).test(lines[a]) === false && lines[a + 1] !== "") {
                            a = a - 1;
                            break;
                        }
                    }
                    if (data.token[parse.count - 1] === "<li>") {
                        paraForce = false;
                        if (lines[a - 1] === "") {
                            a = a - 1;
                            break;
                        }
                    }
                    else if (y < 1 && listtest(a) === false) {
                        paraForce = true;
                        y = 2;
                    }
                    if ((/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s*)$/).test(lines[a]) === true && lines[a + 1] === "") {
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "<li>";
                        record.types = "start";
                        parse.push(data, record, "li");
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else if (y < -1) {
                        //different list type
                        lines.splice(a, 0, "");
                        b = b + 1;
                        break;
                    }
                    else if (y > 1) {
                        if ((/^(\s*>)/).test(lines[a]) === true) {
                            //blockquote in list item
                            end = parse.pop(data);
                            record.begin = end.begin;
                            record.stack = end.stack;
                            parse.structure.push([end.stack, end.begin]);
                            blockquote();
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                        else if (listtest(a) === true && (/^(\u0020{4,}\s*\S)/).test(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "").replace(/^\t/, "    ")) === true) {
                            //code line in list item
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "<li>";
                            record.types = "start";
                            parse.push(data, record, "li");
                            lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "").replace(/^\t/, "    ");
                            code(lines[a], "", true);
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                        else if (paraForce || (codetest(a) === true && listtest(a) === false)) {
                            end = parse.pop(data);
                            record.begin = end.begin;
                            record.stack = end.stack;
                            parse.structure.push([end.stack, end.begin]);
                            if (lines[a - 1] === "" && data.token[parse.count] !== "</p>") {
                                lasttext = data.token[parse.count];
                                parse.pop(data);
                                record.token = "<p>";
                                record.types = "start";
                                parse.push(data, record, "p");
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                record.token = lasttext;
                                record.types = "content";
                                parse.push(data, record, "");
                                record.token = "</p>";
                                record.types = "end";
                                parse.push(data, record, "");
                            }
                            lines[a] = lines[a].replace(/^(\u0020{4})/, "").replace(/^(\s*\t)/, "");
                            if (codetest(a) === true) {
                                code(lines[a], "", true);
                            }
                            else if (data.token[parse.count] === "</p>" && lines[a - 1] !== "") {
                                parse.pop(data);
                                parse.structure.push(["p", data.begin[parse.count]]);
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                record.token = "<br/>";
                                record.types = "singleton";
                                parse.push(data, record, "");
                                text(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, ""), "multiline", false);
                                record.token = "</p>";
                                record.types = "end";
                                parse.push(data, record, "");
                            }
                            else if (data.types[parse.count] === "content") {
                                a = a - 1;
                                parse.pop(data);
                                record.token = "<p>";
                                record.types = "start";
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                parse.push(data, record, "p");
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                text(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, ""), "multiline", false);
                                record.token = "<br/>";
                                record.types = "singleton";
                                parse.push(data, record, "");
                                a = a + 1;
                                text(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, ""), "multiline", false);
                                record.token = "</p>";
                                record.types = "end";
                                parse.push(data, record, "");
                            }
                            else {
                                text(lines[a], "<p>", false);
                            }
                            parse.push(data, end, "");
                        }
                        else if (listtest(a) === true) {
                            lexer_markdown_list();
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                    }
                    else if ((/^(\s*((`{3,})|(~{3,}))+(\S+)?\s*)$/).test(lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "")) === true) {
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "<li>";
                        record.types = "start";
                        parse.push(data, record, "li");
                        lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s)/, "");
                        codeblock(true, false, false);
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "</li>";
                        record.types = "end";
                        parse.push(data, record, "");
                    }
                    else if (checktest() === true || (listtest(a + 1) === true && space(a + 1, false) - space(a, false) > 1)) {
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = "<li>";
                        record.types = "start";
                        parse.push(data, record, "li");
                        if (checktest() === true) {
                            if (data.types[parse.structure[parse.structure.length - 2][1] + 1] !== "attribute") {
                                const index = parse.structure[parse.structure.length - 2][1] + 1;
                                parse.structure[parse.structure.length - 1][1] = parse.structure[parse.structure.length - 1][1] + 1;
                                if (parse.count > index) {
                                    const parent = index - 1;
                                    let aa = parse.count;
                                    do {
                                        aa = aa - 1;
                                        if (data.begin[aa] !== parent) {
                                            data.begin[aa] = data.begin[aa] + 1;
                                        }
                                        data.ender[aa] = data.ender[aa] + 1;
                                    } while (aa > index);
                                }
                                parse.splice({
                                    data: data,
                                    howmany: 0,
                                    index: index,
                                    record: {
                                        begin: parse.structure[parse.structure.length - 2][1],
                                        ender: -1,
                                        lexer: "markdown",
                                        lines: 0,
                                        stack: parse.structure[parse.structure.length - 2][0],
                                        token: "class=\"contains-task-list\"",
                                        types: "attribute"
                                    }
                                });
                            }
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "class=\"task-list-item\"";
                            record.types = "attribute";
                            parse.push(data, record, "");
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "<input/>";
                            record.types = "singleton";
                            parse.push(data, record, "");
                            y = parse.count;
                            record.begin = y;
                            record.stack = "input";
                            record.token = "class=\"task-list-item-checkbox\"";
                            record.types = "attribute";
                            parse.push(data, record, "");
                            record.begin = y;
                            record.stack = "input";
                            record.token = "disabled=\"disabled\"";
                            record.types = "attribute";
                            parse.push(data, record, "");
                            y = lines[a].indexOf("[x]");
                            z = lines[a].indexOf("[ ]");
                            if (y > -1 && z > -1) {
                                if (y < z) {
                                    lines[a] = lines[a].replace(/(\[x\]\s*)/, "");
                                    record.begin = data.begin[parse.count - 1];
                                    record.stack = "input";
                                    record.token = "checked=\"checked\"";
                                    record.types = "attribute";
                                    parse.push(data, record, "");
                                }
                                else {
                                    lines[a] = lines[a].replace(/(\[ \]\s*)/, "");
                                }
                            }
                            else if (y > -1) {
                                lines[a] = lines[a].replace(/(\[x\]\s*)/, "");
                                record.begin = data.begin[parse.count - 1];
                                record.stack = "input";
                                record.token = "checked=\"checked\"";
                                record.types = "attribute";
                                parse.push(data, record, "");
                            }
                            else {
                                lines[a] = lines[a].replace(/(\[ \]\s*)/, "");
                            }
                        }
                        lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, "");
                        text(lines[a], "multiline", false);
                        if (listtest(a + 1) === false || a > b - 1 || frontspace(a) === frontspace(a + 1)) {
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = "</li>";
                            record.types = "end";
                            parse.push(data, record, "");
                        }
                    }
                    else {
                        lines[a] = lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}\.))\s+)/, "");
                        text(lines[a], "<li>", false);
                    }
                }
                a = a + 1;
            } while (a < b);
            if (lines[a] === "" || listtest(a + 1) === false) {
                if (order === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</ol>",
                        types: "end"
                    }, "");
                }
                else {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</ul>",
                        types: "end"
                    }, "");
                }
            }
        }, table = function lexer_markdown_table() {
            let c = 0, d = 0, line = lines[a]
                .replace(/^\|/, "")
                .replace(/\|$/, "")
                .replace(/\\\|/g, "parse\\?sep")
                .split("|"), bar = lines[a + 1]
                .replace(/(\s*)/g, "")
                .replace(/^\|/, "")
                .replace(/\|$/, "")
                .split("|");
            if (line.length !== bar.length) {
                return parabuild();
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<table>",
                types: "start"
            }, "table");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<thead>",
                types: "start"
            }, "thead");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<tr>",
                types: "start"
            }, "tr");
            d = line.length;
            do {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<th>",
                    types: "start"
                }, "th");
                if ((/:-+:/).test(bar[c]) === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "style=\"text-align:center\"",
                        types: "attribute"
                    }, "");
                }
                else if ((/:-+/).test(bar[c]) === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "style=\"text-align:left\"",
                        types: "attribute"
                    }, "");
                }
                else if ((/-+:/).test(bar[c]) === true) {
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "style=\"text-align:right\"",
                        types: "attribute"
                    }, "");
                }
                text(line[c].replace(/parse\\\?sep/g, "|"), "multiline", false);
                quote = "";
                stack = [];
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</th>",
                    types: "end"
                }, "");
                c = c + 1;
            } while (c < d);
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</tr>",
                types: "end"
            }, "");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</thead>",
                types: "end"
            }, "");
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "<tbody>",
                types: "start"
            }, "tbody");
            a = a + 2;
            d = bar.length;
            do {
                if (lines[a] === "") {
                    break;
                }
                if ((/^(\s*>)/).test(lines[a]) === true) {
                    if (data.token[parse.count] === "<tbody>") {
                        parse.structure.pop();
                        parse.pop(data);
                    }
                    else {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "</tbody>",
                            types: "end"
                        }, "");
                    }
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</table>",
                        types: "end"
                    }, "");
                    return blockquote();
                }
                line = lines[a]
                    .replace(/^\|/, "")
                    .replace(/\|$/, "")
                    .replace(/\\\|/g, "parse\\?sep")
                    .split("|");
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "<tr>",
                    types: "start"
                }, "tr");
                c = 0;
                do {
                    if (line[c] === undefined) {
                        line[c] = "";
                    }
                    if (line[c] === " " && c === bar.length) {
                        break;
                    }
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "<td>",
                        types: "start"
                    }, "td");
                    if ((/:-+:/).test(bar[c]) === true) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "style=\"text-align:center\"",
                            types: "attribute"
                        }, "");
                    }
                    else if ((/:-+/).test(bar[c]) === true) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "style=\"text-align:left\"",
                            types: "attribute"
                        }, "");
                    }
                    else if ((/-+:/).test(bar[c]) === true) {
                        parse.push(data, {
                            begin: parse.structure[parse.structure.length - 1][1],
                            ender: -1,
                            lexer: "markdown",
                            lines: 0,
                            stack: parse.structure[parse.structure.length - 1][0],
                            token: "style=\"text-align:right\"",
                            types: "attribute"
                        }, "");
                    }
                    if (line[c] !== "") {
                        text(line[c].replace(/parse\\\?sep/g, "|"), "multiline", false);
                    }
                    quote = "";
                    stack = [];
                    parse.push(data, {
                        begin: parse.structure[parse.structure.length - 1][1],
                        ender: -1,
                        lexer: "markdown",
                        lines: 0,
                        stack: parse.structure[parse.structure.length - 1][0],
                        token: "</td>",
                        types: "end"
                    }, "");
                    c = c + 1;
                } while (c < d);
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</tr>",
                    types: "end"
                }, "");
                a = a + 1;
            } while (a < b);
            if (data.token[parse.count] === "<tbody>") {
                parse.structure.pop();
                parse.pop(data);
            }
            else {
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "markdown",
                    lines: 0,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: "</tbody>",
                    types: "end"
                }, "");
            }
            parse.push(data, {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markdown",
                lines: 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "</table>",
                types: "end"
            }, "");
        };
        b = lines.length;
        parse.push(data, {
            begin: parse.structure[parse.structure.length - 1][1],
            ender: -1,
            lexer: "markdown",
            lines: 0,
            stack: parse.structure[parse.structure.length - 1][0],
            token: "<body>",
            types: "start"
        }, "body");
        do {
            if ((/^(\s*)$/).test(lines[a]) === true) {
                if (lines[a - 1] === "") {
                    lines.splice(a, 1);
                    b = b - 1;
                    a = a - 1;
                }
                else {
                    lines[a] = "";
                }
            }
            else if ((/^(\s*(\*|-|\+|(\d{1,9}(\)|\.))))/).test(lines[a]) === true && lines[a].replace(/^(\s*(\*|-|\+|(\d{1,9}(\)|\.)))\s*)/, "") === "") {
                if ((/^(\u0020{2,})/).test(lines[a + 1]) === true) {
                    lines[a] = lines[a].replace(/(\s+)$/, "") + lines[a + 1].replace("  ", " ");
                    lines.splice(a + 1, 1);
                    b = b - 1;
                }
                else if ((/^(\t)/).test(lines[a + 1]) === true) {
                    lines[a] = lines[a].replace(/(\s+)$/, "") + lines[a + 1].replace("\t", " ");
                    lines.splice(a + 1, 1);
                    b = b - 1;
                }
            }
            a = a + 1;
        } while (a < b);
        a = 0;
        do {
            if (comtest(a) === true) {
                comment();
            }
            else if (codetest(a) === true) {
                if (codetest(a + 1) === true || (lines[a + 1] === "" && codetest(a + 2) === true)) {
                    codeblock(false, false, true);
                }
                else {
                    code(lines[a], "", true);
                }
            }
            else if (hrtest(a) === true) {
                hr();
            }
            else if ((/^(\s{0,3}>)/).test(lines[a]) === true) {
                blockquote();
            }
            else if ((/(((:-+)|(-+:)|(:-+:)|(-{2,}))\s*\|\s*)/).test(lines[a + 1]) === true) {
                table();
            }
            else if (codeblocktest(a) === true) {
                codeblock(true, false, false);
            }
            else if ((/^(\s*#{1,6}\s)/).test(lines[a]) === true) {
                heading();
            }
            else if (listtest(a) === true) {
                list();
            }
            else if (lines[a] !== "" && (/^(\s+)$/).test(lines[a]) === false) {
                parabuild();
            }
            a = a + 1;
        } while (a < b);
        parse.push(data, {
            begin: parse.structure[parse.structure.length - 1][1],
            ender: -1,
            lexer: "markdown",
            lines: 0,
            stack: parse.structure[parse.structure.length - 1][0],
            token: "</body>",
            types: "end"
        }, "");
        return data;
    };
    sparser.lexers.markdown = markdown;
}());
(function script_init() {
    
    const script = function lexer_script(source) {
        let a = 0, ltoke = "", ltype = "", lword = [], pword = [], lengthb = 0, wordTest = -1, paren = -1, funreferences = [], tempstore, pstack, comment;
        const parse = sparser.parse, data = parse.data, options = sparser.options, sourcemap = [
            0, ""
        ], references = parse.references, b = source.length, c = source.split(""), brace = [], classy = [], datatype = [false], 
        // identify variable declarations
        vart = {
            count: [],
            index: [],
            len: -1,
            word: []
        }, 
        // automatic semicolon insertion
        asi = function lexer_script_asi(isEnd) {
            let aa = 0;
            const next = nextchar(1, false), record = {
                begin: data.begin[parse.count],
                ender: data.begin[parse.count],
                lexer: data.lexer[parse.count],
                lines: data.lines[parse.count],
                stack: data.stack[parse.count],
                token: data.token[parse.count],
                types: data.types[parse.count]
            }, clist = (parse.structure.length === 0)
                ? ""
                : parse.structure[parse.structure.length - 1][0];
            if ((/^(\/(\/|\*)\s*parse-ignore\u002dstart)/).test(ltoke) === true) {
                return;
            }
            if (ltype === "start" || ltype === "type_start") {
                return;
            }
            if (options.language === "json" || options.language === "java" || options.language === "csharp") {
                return;
            }
            if (options.language === "json" || record.token === ";" || record.token === "," || next === "{" || record.stack === "class" || record.stack === "map" || record.stack === "attribute" || clist === "initializer" || data.types[record.begin - 1] === "generic") {
                return;
            }
            if (record.token === "}" && data.stack[record.begin - 1] === "global" && data.types[record.begin - 1] !== "operator" && record.stack === data.stack[parse.count - 1]) {
                return;
            }
            if (record.stack === "array" && record.token !== "]") {
                return;
            }
            if (data.token[data.begin[parse.count]] === "{" && record.stack === "data_type") {
                return;
            }
            if (record.types !== undefined && record.types.indexOf("template") > -1 && record.types.indexOf("template_string") < 0) {
                return;
            }
            if (next === ";" && isEnd === false) {
                return;
            }
            if (data.lexer[parse.count - 1] !== "script" && ((a < b && b === options.source.length - 1) || b < options.source.length - 1)) {
                return;
            }
            if (options.language === "qml") {
                if (record.types === "start") {
                    return;
                }
                ltoke = (options.correct === true)
                    ? ";"
                    : "x;";
                ltype = "separator";
                recordPush("");
                if (next !== "}") {
                    blockinsert();
                }
                return;
            }
            if (record.token === "}" && (record.stack === "function" || record.stack === "if" || record.stack === "else" || record.stack === "for" || record.stack === "do" || record.stack === "while" || record.stack === "switch" || record.stack === "class" || record.stack === "try" || record.stack === "catch" || record.stack === "finally" || record.stack === "block")) {
                if (record.stack === "function" && (data.stack[record.begin - 1] === "data_type" || data.types[record.begin - 1] === "type")) {
                    aa = record.begin;
                    do {
                        aa = aa - 1;
                    } while (aa > 0 && data.token[aa] !== ")" && data.stack[aa] !== "arguments");
                    aa = data.begin[aa];
                }
                else {
                    aa = data.begin[record.begin - 1];
                }
                if (data.token[aa] === "(") {
                    aa = aa - 1;
                    if (data.token[aa - 1] === "function") {
                        aa = aa - 1;
                    }
                    if (data.stack[aa - 1] === "object" || data.stack[aa - 1] === "switch") {
                        return;
                    }
                    if (data.token[aa - 1] !== "=" && data.token[aa - 1] !== "return" && data.token[aa - 1] !== ":") {
                        return;
                    }
                }
                else {
                    return;
                }
            }
            if (record.types === "comment" ||
                clist === "method" ||
                clist === "paren" ||
                clist === "expression" ||
                clist === "array" ||
                clist === "object" ||
                (clist === "switch" && record.stack !== "method" && data.token[data.begin[parse.count]] === "(" && data.token[data.begin[parse.count] - 1] !== "return" && data.types[data.begin[parse.count] - 1] !== "operator")) {
                return;
            }
            if (data.stack[parse.count] === "expression" && (data.token[data.begin[parse.count] - 1] !== "while" || (data.token[data.begin[parse.count] - 1] === "while" && data.stack[data.begin[parse.count] - 2] !== "do"))) {
                return;
            }
            if (next !== "" && "=<>+*?|^:&%~,.()]".indexOf(next) > -1 && isEnd === false) {
                return;
            }
            if (record.types === "comment") {
                aa = parse.count;
                do {
                    aa = aa - 1;
                } while (aa > 0 && data.types[aa] === "comment");
                if (aa < 1) {
                    return;
                }
                record.token = data.token[aa];
                record.types = data.types[aa];
                record.stack = data.stack[aa];
            }
            if (record.token === undefined || record.types === "start" || record.types === "separator" || (record.types === "operator" && record.token !== "++" && record.token !== "--") || record.token === "x}" || record.token === "var" || record.token === "let" || record.token === "const" || record.token === "else" || record.token.indexOf("#!/") === 0 || record.token === "instanceof") {
                return;
            }
            if (record.stack === "method" && (data.token[record.begin - 1] === "function" || data.token[record.begin - 2] === "function")) {
                return;
            }
            if (options.lexer_options.script.variable_list === "list") {
                vart.index[vart.len] = parse.count;
            }
            ltoke = (options.correct === true)
                ? ";"
                : "x;";
            ltype = "separator";
            aa = parse.linesSpace;
            parse.linesSpace = 0;
            recordPush("");
            parse.linesSpace = aa;
            blockinsert();
        }, 
        // fixes asi location if inserted after an inserted brace
        asibrace = function lexer_script_asibrace() {
            let aa = parse.count;
            do {
                aa = aa - 1;
            } while (aa > -1 && data.token[aa] === "x}");
            if (data.stack[aa] === "else") {
                return recordPush("");
            }
            aa = aa + 1;
            parse.splice({
                data: data,
                howmany: 0,
                index: aa,
                record: {
                    begin: data.begin[aa],
                    ender: -1,
                    lexer: "script",
                    lines: parse.linesSpace,
                    stack: data.stack[aa],
                    token: ltoke,
                    types: ltype
                }
            });
            recordPush("");
        }, 
        // cleans up improperly applied ASI
        asifix = function lexer_script_asifix() {
            let len = parse.count;
            if (data.types[len] === "comment") {
                do {
                    len = len - 1;
                } while (len > 0 && data.types[len] === "comment");
            }
            if (data.token[len] === "from") {
                len = len - 2;
            }
            if (data.token[len] === "x;") {
                parse.splice({ data: data, howmany: 1, index: len });
            }
        }, 
        // block comments
        blockComment = function lexer_script_blockComment() {
            asi(false);
            if (wordTest > -1) {
                word();
            }
            comment = parse.wrapCommentBlock({
                chars: c,
                end: b,
                lexer: "script",
                opening: "/*",
                start: a,
                terminator: "\u002a/"
            });
            a = comment[1];
            if (data.token[parse.count] === "var" || data.token[parse.count] === "let" || data.token[parse.count] === "const") {
                tempstore = parse.pop(data);
                recordPush("");
                parse.push(data, tempstore, "");
                if (data.lines[parse.count - 2] === 0) {
                    data.lines[parse.count - 2] = data.lines[parse.count];
                }
                data.lines[parse.count] = 0;
            }
            else if (comment[0] !== "") {
                ltoke = comment[0];
                ltype = (/^\/\*\s*parse-ignore-start/).test(ltoke)
                    ? "ignore"
                    : "comment";
                if (ltoke.indexOf("# sourceMappingURL=") === 2) {
                    sourcemap[0] = parse.count + 1;
                    sourcemap[1] = ltoke;
                }
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "script",
                    lines: parse.linesSpace,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: ltoke,
                    types: ltype
                }, "");
            }
            if ((/\/\*\s*global\s+/).test(data.token[parse.count]) === true && data.types.indexOf("word") < 0) {
                references[0] = data.token[parse.count].replace(/\/\*\s*global\s+/, "").replace("\u002a/", "").replace(/,\s+/g, ",").split(",");
            }
        }, 
        // inserts ending curly brace (where absent)
        blockinsert = function lexer_script_blockinsert() {
            let next = nextchar(5, false), name = "";
            const g = parse.count, lines = parse.linesSpace;
            if (options.language === "json" || brace.length < 1 || brace[brace.length - 1].charAt(0) !== "x" || (/^x?(;|\}|\))$/).test(ltoke) === false) {
                return;
            }
            if (data.stack[parse.count] === "do" && next === "while" && data.token[parse.count] === "}") {
                return;
            }
            if (ltoke === ";" && data.token[g - 1] === "x{") {
                name = data.token[data.begin[g - 2] - 1];
                if (data.token[g - 2] === "do" || (data.token[g - 2] === ")" && "ifforwhilecatch".indexOf(name) > -1)) {
                    tempstore = parse.pop(data);
                    ltoke = (options.correct === true)
                        ? "}"
                        : "x}";
                    ltype = "end";
                    pstack = parse.structure[parse.structure.length - 1];
                    recordPush("");
                    brace.pop();
                    parse.linesSpace = lines;
                    return;
                }
                // to prevent the semicolon from inserting between the braces --> while (x) {};
                tempstore = parse.pop(data);
                ltoke = (options.correct === true)
                    ? "}"
                    : "x}";
                ltype = "end";
                pstack = parse.structure[parse.structure.length - 1];
                recordPush("");
                brace.pop();
                ltoke = ";";
                ltype = "end";
                parse.push(data, tempstore, "");
                parse.linesSpace = lines;
                return;
            }
            ltoke = (options.correct === true)
                ? "}"
                : "x}";
            ltype = "end";
            if (data.token[parse.count] === "x}") {
                return;
            }
            if (data.stack[parse.count] === "if" && (data.token[parse.count] === ";" || data.token[parse.count] === "x;") && next === "else") {
                pstack = parse.structure[parse.structure.length - 1];
                recordPush("");
                brace.pop();
                parse.linesSpace = lines;
                return;
            }
            do {
                pstack = parse.structure[parse.structure.length - 1];
                recordPush("");
                brace.pop();
                if (data.stack[parse.count] === "do") {
                    break;
                }
            } while (brace[brace.length - 1] === "x{");
            parse.linesSpace = lines;
        }, 
        // commaComment ensures that commas immediately precede comments instead of
        // immediately follow
        commaComment = function lexer_script_commacomment() {
            let x = parse.count;
            if (data.stack[x] === "object" && options.lexer_options.script.object_sort === true) {
                ltoke = ",";
                ltype = "separator";
                asifix();
                recordPush("");
            }
            else {
                do {
                    x = x - 1;
                } while (x > 0 && data.types[x - 1] === "comment");
                parse.splice({
                    data: data,
                    howmany: 0,
                    index: x,
                    record: {
                        begin: data.begin[x],
                        ender: -1,
                        lexer: "script",
                        lines: parse.linesSpace,
                        stack: data.stack[x],
                        token: ",",
                        types: "separator"
                    }
                });
                recordPush("");
            }
        }, 
        // operations for end types: ), ], }
        end = function lexer_script_end(x) {
            let insert = false, newarr = false;
            const next = nextchar(1, false), count = (data.token[parse.count] === "(")
                ? parse.count
                : data.begin[parse.count], newarray = function lexer_script_end_newarray() {
                let arraylen = 0;
                const ar = (data.token[count - 1] === "Array"), startar = (ar === true)
                    ? "["
                    : "{", endar = (ar === true)
                    ? "]"
                    : "}", namear = (ar === true)
                    ? "array"
                    : "object";
                if (ar === true && data.types[parse.count] === "number") {
                    arraylen = Number(data.token[parse.count]);
                    tempstore = parse.pop(data);
                }
                tempstore = parse.pop(data);
                tempstore = parse.pop(data);
                tempstore = parse.pop(data);
                parse.structure.pop();
                ltoke = startar;
                ltype = "start";
                recordPush(namear);
                if (arraylen > 0) {
                    ltoke = ",";
                    ltype = "separator";
                    do {
                        recordPush("");
                        arraylen = arraylen - 1;
                    } while (arraylen > 0);
                }
                ltoke = endar;
                ltype = "end";
                recordPush("");
            };
            if (wordTest > -1) {
                word();
            }
            if (classy.length > 0) {
                if (classy[classy.length - 1] === 0) {
                    classy.pop();
                }
                else {
                    classy[classy.length - 1] = classy[classy.length - 1] - 1;
                }
            }
            if (x === ")" || x === "x)" || x === "]") {
                if (options.correct === true) {
                    plusplus();
                }
                asifix();
            }
            if (x === ")" || x === "x)") {
                asi(false);
            }
            if (vart.len > -1) {
                if (x === "}" && ((options.lexer_options.script.variable_list === "list" && vart.count[vart.len] === 0) || (data.token[parse.count] === "x;" && options.lexer_options.script.variable_list === "each"))) {
                    vartpop();
                }
                vart.count[vart.len] = vart.count[vart.len] - 1;
                if (vart.count[vart.len] < 0) {
                    vartpop();
                }
            }
            if (ltoke === "," && data.stack[parse.count] !== "initializer" && ((x === "]" && data.token[parse.count - 1] === "[") || x === "}")) {
                tempstore = parse.pop(data);
            }
            if (x === ")" || x === "x)") {
                ltoke = x;
                if (lword.length > 0) {
                    pword = lword[lword.length - 1];
                    if (pword.length > 1 && next !== "{" && (pword[0] === "if" || pword[0] === "for" || (pword[0] === "while" && data.stack[pword[1] - 2] !== undefined && data.stack[pword[1] - 2] !== "do") || pword[0] === "with")) {
                        insert = true;
                    }
                }
            }
            else if (x === "]") {
                ltoke = "]";
            }
            else if (x === "}") {
                if (ltoke !== "," && options.correct === true) {
                    plusplus();
                }
                if (parse.structure.length > 0 && parse.structure[parse.structure.length - 1][0] !== "object") {
                    asi(true);
                }
                if (options.lexer_options.script.object_sort === true && parse.structure[parse.structure.length - 1][0] === "object") {
                    parse.object_sort(data);
                }
                if (ltype === "comment") {
                    ltoke = data.token[parse.count];
                    ltype = data.types[parse.count];
                }
                ltoke = "}";
            }
            if (parse.structure[parse.structure.length - 1][0] === "data_type") {
                ltype = "type_end";
            }
            else {
                ltype = "end";
            }
            lword.pop();
            pstack = parse.structure[parse.structure.length - 1];
            if (x === ")" && options.correct === true && count - parse.count < 2 && (data.token[parse.count] === "(" || data.types[parse.count] === "number") && (data.token[count - 1] === "Array" || data.token[count - 1] === "Object") && data.token[count - 2] === "new") {
                newarray();
                newarr = true;
            }
            if (brace[brace.length - 1] === "x{" && x === "}") {
                blockinsert();
                brace.pop();
                if (data.stack[parse.count] !== "try") {
                    if (next !== ":" && next !== ";" && data.token[data.begin[a] - 1] !== "?") {
                        blockinsert();
                    }
                }
                ltoke = "}";
            }
            else {
                brace.pop();
            }
            // options.end_comma
            if (options.lexer_options.script.end_comma !== undefined && options.lexer_options.script.end_comma !== "none" && parse.structure[parse.structure.length - 1][0] === "array" || parse.structure[parse.structure.length - 1][0] === "object" || parse.structure[parse.structure.length - 1][0] === "data_type") {
                if (options.lexer_options.script.end_comma === "always" && data.token[parse.count] !== ",") {
                    const begin = parse.structure[parse.structure.length - 1][1];
                    let y = parse.count;
                    do {
                        if (data.begin[y] === begin) {
                            if (data.token[y] === ",") {
                                break;
                            }
                        }
                        else {
                            y = data.begin[y];
                        }
                        y = y - 1;
                    } while (y > begin);
                    if (y > begin) {
                        const type = ltype, toke = ltoke;
                        ltoke = ",";
                        ltype = "separator";
                        recordPush("");
                        ltoke = toke;
                        ltype = type;
                    }
                }
                else if (options.lexer_options.script.end_comma === "never" && data.token[parse.count] === ",") {
                    parse.pop(data);
                }
            }
            if (newarr === false) {
                recordPush("");
                if (ltoke === "}" && data.stack[parse.count] !== "object" && data.stack[parse.count] !== "class" && data.stack[parse.count] !== "data_type") {
                    references.pop();
                    blockinsert();
                }
            }
            if (insert === true) {
                ltoke = (options.correct === true)
                    ? "{"
                    : "x{";
                ltype = "start";
                recordPush(pword[0]);
                brace.push("x{");
                pword[1] = parse.count;
            }
            datatype.pop();
            if (parse.structure[parse.structure.length - 1][0] !== "data_type") {
                datatype[datatype.length - 1] = false;
            }
        }, 
        // the general function is a generic tokenizer start argument contains the
        // token's starting syntax offset argument is length of start minus control
        // chars end is how is to identify where the token ends
        general = function lexer_script_general(starting, ending, type) {
            let ee = 0, escape = false, ext = false, build = [starting], ender = ending.split(""), temp;
            const endlen = ender.length, start = a, qc = (options.lexer_options.script.quote_convert === undefined)
                ? "none"
                : options.lexer_options.script.quote_convert, base = a + starting.length, cleanUp = function lexer_script_general_cleanUp() {
                let linesSpace = 0;
                build = [];
                ltype = type;
                ee = a;
                if (type === "string" && (/\s/).test(c[ee + 1]) === true) {
                    linesSpace = 1;
                    do {
                        ee = ee + 1;
                        if (c[ee] === "\n") {
                            linesSpace = linesSpace + 1;
                        }
                    } while (ee < b && (/\s/).test(c[ee + 1]) === true);
                    parse.linesSpace = linesSpace;
                }
            }, finish = function lexer_script_general_finish() {
                let str = "";
                //pads certain template tag delimiters with a space
                const bracketSpace = function lexer_script_general_finish_bracketSpace(input) {
                    if (options.language !== "javascript" && options.language !== "typescript" && options.language !== "jsx" && options.language !== "tsx") {
                        const spaceStart = function lexer_script_general_finish_bracketSpace_spaceStart(start) {
                            return start.replace(/\s*$/, " ");
                        }, spaceEnd = function lexer_script_general_finish_bracketSpace_spaceStart(end) {
                            return end.replace(/^\s*/, " ");
                        };
                        if ((/\{(#|\/|(%>)|(%\]))/).test(input) === true || (/\}%(>|\])/).test(input) === true) {
                            return input;
                        }
                        input = input.replace(/\{((\{+)|%-?)\s*/g, spaceStart);
                        input = input.replace(/\s*((\}\}+)|(-?%\}))/g, spaceEnd);
                        return input;
                    }
                    return input;
                };
                if (starting === "\"" && qc === "single") {
                    build[0] = "'";
                    build[build.length - 1] = "'";
                }
                else if (starting === "'" && qc === "double") {
                    build[0] = "\"";
                    build[build.length - 1] = "\"";
                }
                else if (escape === true) {
                    str = build[build.length - 1];
                    build.pop();
                    build.pop();
                    build.push(str);
                }
                a = ee;
                if (ending === "\n") {
                    a = a - 1;
                    build.pop();
                }
                ltoke = build.join("");
                if (starting === "\"" || starting === "'" || starting === "{{" || starting === "{%" || starting === "{{{") {
                    ltoke = bracketSpace(ltoke);
                }
                if (starting === "{%" || starting === "{{") {
                    temp = tname(ltoke);
                    ltype = temp[0];
                    recordPush(temp[1]);
                    return;
                }
                if (type === "string") {
                    ltype = "string";
                    if (options.language === "json") {
                        ltoke = ltoke
                            .replace(/\u0000/g, "\\u0000")
                            .replace(/\u0001/g, "\\u0001")
                            .replace(/\u0002/g, "\\u0002")
                            .replace(/\u0003/g, "\\u0003")
                            .replace(/\u0004/g, "\\u0004")
                            .replace(/\u0005/g, "\\u0005")
                            .replace(/\u0006/g, "\\u0006")
                            .replace(/\u0007/g, "\\u0007")
                            .replace(/\u0008/g, "\\u0008")
                            .replace(/\u0009/g, "\\u0009")
                            .replace(/\u000a/g, "\\u000a")
                            .replace(/\u000b/g, "\\u000b")
                            .replace(/\u000c/g, "\\u000c")
                            .replace(/\u000d/g, "\\u000d")
                            .replace(/\u000e/g, "\\u000e")
                            .replace(/\u000f/g, "\\u000f")
                            .replace(/\u0010/g, "\\u0010")
                            .replace(/\u0011/g, "\\u0011")
                            .replace(/\u0012/g, "\\u0012")
                            .replace(/\u0013/g, "\\u0013")
                            .replace(/\u0014/g, "\\u0014")
                            .replace(/\u0015/g, "\\u0015")
                            .replace(/\u0016/g, "\\u0016")
                            .replace(/\u0017/g, "\\u0017")
                            .replace(/\u0018/g, "\\u0018")
                            .replace(/\u0019/g, "\\u0019")
                            .replace(/\u001a/g, "\\u001a")
                            .replace(/\u001b/g, "\\u001b")
                            .replace(/\u001c/g, "\\u001c")
                            .replace(/\u001d/g, "\\u001d")
                            .replace(/\u001e/g, "\\u001e")
                            .replace(/\u001f/g, "\\u001f");
                    }
                    else if (starting.indexOf("#!") === 0) {
                        ltoke = ltoke.slice(0, ltoke.length - 1);
                        parse.linesSpace = 2;
                    }
                    else if (parse.structure[parse.structure.length - 1][0] !== "object" || (parse.structure[parse.structure.length - 1][0] === "object" && nextchar(1, false) !== ":" && data.token[parse.count] !== "," && data.token[parse.count] !== "{")) {
                        if ((ltoke.length > options.wrap && options.wrap > 0) || (options.wrap !== 0 && data.token[parse.count] === "+" && (data.token[parse.count - 1].charAt(0) === "\"" || data.token[parse.count - 1].charAt(0) === "'"))) {
                            let item = ltoke, q = (qc === "double")
                                ? "\""
                                : (qc === "single")
                                    ? "'"
                                    : item.charAt(0), segment = "";
                            const limit = options.wrap, uchar = (/u[0-9a-fA-F]{4}/), xchar = (/x[0-9a-fA-F]{2}/);
                            item = item.slice(1, item.length - 1);
                            if (data.token[parse.count] === "+" && (data.token[parse.count - 1].charAt(0) === "\"" || data.token[parse.count - 1].charAt(0) === "'")) {
                                parse.pop(data);
                                q = data.token[parse.count].charAt(0);
                                item = data.token[parse.count].slice(1, data.token[parse.count].length - 1) + item;
                                parse.pop(data);
                            }
                            if (item.length > limit && limit > 0) {
                                do {
                                    segment = item.slice(0, limit);
                                    if (segment.charAt(limit - 5) === "\\" && uchar.test(item.slice(limit - 4, limit + 1)) === true) {
                                        segment = segment.slice(0, limit - 5);
                                    }
                                    else if (segment.charAt(limit - 4) === "\\" && uchar.test(item.slice(limit - 3, limit + 2)) === true) {
                                        segment = segment.slice(0, limit - 4);
                                    }
                                    else if (segment.charAt(limit - 3) === "\\" && (uchar.test(item.slice(limit - 2, limit + 3)) === true || xchar.test(item.slice(limit - 2, limit + 1)) === true)) {
                                        segment = segment.slice(0, limit - 3);
                                    }
                                    else if (segment.charAt(limit - 2) === "\\" && (uchar.test(item.slice(limit - 1, limit + 4)) === true || xchar.test(item.slice(limit - 1, limit + 2)) === true)) {
                                        segment = segment.slice(0, limit - 2);
                                    }
                                    else if (segment.charAt(limit - 1) === "\\") {
                                        segment = segment.slice(0, limit - 1);
                                    }
                                    segment = q + segment + q;
                                    item = item.slice(segment.length - 2);
                                    ltoke = segment;
                                    ltype = "string";
                                    recordPush("");
                                    parse.linesSpace = 0;
                                    ltoke = "+";
                                    ltype = "operator";
                                    recordPush("");
                                } while (item.length > limit);
                            }
                            if (item === "") {
                                ltoke = q + q;
                            }
                            else {
                                ltoke = q + item + q;
                            }
                            ltype = "string";
                        }
                    }
                }
                else if ((/\{\s*\?>$/).test(ltoke) === true) {
                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                        ltype = "template_else";
                    }
                    else {
                        ltype = "template_start";
                    }
                }
                else if ((/^<\?(=|(php))\s*\}/).test(ltoke) === true) {
                    if ((/^<\?(=|(php))\s*\}\s*else/).test(ltoke) === true) {
                        ltype = "template_else";
                    }
                    else {
                        ltype = "template_end";
                    }
                }
                else {
                    ltype = type;
                }
                if (ltoke.length > 0) {
                    recordPush("");
                }
            };
            if (wordTest > -1) {
                word();
            }
            // this insanity is for JSON where all the required quote characters are
            // escaped.
            if (c[a - 1] === "\\" && slashes(a - 1) === true && (c[a] === "\"" || c[a] === "'")) {
                parse.pop(data);
                if (data.token[0] === "{") {
                    if (c[a] === "\"") {
                        starting = "\"";
                        ending = "\\\"";
                        build = ["\""];
                    }
                    else {
                        starting = "'";
                        ending = "\\'";
                        build = ["'"];
                    }
                    escape = true;
                }
                else {
                    if (c[a] === "\"") {
                        build = ["\\\""];
                        finish();
                        return;
                    }
                    build = ["\\'"];
                    finish();
                    return;
                }
            }
            ee = base;
            if (ee < b) {
                do {
                    if (data.token[0] !== "{" && data.token[0] !== "[" && qc !== "none" && (c[ee] === "\"" || c[ee] === "'")) {
                        if (c[ee - 1] === "\\") {
                            if (slashes(ee - 1) === true) {
                                if (qc === "double" && c[ee] === "'") {
                                    build.pop();
                                }
                                else if (qc === "single" && c[ee] === "\"") {
                                    build.pop();
                                }
                            }
                        }
                        else if (qc === "double" && c[ee] === "\"" && c[a] === "'") {
                            c[ee] = "\\\"";
                        }
                        else if (qc === "single" && c[ee] === "'" && c[a] === "\"") {
                            c[ee] = "\\'";
                        }
                        build.push(c[ee]);
                    }
                    else if (ee > start) {
                        ext = true;
                        if (c[ee] === "<" && c[ee + 1] === "?" && c[ee + 2] === "p" && c[ee + 3] === "h" && c[ee + 4] === "p" && c[ee + 5] !== starting) {
                            finish();
                            // php
                            lexer_script_general("<?php", "?>", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "<" && c[ee + 1] === "?" && c[ee + 2] === "=" && c[ee + 3] !== starting) {
                            finish();
                            // php
                            lexer_script_general("<?=", "?>", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "<" && c[ee + 1] === "%" && c[ee + 2] !== starting) {
                            finish();
                            // asp
                            lexer_script_general("<%", "%>", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "{" && c[ee + 1] === "%" && c[ee + 2] !== starting) {
                            finish();
                            // twig
                            lexer_script_general("{%", "%}", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] === "{" && c[ee + 3] !== starting) {
                            finish();
                            // mustache
                            lexer_script_general("{{{", "}}}", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "{" && c[ee + 1] === "{" && c[ee + 2] !== starting) {
                            finish();
                            // handlebars
                            lexer_script_general("{{", "}}", "template");
                            cleanUp();
                        }
                        else if (c[ee] === "<" && c[ee + 1] === "!" && c[ee + 2] === "-" && c[ee + 3] === "-" && c[ee + 4] === "#" && c[ee + 5] !== starting) {
                            finish();
                            // ssi
                            lexer_script_general("<!--#", "-->", "template");
                            cleanUp();
                        }
                        else {
                            ext = false;
                            build.push(c[ee]);
                        }
                    }
                    else {
                        build.push(c[ee]);
                    }
                    if ((starting === "\"" || starting === "'") && (ext === true || ee > start) && options.language !== "json" && c[ee - 1] !== "\\" && c[ee] !== "\"" && c[ee] !== "'" && (c[ee] === "\n" || ee === b - 1)) {
                        sparser.parseerror = "Unterminated string in script on line number " + parse.lineNumber;
                        break;
                    }
                    if (c[ee] === ender[endlen - 1] && (c[ee - 1] !== "\\" || slashes(ee - 1) === false)) {
                        if (endlen === 1) {
                            break;
                        }
                        // `ee - base` is a cheap means of computing length of build array the `ee -
                        // base` and `endlen` are both length based values, so adding two (1 for each)
                        // provides an index based number
                        if (build[ee - base] === ender[0] && build.slice(ee - base - endlen + 2).join("") === ending) {
                            break;
                        }
                    }
                    ee = ee + 1;
                } while (ee < b);
            }
            finish();
        }, 
        // line comments
        lineComment = function lexer_script_lineComment() {
            asi(false);
            blockinsert();
            if (wordTest > -1) {
                word();
            }
            comment = parse.wrapCommentLine({
                chars: c,
                end: b,
                lexer: "script",
                opening: "//",
                start: a,
                terminator: "\n"
            });
            a = comment[1];
            if (comment[0] !== "") {
                ltoke = comment[0];
                ltype = (/^(\/\/\s*parse-ignore-start)/).test(ltoke)
                    ? "ignore"
                    : "comment";
                if (ltoke.indexOf("# sourceMappingURL=") === 2) {
                    sourcemap[0] = parse.count + 1;
                    sourcemap[1] = ltoke;
                }
                parse.push(data, {
                    begin: parse.structure[parse.structure.length - 1][1],
                    ender: -1,
                    lexer: "script",
                    lines: parse.linesSpace,
                    stack: parse.structure[parse.structure.length - 1][0],
                    token: ltoke,
                    types: ltype
                }, "");
            }
        }, 
        // Identifies blocks of markup embedded within JavaScript for language super sets
        // like React JSX.
        markup = function lexer_script_markup() {
            let curlytest = false, endtag = false, anglecount = 0, curlycount = 0, tagcount = 0, d = 0, next = "", priorToken = "", priorType = "", output = [];
            const dt = datatype[datatype.length - 1], syntaxnum = "0123456789=<>+-*?|^:&.,;%(){}[]~", applyMarkup = function lexer_script_markup_applyMarkup() {
                if (ltoke === "(") {
                    parse.structure[parse.structure.length - 1] = ["paren", parse.count];
                }
                sparser.lexers.markup(output.join(""));
            };
            if (wordTest > -1) {
                word();
            }
            // type generics tokenizer
            priorToken = (parse.count > 0)
                ? data.token[parse.count - 1]
                : "";
            priorType = (parse.count > 0)
                ? data.types[parse.count - 1]
                : "";
            next = nextchar(1, false);
            if (options.language !== "jsx" && options.language !== "tsx" && (/\d/).test(next) === false && (ltoke === "function" ||
                priorToken === "=>" ||
                priorToken === "void" ||
                priorToken === "." ||
                data.stack[parse.count] === "arguments" ||
                ((options.language === "csharp" || options.language === "java") && priorToken === "public" || priorToken === "private" || priorToken === "final" || priorToken === "static") ||
                (ltype === "type" && priorToken === "type") ||
                (ltype === "reference" && (priorType === "operator" || priorToken === "function" || priorToken === "class" || priorToken === "new")) ||
                (ltype === "type" && priorType === "operator") ||
                ltoke === "return" ||
                ltype === "operator")) {
                let inc = 0, e = 0;
                const build = [];
                d = a;
                do {
                    build.push(c[d]);
                    if (c[d] === "<") {
                        inc = inc + 1;
                    }
                    else if (c[d] === ">") {
                        inc = inc - 1;
                        if (inc < 1) {
                            break;
                        }
                    }
                    d = d + 1;
                } while (d < b);
                e = a;
                a = d;
                next = nextchar(1, false);
                if (c[d] === ">" && (dt === true || priorToken === "=>" || priorToken === "." || priorType !== "operator" || (priorType === "operator" && (next === "(" || next === "=")))) {
                    ltype = "generic";
                    ltoke = build.join("").replace(/^<\s+/, "<").replace(/\s+>$/, ">").replace(/,\s*/g, ", ");
                    recordPush("");
                    return;
                }
                a = e;
            }
            d = parse.count;
            if (data.types[d] === "comment") {
                do {
                    d = d - 1;
                } while (d > 0 && data.types[d] === "comment");
            }
            if (dt === false &&
                nextchar(1, false) !== ">" && ((c[a] !== "<" && syntaxnum.indexOf(c[a + 1]) > -1) ||
                data.token[d] === "++" ||
                data.token[d] === "--" ||
                (/\s/).test(c[a + 1]) === true ||
                ((/\d/).test(c[a + 1]) === true &&
                    (ltype === "operator" ||
                        ltype === "string" ||
                        ltype === "number" ||
                        ltype === "reference" ||
                        (ltype === "word" && ltoke !== "return"))))) {
                ltype = "operator";
                ltoke = operator();
                return recordPush("");
            }
            if (options.language !== "typescript" && options.language !== "flow" && (data.token[d] === "return" || data.types[d] === "operator" || data.types[d] === "start" || data.types[d] === "separator" || data.types[d] === "jsx_attribute_start" || (data.token[d] === "}" && parse.structure[parse.structure.length - 1][0] === "global"))) {
                ltype = "markup";
                options.language = "jsx";
                do {
                    output.push(c[a]);
                    if (c[a] === "{") {
                        curlycount = curlycount + 1;
                        curlytest = true;
                    }
                    else if (c[a] === "}") {
                        curlycount = curlycount - 1;
                        if (curlycount === 0) {
                            curlytest = false;
                        }
                    }
                    else if (c[a] === "<" && curlytest === false) {
                        if (c[a + 1] === "<") {
                            do {
                                output.push(c[a]);
                                a = a + 1;
                            } while (a < b && c[a + 1] === "<");
                        }
                        anglecount = anglecount + 1;
                        if (nextchar(1, false) === "/") {
                            endtag = true;
                        }
                    }
                    else if (c[a] === ">" && curlytest === false) {
                        if (c[a + 1] === ">") {
                            do {
                                output.push(c[a]);
                                a = a + 1;
                            } while (c[a + 1] === ">");
                        }
                        anglecount = anglecount - 1;
                        if (endtag === true) {
                            tagcount = tagcount - 1;
                        }
                        else if (c[a - 1] !== "/") {
                            tagcount = tagcount + 1;
                        }
                        if (anglecount === 0 && curlycount === 0 && tagcount < 1) {
                            next = nextchar(2, false);
                            if (next.charAt(0) !== "<") {
                                // if followed by nonmarkup
                                return applyMarkup();
                            }
                            // catch additional trailing tag sets
                            if (next.charAt(0) === "<" && syntaxnum.indexOf(next.charAt(1)) < 0 && (/\s/).test(next.charAt(1)) === false) {
                                // perform a minor safety test to verify if "<" is a tag start or a less than
                                // operator
                                d = a + 1;
                                do {
                                    d = d + 1;
                                    if (c[d] === ">" || ((/\s/).test(c[d - 1]) === true && syntaxnum.indexOf(c[d]) < 0)) {
                                        break;
                                    }
                                    if (syntaxnum.indexOf(c[d]) > -1) {
                                        // if followed by additional markup tags
                                        return applyMarkup();
                                    }
                                } while (d < b);
                            }
                            else {
                                // if a nonmarkup "<" follows markup
                                return applyMarkup();
                            }
                        }
                        endtag = false;
                    }
                    a = a + 1;
                } while (a < b);
                return applyMarkup();
            }
            ltype = "operator";
            ltoke = operator();
            recordPush("");
            return;
        }, 
        // peek at whats up next
        nextchar = function lexer_script_nextchar(len, current) {
            let cc = (current === true)
                ? a
                : a + 1, dd = "";
            if (typeof len !== "number" || len < 1) {
                len = 1;
            }
            if (c[a] === "/") {
                if (c[a + 1] === "/") {
                    dd = "\n";
                }
                else if (c[a + 1] === "*") {
                    dd = "/";
                }
            }
            if (cc < b) {
                do {
                    if ((/\s/).test(c[cc]) === false) {
                        if (c[cc] === "/") {
                            if (dd === "") {
                                if (c[cc + 1] === "/") {
                                    dd = "\n";
                                }
                                else if (c[cc + 1] === "*") {
                                    dd = "/";
                                }
                            }
                            else if (dd === "/" && c[cc - 1] === "*") {
                                dd = "";
                            }
                        }
                        if (dd === "" && c[cc - 1] + c[cc] !== "\u002a/") {
                            return c
                                .slice(cc, cc + len)
                                .join("");
                        }
                    }
                    else if (dd === "\n" && c[cc] === "\n") {
                        dd = "";
                    }
                    cc = cc + 1;
                } while (cc < b);
            }
            return "";
        }, 
        // a tokenizer for numbers
        numb = function lexer_script_number() {
            const f = b, build = [c[a]];
            let ee = 0, test = /zz/, dot = (build[0] === ".");
            if (a < b - 2 && c[a] === "0") {
                if (c[a + 1] === "x") {
                    test = /[0-9a-fA-F]/;
                }
                else if (c[a + 1] === "o") {
                    test = /[0-9]/;
                }
                else if (c[a + 1] === "b") {
                    test = /0|1/;
                }
                if (test.test(c[a + 2]) === true) {
                    build.push(c[a + 1]);
                    ee = a + 1;
                    do {
                        ee = ee + 1;
                        build.push(c[ee]);
                    } while (test.test(c[ee + 1]) === true);
                    a = ee;
                    return build.join("");
                }
            }
            ee = a + 1;
            if (ee < f) {
                do {
                    if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {
                        build.push(c[ee]);
                        if (c[ee] === ".") {
                            dot = true;
                        }
                    }
                    else {
                        break;
                    }
                    ee = ee + 1;
                } while (ee < f);
            }
            if (ee < f - 1 && ((/\d/).test(c[ee - 1]) === true || ((/\d/).test(c[ee - 2]) === true && (c[ee - 1] === "-" || c[ee - 1] === "+"))) && (c[ee] === "e" || c[ee] === "E")) {
                build.push(c[ee]);
                if (c[ee + 1] === "-" || c[ee + 1] === "+") {
                    build.push(c[ee + 1]);
                    ee = ee + 1;
                }
                dot = false;
                ee = ee + 1;
                if (ee < f) {
                    do {
                        if ((/[0-9]/).test(c[ee]) || (c[ee] === "." && dot === false)) {
                            build.push(c[ee]);
                            if (c[ee] === ".") {
                                dot = true;
                            }
                        }
                        else {
                            break;
                        }
                        ee = ee + 1;
                    } while (ee < f);
                }
            }
            a = ee - 1;
            return build.join("");
        }, 
        // a unique tokenizer for operator characters
        operator = function lexer_script_operator() {
            let g = 0, h = 0, jj = b, output = "";
            const syntax = [
                "=",
                "<",
                ">",
                "+",
                "*",
                "?",
                "|",
                "^",
                ":",
                "&",
                "%",
                "~"
            ], synlen = syntax.length;
            if (wordTest > -1) {
                word();
            }
            if (c[a] === "/" && (parse.count > -1 && ((ltype !== "word" && ltype !== "reference") || ltoke === "typeof" || ltoke === "return" || ltoke === "else") && ltype !== "number" && ltype !== "string" && ltype !== "end")) {
                if (ltoke === "return" || ltoke === "typeof" || ltoke === "else" || ltype !== "word") {
                    ltoke = regex();
                    ltype = "regex";
                }
                else {
                    ltoke = "/";
                    ltype = "operator";
                }
                recordPush("");
                return "regex";
            }
            if (c[a] === "?" && ("+-\u002a/.?".indexOf(c[a + 1]) > -1 || (c[a + 1] === ":" && syntax.join("").indexOf(c[a + 2]) < 0))) {
                if (c[a + 1] === "." && (/\d/).test(c[a + 2]) === false) {
                    output = "?.";
                }
                else if (c[a + 1] === "?") {
                    output = "??";
                }
                if (output === "") {
                    return "?";
                }
            }
            if (c[a] === ":" && "+-\u002a/".indexOf(c[a + 1]) > -1) {
                return ":";
            }
            if (a < b - 1) {
                if (c[a] !== "<" && c[a + 1] === "<") {
                    return c[a];
                }
                if (c[a] === "!" && c[a + 1] === "/") {
                    return "!";
                }
                if (c[a] === "-") {
                    datatype[datatype.length - 1] = false;
                    if (c[a + 1] === "-") {
                        output = "--";
                    }
                    else if (c[a + 1] === "=") {
                        output = "-=";
                    }
                    else if (c[a + 1] === ">") {
                        output = "->";
                    }
                    if (output === "") {
                        return "-";
                    }
                }
                if (c[a] === "+") {
                    datatype[datatype.length - 1] = false;
                    if (c[a + 1] === "+") {
                        output = "++";
                    }
                    else if (c[a + 1] === "=") {
                        output = "+=";
                    }
                    if (output === "") {
                        return "+";
                    }
                }
                if (c[a] === "=" && c[a + 1] !== "=" && c[a + 1] !== "!" && c[a + 1] !== ">") {
                    datatype[datatype.length - 1] = false;
                    return "=";
                }
            }
            if (c[a] === ":") {
                if (options.language === "typescript" || options.language === "flow") {
                    if (data.stack[parse.count] === "arguments") {
                        if (data.token[parse.count] === "?") {
                            parse.pop(data);
                            output = "?:";
                            a = a - 1;
                        }
                        datatype[datatype.length - 1] = true;
                    }
                    else if (ltoke === ")" && (data.token[data.begin[parse.count] - 1] === "function" || data.token[data.begin[parse.count] - 2] === "function")) {
                        datatype[datatype.length - 1] = true;
                    }
                    else if (ltype === "reference") {
                        g = parse.count;
                        let colon = false;
                        do {
                            if (data.begin[g] === data.begin[parse.count]) {
                                if (g < parse.count && data.token[g] === ":" && data.types[g + 1] !== "type") {
                                    colon = true;
                                }
                                if (data.token[g] === "?" && colon === false) {
                                    break;
                                }
                                if (data.token[g] === ";" || data.token[g] === "x;") {
                                    break;
                                }
                                if (data.token[g] === "var" || data.token[g] === "let" || data.token[g] === "const" || data.types[g] === "type") {
                                    datatype[datatype.length - 1] = true;
                                    break;
                                }
                            }
                            else {
                                if (data.types[g] === "type_end") {
                                    datatype[datatype.length - 1] = true;
                                    break;
                                }
                                g = data.begin[g];
                            }
                            g = g - 1;
                        } while (g > data.begin[parse.count]);
                    }
                }
                else if ((data.types[parse.count] === "word" || data.types[parse.count] === "reference") && data.token[parse.count - 1] === "[") {
                    parse.structure[parse.structure.length - 1][0] = "attribute";
                    data.stack[parse.count] = "attribute";
                }
            }
            if (output === "") {
                if ((c[a + 1] === "+" && c[a + 2] === "+") || (c[a + 1] === "-" && c[a + 2] === "-")) {
                    output = c[a];
                }
                else {
                    const buildout = [c[a]];
                    g = a + 1;
                    if (g < jj) {
                        do {
                            if ((c[g] === "+" && c[g + 1] === "+") || (c[g] === "-" && c[g + 1] === "-")) {
                                break;
                            }
                            h = 0;
                            if (h < synlen) {
                                do {
                                    if (c[g] === syntax[h]) {
                                        buildout.push(syntax[h]);
                                        break;
                                    }
                                    h = h + 1;
                                } while (h < synlen);
                            }
                            if (h === synlen) {
                                break;
                            }
                            g = g + 1;
                        } while (g < jj);
                    }
                    output = buildout.join("");
                }
            }
            a = a + (output.length - 1);
            if (output === "=>" && ltoke === ")") {
                g = parse.count;
                jj = data.begin[g];
                do {
                    if (data.begin[g] === jj) {
                        data.stack[g] = "method";
                    }
                    g = g - 1;
                } while (g > jj - 1);
            }
            return output;
        }, 
        // convert ++ and -- into "= x +"  and "= x -" in most cases
        plusplus = function lexer_script_plusplus() {
            let pre = true, toke = "+", tokea = "", tokeb = "", tokec = "", inc = 0, ind = 0, walk = 0, next = "";
            const store = [], end = function lexer_script_plusplus_end() {
                walk = data.begin[walk] - 1;
                if (data.types[walk] === "end") {
                    lexer_script_plusplus_end();
                }
                else if (data.token[walk - 1] === ".") {
                    period();
                }
            }, period = function lexer_script_plusplus_period() {
                walk = walk - 2;
                if (data.types[walk] === "end") {
                    end();
                }
                else if (data.token[walk - 1] === ".") {
                    lexer_script_plusplus_period();
                }
            }, applyStore = function lexer_script_plusplus_applyStore() {
                let x = 0;
                const y = store.length;
                if (x < y) {
                    do {
                        parse.push(data, store[x], "");
                        x = x + 1;
                    } while (x < y);
                }
            }, recordStore = function lexer_script_plusplus_recordStore(index) {
                return {
                    begin: data.begin[index],
                    ender: data.ender[index],
                    lexer: data.lexer[index],
                    lines: data.lines[index],
                    stack: data.stack[index],
                    token: data.token[index],
                    types: data.types[index]
                };
            };
            tokea = data.token[parse.count];
            tokeb = data.token[parse.count - 1];
            tokec = data.token[parse.count - 2];
            if (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--") {
                walk = parse.count;
                if (data.types[walk] === "end") {
                    end();
                }
                else if (data.token[walk - 1] === ".") {
                    period();
                }
            }
            if (data.token[walk - 1] === "++" || data.token[walk - 1] === "--") {
                if ("startendoperator".indexOf(data.types[walk - 2]) > -1) {
                    return;
                }
                inc = walk;
                if (inc < parse.count + 1) {
                    do {
                        store.push(recordStore(inc));
                        inc = inc + 1;
                    } while (inc < parse.count + 1);
                    parse.splice({
                        data: data,
                        howmany: parse.count - walk,
                        index: walk
                    });
                }
            }
            else {
                if (options.correct === false || (tokea !== "++" && tokea !== "--" && tokeb !== "++" && tokeb !== "--")) {
                    return;
                }
                next = nextchar(1, false);
                if ((tokea === "++" || tokea === "--") && (c[a] === ";" || next === ";" || c[a] === "}" || next === "}" || c[a] === ")" || next === ")")) {
                    toke = data.stack[parse.count];
                    if (toke === "array" || toke === "method" || toke === "object" || toke === "paren" || toke === "notation" || (data.token[data.begin[parse.count] - 1] === "while" && toke !== "while")) {
                        return;
                    }
                    inc = parse.count;
                    do {
                        inc = inc - 1;
                        if (data.token[inc] === "return") {
                            return;
                        }
                        if (data.types[inc] === "end") {
                            do {
                                inc = data.begin[inc] - 1;
                            } while (data.types[inc] === "end" && inc > 0);
                        }
                    } while (inc > 0 && (data.token[inc] === "." || data.types[inc] === "word" || data.types[inc] === "reference" || data.types[inc] === "end"));
                    if (data.token[inc] === "," && c[a] !== ";" && next !== ";" && c[a] !== "}" && next !== "}" && c[a] !== ")" && next !== ")") {
                        return;
                    }
                    if (data.types[inc] === "operator") {
                        if (data.stack[inc] === "switch" && data.token[inc] === ":") {
                            do {
                                inc = inc - 1;
                                if (data.types[inc] === "start") {
                                    ind = ind - 1;
                                    if (ind < 0) {
                                        break;
                                    }
                                }
                                else if (data.types[inc] === "end") {
                                    ind = ind + 1;
                                }
                                if (data.token[inc] === "?" && ind === 0) {
                                    return;
                                }
                            } while (inc > 0);
                        }
                        else {
                            return;
                        }
                    }
                    pre = false;
                    if (tokea === "--") {
                        toke = "-";
                    }
                    else {
                        toke = "+";
                    }
                }
                else if (tokec === "[" || tokec === ";" || tokec === "x;" || tokec === "}" || tokec === "{" || tokec === "(" || tokec === ")" || tokec === "," || tokec === "return") {
                    if (tokea === "++" || tokea === "--") {
                        if (tokec === "[" || tokec === "(" || tokec === "," || tokec === "return") {
                            return;
                        }
                        if (tokea === "--") {
                            toke = "-";
                        }
                        pre = false;
                    }
                    else if (tokeb === "--" || tokea === "--") {
                        toke = "-";
                    }
                }
                else {
                    return;
                }
                if (pre === false) {
                    tempstore = parse.pop(data);
                }
                walk = parse.count;
                if (data.types[walk] === "end") {
                    end();
                }
                else if (data.token[walk - 1] === ".") {
                    period();
                }
                inc = walk;
                if (inc < parse.count + 1) {
                    do {
                        store.push(recordStore(inc));
                        inc = inc + 1;
                    } while (inc < parse.count + 1);
                }
            }
            if (pre === true) {
                parse.splice({
                    data: data,
                    howmany: 1,
                    index: walk - 1
                });
                ltoke = "=";
                ltype = "operator";
                recordPush("");
                applyStore();
                ltoke = toke;
                ltype = "operator";
                recordPush("");
                ltoke = "1";
                ltype = "number";
                recordPush("");
            }
            else {
                ltoke = "=";
                ltype = "operator";
                recordPush("");
                applyStore();
                ltoke = toke;
                ltype = "operator";
                recordPush("");
                ltoke = "1";
                ltype = "number";
                recordPush("");
            }
            ltoke = data.token[parse.count];
            ltype = data.types[parse.count];
            if (next === "}" && c[a] !== ";") {
                asi(false);
            }
        }, 
        // determine the definition of containment by stack
        recordPush = function lexer_script_recordPush(structure) {
            const record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "script",
                lines: parse.linesSpace,
                stack: parse.structure[parse.structure.length - 1][0],
                token: ltoke,
                types: ltype
            };
            parse.push(data, record, structure);
        }, 
        // a tokenizer for regular expressions
        regex = function lexer_script_regex() {
            let ee = a + 1, h = 0, i = 0, output = "", square = false;
            const f = b, build = ["/"];
            if (ee < f) {
                do {
                    build.push(c[ee]);
                    if (c[ee - 1] !== "\\" || c[ee - 2] === "\\") {
                        if (c[ee] === "[") {
                            square = true;
                        }
                        if (c[ee] === "]") {
                            square = false;
                        }
                    }
                    if (c[ee] === "/" && square === false) {
                        if (c[ee - 1] === "\\") {
                            i = 0;
                            h = ee - 1;
                            if (h > 0) {
                                do {
                                    if (c[h] === "\\") {
                                        i = i + 1;
                                    }
                                    else {
                                        break;
                                    }
                                    h = h - 1;
                                } while (h > 0);
                            }
                            if (i % 2 === 0) {
                                break;
                            }
                        }
                        else {
                            break;
                        }
                    }
                    ee = ee + 1;
                } while (ee < f);
            }
            if (c[ee + 1] === "g" || c[ee + 1] === "i" || c[ee + 1] === "m" || c[ee + 1] === "y" || c[ee + 1] === "u") {
                build.push(c[ee + 1]);
                if (c[ee + 2] !== c[ee + 1] && (c[ee + 2] === "g" || c[ee + 2] === "i" || c[ee + 2] === "m" || c[ee + 2] === "y" || c[ee + 2] === "u")) {
                    build.push(c[ee + 2]);
                    if (c[ee + 3] !== c[ee + 1] && c[ee + 3] !== c[ee + 2] && (c[ee + 3] === "g" || c[ee + 3] === "i" || c[ee + 3] === "m" || c[ee + 3] === "y" || c[ee + 3] === "u")) {
                        build.push(c[ee + 3]);
                        if (c[ee + 4] !== c[ee + 1] && c[ee + 4] !== c[ee + 2] && c[ee + 4] !== c[ee + 3] && (c[ee + 4] === "g" || c[ee + 4] === "i" || c[ee + 4] === "m" || c[ee + 4] === "y" || c[ee + 4] === "u")) {
                            build.push(c[ee + 4]);
                            if (c[ee + 5] !== c[ee + 1] && c[ee + 5] !== c[ee + 2] && c[ee + 5] !== c[ee + 3] && c[ee + 5] !== c[ee + 4] && (c[ee + 5] === "g" || c[ee + 5] === "i" || c[ee + 5] === "m" || c[ee + 5] === "y" || c[ee + 5] === "u")) {
                                build.push(c[ee + 4]);
                                a = ee + 5;
                            }
                            else {
                                a = ee + 4;
                            }
                        }
                        else {
                            a = ee + 3;
                        }
                    }
                    else {
                        a = ee + 2;
                    }
                }
                else {
                    a = ee + 1;
                }
            }
            else {
                a = ee;
            }
            output = build.join("");
            return output;
        }, 
        // determines if a slash comprises a valid escape or if it is escaped itself
        slashes = function lexer_script_slashes(index) {
            const slashy = index;
            do {
                index = index - 1;
            } while (c[index] === "\\" && index > 0);
            if ((slashy - index) % 2 === 1) {
                return true;
            }
            return false;
        }, 
        // operations for start types: (, [, {
        start = function lexer_script_start(x) {
            let aa = parse.count, wordx = "", wordy = "", stack = "", func = false;
            brace.push(x);
            if (x === "{" && (data.types[parse.count] === "type" || data.types[parse.count] === "type_end" || data.types[parse.count] === "generic")) {
                // this block determines if a function body follows a type annotation
                let begin = 0;
                if (data.types[parse.count] === "type_end") {
                    aa = data.begin[parse.count];
                }
                begin = aa;
                do {
                    aa = aa - 1;
                    if (data.begin[aa] !== begin && data.begin[aa] !== -1) {
                        break;
                    }
                    if (data.token[aa] === ":") {
                        break;
                    }
                } while (aa > data.begin[aa]);
                if (data.token[aa] === ":" && data.stack[aa - 1] === "arguments") {
                    datatype.push(false);
                    func = true;
                }
                else {
                    datatype.push(datatype[datatype.length - 1]);
                }
                aa = parse.count;
            }
            else if (x === "[" && data.types[parse.count] === "type_end") {
                datatype.push(true);
            }
            else {
                datatype.push(datatype[datatype.length - 1]);
            }
            if (wordTest > -1) {
                word();
                aa = parse.count;
            }
            if (vart.len > -1) {
                vart.count[vart.len] = vart.count[vart.len] + 1;
            }
            if (data.token[aa - 1] === "function") {
                lword.push([
                    "function", aa + 1
                ]);
            }
            else {
                lword.push([
                    ltoke, aa + 1
                ]);
            }
            ltoke = x;
            if (datatype[datatype.length - 1] === true) {
                ltype = "type_start";
            }
            else {
                ltype = "start";
            }
            if (x === "(" || x === "x(") {
                asifix();
            }
            else if (x === "{") {
                if (paren > -1) {
                    if (data.begin[paren - 1] === data.begin[data.begin[aa] - 1] || data.token[data.begin[aa]] === "x(") {
                        paren = -1;
                        if (options.correct === true) {
                            end(")");
                        }
                        else {
                            end("x)");
                        }
                        asifix();
                        ltoke = "{";
                        ltype = "start";
                    }
                }
                else if (ltoke === ")") {
                    asifix();
                }
                if (ltype === "comment" && data.token[aa - 1] === ")") {
                    ltoke = data.token[aa];
                    data.token[aa] = "{";
                    ltype = data.types[aa];
                    data.types[aa] = "start";
                }
            }
            wordx = (function lexer_script_start_wordx() {
                let bb = parse.count;
                if (data.types[bb] === "comment") {
                    do {
                        bb = bb - 1;
                    } while (bb > 0 && data.types[bb] === "comment");
                }
                return data.token[bb];
            }());
            wordy = (data.stack[aa] === undefined)
                ? ""
                : (function lexer_script_start_wordy() {
                    let bb = parse.count;
                    if (data.types[bb] === "comment") {
                        do {
                            bb = bb - 1;
                        } while (bb > 0 && data.types[bb] === "comment");
                    }
                    return data.token[data.begin[bb] - 1];
                }());
            if (ltoke === "{" && (data.types[aa] === "word" || data.token[aa] === "]")) {
                let bb = aa;
                if (data.token[bb] === "]") {
                    do {
                        bb = data.begin[bb] - 1;
                    } while (data.token[bb] === "]");
                }
                do {
                    if (data.types[bb] === "start" || data.types[bb] === "end" || data.types[bb] === "operator") {
                        break;
                    }
                    bb = bb - 1;
                } while (bb > 0);
                if (data.token[bb] === ":" && data.stack[bb - 1] === "arguments") {
                    stack = "function";
                    references.push(funreferences);
                    funreferences = [];
                }
            }
            if (ltype === "type_start") {
                stack = "data_type";
            }
            else if (stack === "" && (ltoke === "{" || ltoke === "x{")) {
                if (wordx === "else" || wordx === "do" || wordx === "try" || wordx === "finally" || wordx === "switch") {
                    stack = wordx;
                }
                else if (classy[classy.length - 1] === 0 && wordx !== "return") {
                    classy.pop();
                    stack = "class";
                }
                else if (data.token[aa - 1] === "class") {
                    stack = "class";
                }
                else if (data.token[aa] === "]" && data.token[aa - 1] === "[") {
                    stack = "array";
                }
                else if ((data.types[aa] === "word" || data.types[aa] === "reference") &&
                    (data.types[aa - 1] === "word" ||
                        data.types[aa - 1] === "reference" ||
                        (data.token[aa - 1] === "?" && (data.types[aa - 2] === "word" || data.types[aa - 2] === "reference"))) &&
                    data.token[aa] !== "in" &&
                    data.token[aa - 1] !== "export" &&
                    data.token[aa - 1] !== "import") {
                    stack = "map";
                }
                else if (data.stack[aa] === "method" &&
                    data.types[aa] === "end" &&
                    (data.types[data.begin[aa] - 1] === "word" || data.types[data.begin[aa] - 1] === "reference") &&
                    data.token[data.begin[aa] - 2] === "new") {
                    stack = "initializer";
                }
                else if (ltoke === "{" &&
                    (wordx === ")" || wordx === "x)") &&
                    (data.types[data.begin[aa] - 1] === "word" || data.types[data.begin[aa] - 1] === "reference" || data.token[data.begin[aa] - 1] === "]")) {
                    if (wordy === "if") {
                        stack = "if";
                    }
                    else if (wordy === "for") {
                        stack = "for";
                    }
                    else if (wordy === "while") {
                        stack = "while";
                    }
                    else if (wordy === "class") {
                        stack = "class";
                    }
                    else if (wordy === "switch" || data.token[data.begin[aa] - 1] === "switch") {
                        stack = "switch";
                    }
                    else if (wordy === "catch") {
                        stack = "catch";
                    }
                    else {
                        stack = "function";
                    }
                }
                else if (ltoke === "{" && (wordx === ";" || wordx === "x;")) {
                    // ES6 block
                    stack = "block";
                }
                else if (ltoke === "{" && data.token[aa] === ":" && data.stack[aa] === "switch") {
                    // ES6 block
                    stack = "block";
                }
                else if (data.token[aa - 1] === "import" || data.token[aa - 2] === "import" || data.token[aa - 1] === "export" || data.token[aa - 2] === "export") {
                    stack = "object";
                }
                else if (wordx === ")" && (pword[0] === "function" || pword[0] === "if" || pword[0] === "for" || pword[0] === "class" || pword[0] === "while" || pword[0] === "switch" || pword[0] === "catch")) {
                    // if preceeded by a paren the prior containment is preceeded by a keyword if
                    // (...) {
                    stack = pword[0];
                }
                else if (data.stack[aa] === "notation") {
                    // if following a TSX array type declaration
                    stack = "function";
                }
                else if ((data.types[aa] === "number" ||
                    data.types[aa] === "string" ||
                    data.types[aa] === "word" ||
                    data.types[aa] === "reference") &&
                    (data.types[aa - 1] === "word" || data.types[aa - 1] === "reference") &&
                    data.token[data.begin[aa] - 1] !== "for") {
                    // if preceed by a word and either string or word public class {
                    stack = "function";
                }
                else if (parse.structure.length > 0 && data.token[aa] !== ":" && parse.structure[parse.structure.length - 1][0] === "object" && (data.token[data.begin[aa] - 2] === "{" || data.token[data.begin[aa] - 2] === ",")) {
                    // if an object wrapped in some containment which is itself preceeded by a curly
                    // brace or comma var a={({b:{cat:"meow"}})};
                    stack = "function";
                }
                else if (data.types[pword[1] - 1] === "markup" && data.token[pword[1] - 3] === "function") {
                    // checking for TSX function using an angle brace name
                    stack = "function";
                }
                else if (wordx === "=>") {
                    // checking for fat arrow assignment
                    stack = "function";
                }
                else if (func === true || (data.types[parse.count] === "type_end" && data.stack[data.begin[parse.count] - 2] === "arguments")) {
                    // working around typescript inline interface
                    stack = "function";
                }
                else if (wordx === ")" &&
                    data.stack[aa] === "method" &&
                    (data.types[data.begin[aa] - 1] === "word" || data.types[data.begin[aa] - 1] === "property" || data.types[data.begin[aa] - 1] === "reference")) {
                    stack = "function";
                }
                else if (data.types[aa] === "word" && ltoke === "{" && data.token[aa] !== "return" && data.token[aa] !== "in" && data.token[aa] !== "import" && data.token[aa] !== "const" && data.token[aa] !== "let" && data.token[aa] !== "") {
                    // ES6 block
                    stack = "block";
                }
                else if (ltoke === "{" && (data.token[aa] === "x}" || data.token[aa] === "}") && "if|else|for|while|function|class|switch|catch|finally".indexOf(data.stack[aa]) > -1) {
                    // ES6 block
                    stack = "block";
                }
                else if (data.stack[aa] === "arguments") {
                    stack = "function";
                }
                else if (data.types[aa] === "generic") {
                    do {
                        aa = aa - 1;
                        if (data.token[aa] === "function" || data.stack[aa] === "arguments") {
                            stack = "function";
                            break;
                        }
                        if (data.token[aa] === "interface") {
                            stack = "map";
                            break;
                        }
                        if (data.token[aa] === ";") {
                            stack = "object";
                            break;
                        }
                    } while (aa > data.begin[parse.count]);
                }
                else if ((options.language === "java" || options.language === "csharp") && data.types[parse.count - 1] === "reference" && data.token[parse.count - 2] === "]") {
                    stack = "array";
                }
                else {
                    stack = "object";
                }
                if (stack !== "object" && stack !== "class") {
                    if (stack === "function") {
                        references.push(funreferences);
                        funreferences = [];
                    }
                    else {
                        references.push([]);
                    }
                }
            }
            else if (ltoke === "[") {
                if ((/\s/).test(c[a - 1]) === true && (data.types[aa] === "word" || data.types[aa] === "reference") && wordx !== "return" && options.language !== "twig") {
                    stack = "notation";
                }
                else {
                    stack = "array";
                }
            }
            else if (ltoke === "(" || ltoke === "x(") {
                if (wordx === "function" || data.token[aa - 1] === "function" || data.token[aa - 1] === "function*" || data.token[aa - 2] === "function") {
                    stack = "arguments";
                }
                else if (data.token[aa - 1] === "." || data.token[data.begin[aa] - 2] === ".") {
                    stack = "method";
                }
                else if (data.types[aa] === "generic") {
                    stack = "method";
                }
                else if (data.token[aa] === "}" && data.stack[aa] === "function") {
                    stack = "method";
                }
                else if (wordx === "if" || wordx === "for" || wordx === "class" || wordx === "while" || wordx === "catch" || wordx === "finally" || wordx === "switch" || wordx === "with") {
                    stack = "expression";
                }
                else if (data.types[aa] === "word" || data.types[aa] === "property" || data.types[aa] === "reference") {
                    stack = "method";
                }
                else {
                    stack = "paren";
                }
            }
            recordPush(stack);
            if (classy.length > 0) {
                classy[classy.length - 1] = classy[classy.length - 1] + 1;
            }
        }, 
        // ES6 template string support
        tempstring = function lexer_script_tempstring() {
            const output = [c[a]];
            a = a + 1;
            if (a < b) {
                do {
                    output.push(c[a]);
                    if (c[a] === "`" && (c[a - 1] !== "\\" || slashes(a - 1) === false)) {
                        break;
                    }
                    if (c[a - 1] === "$" && c[a] === "{" && (c[a - 2] !== "\\" || slashes(a - 2) === false)) {
                        break;
                    }
                    a = a + 1;
                } while (a < b);
            }
            return output.join("");
        }, 
        // determines tag names for {% %} based template tags and returns a type
        tname = function lexer_script_tname(x) {
            let sn = 2, en = 0, name = "";
            const st = x.slice(0, 2), len = x.length, namelist = [
                "autoescape",
                "block",
                "capture",
                "case",
                "comment",
                "embed",
                "filter",
                "for",
                "form",
                "if",
                "macro",
                "paginate",
                "raw",
                "sandbox",
                "spaceless",
                "tablerow",
                "unless",
                "verbatim"
            ];
            if (x.charAt(2) === "-") {
                sn = sn + 1;
            }
            if ((/\s/).test(x.charAt(sn)) === true) {
                do {
                    sn = sn + 1;
                } while ((/\s/).test(x.charAt(sn)) === true && sn < len);
            }
            en = sn;
            do {
                en = en + 1;
            } while ((/\s/).test(x.charAt(en)) === false && x.charAt(en) !== "(" && en < len);
            if (en === len) {
                en = x.length - 2;
            }
            name = x.slice(sn, en);
            if (name === "else" || (st === "{%" && (name === "elseif" || name === "when" || name === "elif"))) {
                return ["template_else", `template_${name}`];
            }
            if (st === "{{") {
                if (name === "end") {
                    return ["template_end", ""];
                }
                if ((name === "block" && (/\{%\s*\w/).test(source) === false) || name === "define" || name === "form" || name === "if" || name === "range" || name === "with") {
                    return ["template_start", `template_${name}`];
                }
                return ["template", ""];
            }
            en = namelist.length - 1;
            if (en > -1) {
                do {
                    if (name === namelist[en] && (name !== "block" || (/\{%\s*\w/).test(source) === false)) {
                        return ["template_start", `template_${name}`];
                    }
                    if (name === "end" + namelist[en]) {
                        return ["template_end", ""];
                    }
                    en = en - 1;
                } while (en > -1);
            }
            return ["template", ""];
        }, 
        // remove "vart" object data
        vartpop = function lexer_script_vartpop() {
            vart
                .count
                .pop();
            vart
                .index
                .pop();
            vart
                .word
                .pop();
            vart.len = vart.len - 1;
        }, 
        // A lexer for keywords, reserved words, and variables
        word = function lexer_script_word() {
            let f = wordTest, g = 1, output = "", nextitem = "", tokel = ltoke, typel = ltype;
            const lex = [], elsefix = function lexer_script_word_elsefix() {
                brace.push("x{");
                parse.splice({
                    data: data,
                    howmany: 1,
                    index: parse.count - 3
                });
            }, hoisting = function lexer_script_word_hoisting(index, ref, samescope) {
                const begin = data.begin[index];
                let parent = 0;
                do {
                    if (data.token[index] === ref && data.types[index] === "word") {
                        if (samescope === true) {
                            // the simple state is for hoisted references, var and function declarations
                            data.types[index] = "reference";
                        }
                        else if (data.begin[index] > begin && data.token[data.begin[index]] === "{" && data.stack[index] !== "object" && data.stack[index] !== "class" && data.stack[index] !== "data_type") {
                            // the complex state is for non-hoisted references living in prior functions of the same parent scope
                            if (data.stack[index] === "function") {
                                data.types[index] = "reference";
                            }
                            else {
                                // this looping is necessary to determine if there is a function between the reference and the declared scope
                                parent = data.begin[index];
                                do {
                                    if (data.stack[parent] === "function") {
                                        data.types[index] = "reference";
                                        break;
                                    }
                                    parent = data.begin[parent];
                                } while (parent > begin);
                            }
                        }
                    }
                    index = index - 1;
                } while (index > begin);
            };
            do {
                lex.push(c[f]);
                if (c[f] === "\\") {
                    sparser.parseerror = `Illegal escape in JavaScript on line number ${parse.lineNumber}`;
                }
                f = f + 1;
            } while (f < a);
            if (ltoke.charAt(0) === "\u201c") {
                sparser.parseerror = `Quote looking character (\u201c, \\u201c) used instead of actual quotes on line number ${parse.lineNumber}`;
            }
            else if (ltoke.charAt(0) === "\u201d") {
                sparser.parseerror = `Quote looking character (\u201d, \\u201d) used instead of actual quotes on line number ${parse.lineNumber}`;
            }
            output = lex.join("");
            wordTest = -1;
            if (parse.count > 0 && output === "function" && data.token[parse.count] === "(" && (data.token[parse.count - 1] === "{" || data.token[parse.count - 1] === "x{")) {
                data.types[parse.count] = "start";
            }
            if (parse.count > 1 && output === "function" && ltoke === "(" && (data.token[parse.count - 1] === "}" || data.token[parse.count - 1] === "x}")) {
                if (data.token[parse.count - 1] === "}") {
                    f = parse.count - 2;
                    if (f > -1) {
                        do {
                            if (data.types[f] === "end") {
                                g = g + 1;
                            }
                            else if (data.types[f] === "start" || data.types[f] === "end") {
                                g = g - 1;
                            }
                            if (g === 0) {
                                break;
                            }
                            f = f - 1;
                        } while (f > -1);
                    }
                    if (data.token[f] === "{" && data.token[f - 1] === ")") {
                        g = 1;
                        f = f - 2;
                        if (f > -1) {
                            do {
                                if (data.types[f] === "end") {
                                    g = g + 1;
                                }
                                else if (data.types[f] === "start" || data.types[f] === "end") {
                                    g = g - 1;
                                }
                                if (g === 0) {
                                    break;
                                }
                                f = f - 1;
                            } while (f > -1);
                        }
                        if (data.token[f - 1] !== "function" && data.token[f - 2] !== "function") {
                            data.types[parse.count] = "start";
                        }
                    }
                }
                else {
                    data.types[parse.count] = "start";
                }
            }
            if (options.correct === true && (output === "Object" || output === "Array") && c[a + 1] === "(" && c[a + 2] === ")" && data.token[parse.count - 1] === "=" && data.token[parse.count] === "new") {
                if (output === "Object") {
                    data.token[parse.count] = "{";
                    ltoke = "}";
                    data.stack[parse.count] = "object";
                    parse.structure[parse.structure.length - 1][0] = "object";
                }
                else {
                    data.token[parse.count] = "[";
                    ltoke = "]";
                    data.stack[parse.count] = "array";
                    parse.structure[parse.structure.length - 1][0] = "array";
                }
                data.types[parse.count] = "start";
                ltype = "end";
                c[a + 1] = "";
                c[a + 2] = "";
                a = a + 2;
            }
            else {
                g = parse.count;
                f = g;
                if (options.lexer_options.script.variable_list !== "none" && (output === "var" || output === "let" || output === "const")) {
                    if (data.types[g] === "comment") {
                        do {
                            g = g - 1;
                        } while (g > 0 && (data.types[g] === "comment"));
                    }
                    if (options.lexer_options.script.variable_list === "list" && vart.len > -1 && vart.index[vart.len] === g && output === vart.word[vart.len]) {
                        ltoke = ",";
                        ltype = "separator";
                        data.token[g] = ltoke;
                        data.types[g] = ltype;
                        vart.count[vart.len] = 0;
                        vart.index[vart.len] = g;
                        vart.word[vart.len] = output;
                        return;
                    }
                    vart.len = vart.len + 1;
                    vart
                        .count
                        .push(0);
                    vart
                        .index
                        .push(g);
                    vart
                        .word
                        .push(output);
                    g = f;
                }
                else if (vart.len > -1 && output !== vart.word[vart.len] && parse.count === vart.index[vart.len] && data.token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && options.lexer_options.script.variable_list === "list") {
                    vartpop();
                }
                if (output === "from" && data.token[parse.count] === "x;" && data.token[parse.count - 1] === "}") {
                    asifix();
                }
                if (output === "while" && data.token[parse.count] === "x;" && data.token[parse.count - 1] === "}") {
                    let d = 0, e = parse.count - 2;
                    if (e > -1) {
                        do {
                            if (data.types[e] === "end") {
                                d = d + 1;
                            }
                            else if (data.types[e] === "start") {
                                d = d - 1;
                            }
                            if (d < 0) {
                                if (data.token[e] === "{" && data.token[e - 1] === "do") {
                                    asifix();
                                }
                                return;
                            }
                            e = e - 1;
                        } while (e > -1);
                    }
                }
                if (typel === "comment") {
                    let d = parse.count;
                    do {
                        d = d - 1;
                    } while (d > 0 && data.types[d] === "comment");
                    typel = data.types[d];
                    tokel = data.token[d];
                }
                nextitem = nextchar(2, false);
                if (output === "void") {
                    if (tokel === ":" && data.stack[parse.count - 1] === "arguments") {
                        ltype = "type";
                    }
                    else {
                        ltype = "word";
                    }
                }
                else if ((options.language === "java" || options.language === "csharp") && output === "static") {
                    ltype = "word";
                }
                else if ((parse.structure[parse.structure.length - 1][0] === "object" ||
                    parse.structure[parse.structure.length - 1][0] === "class" ||
                    parse.structure[parse.structure.length - 1][0] === "data_type") && (data.token[parse.count] === "{" ||
                    (data.token[data.begin[parse.count]] === "{" && data.token[parse.count] === ",") ||
                    (data.types[parse.count] === "template_end" && (data.token[data.begin[parse.count] - 1] === "{" || data.token[data.begin[parse.count] - 1] === ",")))) {
                    if (output === "return" || output === "break") {
                        ltype = "word";
                    }
                    else {
                        ltype = "property";
                    }
                }
                else if (datatype[datatype.length - 1] === true || ((options.language === "typescript" || options.language === "flow") && tokel === "type")) {
                    ltype = "type";
                }
                else if ((options.language === "java" || options.language === "csharp") && (tokel === "public" || tokel === "private" || tokel === "static" || tokel === "final")) {
                    ltype = "reference";
                }
                else if ((options.language === "java" || options.language === "csharp") && ltoke !== "var" && (ltype === "end" || ltype === "word") && nextitem.charAt(0) === "=" && nextitem.charAt(1) !== "=") {
                    ltype = "reference";
                }
                else if (references.length > 0 && (tokel === "function" || tokel === "class" || tokel === "const" || tokel === "let" || tokel === "var" || tokel === "new" || tokel === "void")) {
                    ltype = "reference";
                    references[references.length - 1].push(output);
                    if (options.language === "javascript" || options.language === "jsx" || options.language === "typescript" || options.language === "flow") {
                        if (tokel === "var" || (tokel === "function" && data.types[parse.count - 1] !== "operator" && data.types[parse.count - 1] !== "start" && data.types[parse.count - 1] !== "end")) {
                            hoisting(parse.count, output, true);
                        }
                        else {
                            hoisting(parse.count, output, false);
                        }
                    }
                    else {
                        hoisting(parse.count, output, false);
                    }
                }
                else if (parse.structure[parse.structure.length - 1][0] === "arguments" && ltype !== "operator") {
                    ltype = "reference";
                    funreferences.push(output);
                }
                else if (tokel === "," && data.stack[parse.count] !== "method" && (data.stack[parse.count] !== "expression" || data.token[data.begin[parse.count] - 1] === "for")) {
                    let d = parse.count;
                    const e = parse.structure[parse.structure.length - 1][1];
                    do {
                        if (data.begin[d] === e) {
                            if (data.token[d] === ";") {
                                break;
                            }
                            if (data.token[d] === "var" || data.token[d] === "let" || data.token[d] === "const" || data.token[d] === "type") {
                                break;
                            }
                        }
                        else if (data.types[d] === "end") {
                            d = data.begin[d];
                        }
                        d = d - 1;
                    } while (d > e);
                    if (references.length > 0 && data.token[d] === "var") {
                        ltype = "reference";
                        references[references.length - 1].push(output);
                        if (options.language === "javascript" || options.language === "jsx" || options.language === "typescript" || options.language === "flow") {
                            hoisting(d, output, true);
                        }
                        else {
                            hoisting(d, output, false);
                        }
                    }
                    else if (references.length > 0 && (data.token[d] === "let" || data.token[d] === "const" || (data.token[d] === "type" && (options.language === "typescript" || options.language === "flow")))) {
                        ltype = "reference";
                        references[references.length - 1].push(output);
                        hoisting(d, output, false);
                    }
                    else {
                        ltype = "word";
                    }
                }
                else if (parse.structure[parse.structure.length - 1][0] !== "object" || (parse.structure[parse.structure.length - 1][0] === "object" && ltoke !== "," && ltoke !== "{")) {
                    let d = references.length, e = 0;
                    if (d > 0) {
                        do {
                            d = d - 1;
                            e = references[d].length;
                            if (e > 0) {
                                do {
                                    e = e - 1;
                                    if (output === references[d][e]) {
                                        break;
                                    }
                                } while (e > 0);
                                if (output === references[d][e]) {
                                    break;
                                }
                            }
                        } while (d > 0);
                        if (references[d][e] === output && tokel !== ".") {
                            ltype = "reference";
                        }
                        else {
                            ltype = "word";
                        }
                    }
                    else {
                        ltype = "word";
                    }
                }
                else {
                    ltype = "word";
                }
                ltoke = output;
                if (output === "from" && data.token[parse.count] === "}") {
                    asifix();
                }
            }
            recordPush("");
            if (output === "class") {
                classy.push(0);
            }
            if (output === "do") {
                nextitem = nextchar(1, true);
                if (nextitem !== "{") {
                    ltoke = (options.correct === true)
                        ? "{"
                        : "x{";
                    ltype = "start";
                    brace.push("x{");
                    recordPush("do");
                }
            }
            if (output === "else") {
                nextitem = nextchar(2, true);
                let x = parse.count - 1;
                if (data.types[x] === "comment") {
                    do {
                        x = x - 1;
                    } while (x > 0 && data.types[x] === "comment");
                }
                if (data.token[x] === "x}") {
                    if (data.token[parse.count] === "else") {
                        if (data.stack[parse.count - 1] !== "if" && data.types[parse.count - 1] !== "comment" && data.stack[parse.count - 1] !== "else") {
                            brace.pop();
                            parse.splice({
                                data: data,
                                howmany: 0,
                                index: parse.count - 1,
                                record: {
                                    begin: data.begin[data.begin[data.begin[parse.count - 1] - 1] - 1],
                                    ender: -1,
                                    lexer: "script",
                                    lines: 0,
                                    stack: "if",
                                    token: (options.correct === true)
                                        ? "}"
                                        : "x}",
                                    types: "end"
                                }
                            });
                            if (parse.structure.length > 1) {
                                parse.structure.splice(parse.structure.length - 2, 1);
                                parse.structure[parse.structure.length - 1][1] = parse.count;
                            }
                        }
                        else if (data.token[parse.count - 2] === "x}" && pstack[0] !== "if" && data.stack[parse.count] === "else") {
                            elsefix();
                        }
                        else if (data.token[parse.count - 2] === "}" && data.stack[parse.count - 2] === "if" && pstack[0] === "if" && data.token[pstack[1] - 1] !== "if" && data.token[data.begin[parse.count - 1]] === "x{") {
                            // fixes when "else" is following a block that isn't "if"
                            elsefix();
                        }
                    }
                    else if (data.token[parse.count] === "x}" && data.stack[parse.count] === "if") {
                        elsefix();
                    }
                }
                if (nextitem !== "if" && nextitem.charAt(0) !== "{") {
                    ltoke = (options.correct === true)
                        ? "{"
                        : "x{";
                    ltype = "start";
                    brace.push("x{");
                    recordPush("else");
                }
            }
            if ((output === "for" || output === "if" || output === "switch" || output === "catch") && options.language !== "twig" && data.token[parse.count - 1] !== ".") {
                nextitem = nextchar(1, true);
                if (nextitem !== "(") {
                    paren = parse.count;
                    if (options.correct === true) {
                        start("(");
                    }
                    else {
                        start("x(");
                    }
                }
            }
        };
        do {
            if ((/\s/).test(c[a]) === true) {
                if (wordTest > -1) {
                    word();
                }
                a = parse.spacer({ array: c, end: b, index: a });
                if (parse.linesSpace > 1 && ltoke !== ";" && lengthb < parse.count && c[a + 1] !== "}") {
                    asi(false);
                    lengthb = parse.count;
                }
            }
            else if (c[a] === "<" && c[a + 1] === "?" && c[a + 2] === "p" && c[a + 3] === "h" && c[a + 4] === "p") {
                // php
                general("<?php", "?>", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "?" && c[a + 2] === "=") {
                // php
                general("<?=", "?>", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "%") {
                // asp
                general("<%", "%>", "template");
            }
            else if (c[a] === "{" && c[a + 1] === "%") {
                // twig
                general("{%", "%}", "template");
            }
            else if (c[a] === "{" && c[a + 1] === "{" && c[a + 2] === "{") {
                // mustache
                general("{{{", "}}}", "template");
            }
            else if (c[a] === "{" && c[a + 1] === "{") {
                // handlebars
                general("{{", "}}", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-" && c[a + 4] === "#") {
                // ssi
                general("<!--#", "-->", "template");
            }
            else if (c[a] === "<" && c[a + 1] === "!" && c[a + 2] === "-" && c[a + 3] === "-") {
                // markup comment
                general("<!--", "-->", "comment");
            }
            else if (c[a] === "<") {
                // markup
                markup();
            }
            else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "*")) {
                // comment block
                blockComment();
            }
            else if ((parse.count < 0 || data.lines[parse.count] > 0) && c[a] === "#" && c[a + 1] === "!" && (c[a + 2] === "/" || c[a + 2] === "[")) {
                // shebang
                general("#!" + c[a + 2], "\n", "string");
            }
            else if (c[a] === "/" && (a === b - 1 || c[a + 1] === "/")) {
                // comment line
                lineComment();
            }
            else if (c[a] === "#" && c[a + 1] === "r" && c[a + 2] === "e" && c[a + 3] === "g" && c[a + 4] === "i" && c[a + 5] === "o" && c[a + 6] === "n" && (/\s/).test(c[a + 7]) === true) {
                // comment line
                asi(false);
                general("#region", "\n", "comment");
            }
            else if (c[a] === "#" && c[a + 1] === "e" && c[a + 2] === "n" && c[a + 3] === "d" && c[a + 4] === "r" && c[a + 5] === "e" && c[a + 6] === "g" && c[a + 7] === "i" && c[a + 8] === "o" && c[a + 9] === "n") {
                // comment line
                asi(false);
                general("#endregion", "\n", "comment");
            }
            else if (c[a] === "`" || (c[a] === "}" && parse.structure[parse.structure.length - 1][0] === "template_string")) {
                // template string
                if (wordTest > -1) {
                    word();
                }
                ltoke = tempstring();
                if (ltoke.charAt(0) === "}" && ltoke.slice(ltoke.length - 2) === "${") {
                    ltype = "template_string_else";
                    recordPush("template_string");
                }
                else if (ltoke.slice(ltoke.length - 2) === "${") {
                    ltype = "template_string_start";
                    recordPush("template_string");
                }
                else if (ltoke.charAt(0) === "}") {
                    ltype = "template_string_end";
                    recordPush("");
                }
                else {
                    ltype = "string";
                    recordPush("");
                }
            }
            else if (c[a] === "\"" || c[a] === "'") {
                // string
                general(c[a], c[a], "string");
            }
            else if (c[a] === "-" &&
                (a < b - 1 && c[a + 1] !== "=" && c[a + 1] !== "-") &&
                (ltype === "number" || ltype === "word" || ltype === "reference") &&
                ltoke !== "return" &&
                (ltoke === ")" || ltoke === "]" || ltype === "word" || ltype === "reference" || ltype === "number")) {
                // subtraction
                if (wordTest > -1) {
                    word();
                }
                ltoke = "-";
                ltype = "operator";
                recordPush("");
            }
            else if (wordTest === -1 && (c[a] !== "0" || (c[a] === "0" && c[a + 1] !== "b")) && ((/\d/).test(c[a]) || (a !== b - 2 && c[a] === "-" && c[a + 1] === "." && (/\d/).test(c[a + 2])) || (a !== b - 1 && (c[a] === "-" || c[a] === ".") && (/\d/).test(c[a + 1])))) {
                // number
                if (wordTest > -1) {
                    word();
                }
                if (ltype === "end" && c[a] === "-") {
                    ltoke = "-";
                    ltype = "operator";
                }
                else {
                    ltoke = numb();
                    ltype = "number";
                }
                recordPush("");
            }
            else if (c[a] === ":" && c[a + 1] === ":") {
                if (wordTest > -1) {
                    word();
                }
                if (options.correct === true) {
                    plusplus();
                }
                asifix();
                a = a + 1;
                ltoke = "::";
                ltype = "separator";
                recordPush("");
            }
            else if (c[a] === ",") {
                // comma
                if (wordTest > -1) {
                    word();
                }
                if (options.correct === true) {
                    plusplus();
                }
                if (datatype[datatype.length - 1] === true && data.stack[parse.count].indexOf("type") < 0) {
                    datatype[datatype.length - 1] = false;
                }
                if (ltype === "comment") {
                    commaComment();
                }
                else if (vart.len > -1 && vart.count[vart.len] === 0 && options.lexer_options.script.variable_list === "each") {
                    asifix();
                    ltoke = ";";
                    ltype = "separator";
                    recordPush("");
                    ltoke = vart.word[vart.len];
                    ltype = "word";
                    recordPush("");
                    vart.index[vart.len] = parse.count;
                }
                else {
                    ltoke = ",";
                    ltype = "separator";
                    asifix();
                    recordPush("");
                }
            }
            else if (c[a] === ".") {
                // period
                if (wordTest > -1) {
                    word();
                }
                datatype[datatype.length - 1] = false;
                if (c[a + 1] === "." && c[a + 2] === ".") {
                    ltoke = "...";
                    ltype = "operator";
                    a = a + 2;
                }
                else {
                    asifix();
                    ltoke = ".";
                    ltype = "separator";
                }
                if ((/\s/).test(c[a - 1]) === true) {
                    parse.linesSpace = 1;
                }
                recordPush("");
            }
            else if (c[a] === ";") {
                // semicolon
                if (wordTest > -1) {
                    word();
                }
                if (datatype[datatype.length - 1] === true && data.stack[parse.count].indexOf("type") < 0) {
                    datatype[datatype.length - 1] = false;
                }
                if (options.language === "qml") {
                    ltoke = (options.correct === true)
                        ? ";"
                        : "x;";
                    ltype = "separator";
                    recordPush("");
                }
                else {
                    if (classy[classy.length - 1] === 0) {
                        classy.pop();
                    }
                    if (vart.len > -1 && vart.count[vart.len] === 0) {
                        if (options.lexer_options.script.variable_list === "each") {
                            vartpop();
                        }
                        else {
                            vart.index[vart.len] = parse.count + 1;
                        }
                    }
                    if (options.correct === true) {
                        plusplus();
                    }
                    ltoke = ";";
                    ltype = "separator";
                    if (data.token[parse.count] === "x}") {
                        asibrace();
                    }
                    else {
                        recordPush("");
                    }
                }
                blockinsert();
            }
            else if (c[a] === "(" || c[a] === "[" || c[a] === "{") {
                start(c[a]);
            }
            else if (c[a] === ")" || c[a] === "]" || c[a] === "}") {
                end(c[a]);
            }
            else if (c[a] === "*" && data.stack[parse.count] === "object" && wordTest < 0 && (/\s/).test(c[a + 1]) === false && c[a + 1] !== "=" && (/\d/).test(c[a + 1]) === false) {
                wordTest = a;
            }
            else if (c[a] === "=" || c[a] === "&" || c[a] === "<" || c[a] === ">" || c[a] === "+" || c[a] === "-" || c[a] === "*" || c[a] === "/" || c[a] === "!" || c[a] === "?" || c[a] === "|" || c[a] === "^" || c[a] === ":" || c[a] === "%" || c[a] === "~") {
                // operator
                ltoke = operator();
                if (ltoke === "regex") {
                    ltoke = data.token[parse.count];
                }
                else if (ltoke === "*" && data.token[parse.count] === "function") {
                    data.token[parse.count] = "function*";
                }
                else {
                    ltype = "operator";
                    if (ltoke !== "!" && ltoke !== "++" && ltoke !== "--") {
                        asifix();
                    }
                    recordPush("");
                }
            }
            else if (wordTest < 0 && c[a] !== "") {
                wordTest = a;
            }
            if (vart.len > -1 && parse.count === vart.index[vart.len] + 1 && data.token[vart.index[vart.len]] === ";" && ltoke !== vart.word[vart.len] && ltype !== "comment" && options.lexer_options.script.variable_list === "list") {
                vartpop();
            }
            a = a + 1;
        } while (a < b);
        if (wordTest > -1) {
            word();
        }
        if (((data.token[parse.count] !== "}" && data.token[0] === "{") || data.token[0] !== "{") && ((data.token[parse.count] !== "]" && data.token[0] === "[") || data.token[0] !== "[")) {
            asi(false);
        }
        if (sourcemap[0] === parse.count) {
            ltoke = "\n" + sourcemap[1];
            ltype = "string";
            recordPush("");
        }
        if (data.token[parse.count] === "x;" && (data.token[parse.count - 1] === "}" || data.token[parse.count - 1] === "]") && data.begin[parse.count - 1] === 0) {
            parse.pop(data);
        }
        return data;
    };
    sparser.lexers.script = script;
}());
(function markup_init() {
    
    const markup = function lexer_markup(source) {
        let a = 0, sgmlflag = 0, html = "", cftransaction = false, ext = false;
        const parse = sparser.parse, data = parse.data, count = {
            end: 0,
            index: -1,
            start: 0
        }, options = sparser.options, b = source.split(""), c = b.length, htmlblocks = {
            body: "block",
            colgroup: "block",
            dd: "block",
            dt: "block",
            head: "block",
            html: "block",
            li: "block",
            option: "block",
            p: "block",
            tbody: "block",
            td: "block",
            tfoot: "block",
            th: "block",
            thead: "block",
            tr: "block",
        }, attribute_sort_list = (typeof options.lexer_options.markup.attribute_sort_list === "string" && options.lexer_options.markup.attribute_sort_list !== "")
            ? options.lexer_options.markup.attribute_sort_list.split(",")
            : [], asl = attribute_sort_list.length, 
        //pads certain template tag delimiters with a space
        bracketSpace = function lexer_markup_bracketSpace(input) {
            if (options.language !== "html" && options.language !== "xml" && options.language !== "sgml" && options.language !== "jsx") {
                const spaceStart = function lexer_markup_tag_spaceStart(start) {
                    return start.replace(/\s*$/, " ");
                }, spaceEnd = function lexer_markup_tag_spaceStart(end) {
                    return end.replace(/^\s*/, " ");
                };
                if ((/\{(=|#|\/|(%>)|(%\]))/).test(input) === true || (/\}%(>|\])/).test(input) === true) {
                    return input;
                }
                input = input.replace(/\{((\{+)|%-?)\s*/g, spaceStart);
                input = input.replace(/\s*((\}\}+)|(-?%\}))/g, spaceEnd);
                return input;
            }
            return input;
        }, 
        // pushes a record into the parse table
        recordPush = function lexer_markup_recordPush(target, record, structure) {
            if (target === data) {
                if (record.types.indexOf("end") > -1) {
                    count.end = count.end + 1;
                }
                else if (record.types.indexOf("start") > -1) {
                    count.start = count.start + 1;
                }
            }
            if (options.lexer_options.markup.parse_space === true) {
                record.lines = 0;
            }
            parse.push(target, record, structure);
        }, 
        // Find the lowercase tag name of the provided token.
        tagName = function lexer_markup_tagName(el) {
            let space = 0, name = "";
            const reg = (/^((\{|<)((%-?)|\{-?)=?\s*)/);
            if (typeof el !== "string") {
                return "";
            }
            space = el
                .replace(reg, "%")
                .replace(/\s+/, " ")
                .indexOf(" ");
            name = el.replace(reg, " ");
            name = (space < 0)
                ? name.slice(1, el.length - 1)
                : name.slice(1, space);
            if (html === "html" || options.language === "coldfusion") {
                name = name.toLowerCase();
            }
            name = name.replace(/(\}\})$/, "");
            if (name.indexOf("(") > 0) {
                name = name.slice(0, name.indexOf("("));
            }
            if (name === "?xml?") {
                return "xml";
            }
            return name;
        }, 
        // A fix for HTML missing end tags
        fixHtmlEnd = function lexer_markup_fixHtmlEnd(element, end) {
            const tname = tagName(element), record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: (data.lines[parse.count] > 0) ? 1 : 0,
                stack: parse.structure[parse.structure.length - 1][0],
                token: `</${parse.structure[parse.structure.length - 1][0]}>`,
                types: "end"
            };
            recordPush(data, record, "");
            if (htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && ((end === true && parse.structure.length > 1) || (end === false && `/${parse.structure[parse.structure.length - 1][0]}` !== tname))) {
                do {
                    record.begin = parse.structure[parse.structure.length - 1][1];
                    record.stack = parse.structure[parse.structure.length - 1][0];
                    record.token = `</${parse.structure[parse.structure.length - 1][0]}>`;
                    recordPush(data, record, "");
                } while (htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && ((end === true && parse.structure.length > 1) || (end === false && `/${parse.structure[parse.structure.length - 1][0]}` !== tname)));
            }
        }, 
        // A fix for Vapor Leaf end structure parsing
        vaporEnd = function lexer_markup_vaporEnd() {
            const liner = parse.linesSpace, rec = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: liner,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "}",
                types: "template_end"
            };
            let aa = a + 1;
            if ((/\s/).test(b[aa]) === true) {
                aa = parse.spacer({ array: b, end: c, index: aa }) + 1;
            }
            if (b[aa] === "e" && b[aa + 1] === "l" && b[aa + 2] === "s" && b[aa + 3] === "e") {
                if (b[aa + 4] === "{") {
                    rec.token = "} else {";
                    rec.types = "template_else";
                    recordPush(data, rec, "else");
                    a = aa;
                    return;
                }
                if ((/\s/).test(b[aa + 4]) === true) {
                    aa = parse.spacer({ array: b, end: c, index: aa + 4 }) + 1;
                    if (b[aa] === "{") {
                        rec.token = "} else {";
                        rec.types = "template_else";
                        recordPush(data, rec, "else");
                        a = aa;
                        return;
                    }
                    if (b[aa] === "i" && b[aa + 1] === "f") {
                        aa = aa + 2;
                        if ((/\s/).test(b[aa]) === true) {
                            aa = parse.spacer({ array: b, end: c, index: aa }) + 1;
                        }
                        if (b[aa] === "(") {
                            let paren = 0;
                            do {
                                if (b[aa] === "(") {
                                    paren = paren + 1;
                                }
                                else if (b[aa] === ")") {
                                    paren = paren - 1;
                                    if (paren < 1) {
                                        aa = aa + 1;
                                        break;
                                    }
                                }
                                aa = aa + 1;
                            } while (aa < c);
                            if ((/\s/).test(b[aa]) === true) {
                                aa = parse.spacer({ array: b, end: c, index: aa }) + 1;
                            }
                            if (b[aa] === "{") {
                                rec.token = b.slice(a, aa + 1).join("");
                                rec.types = "template_else";
                                recordPush(data, rec, "else");
                                a = aa;
                                return;
                            }
                        }
                    }
                }
            }
            recordPush(data, rec, "");
            parse.linesSpace = liner;
        }, 
        // A fix for Vapor Leaf start structure parsing
        vaporStart = function lexer_markup_vaporStart() {
            const rec = parse.pop(data);
            rec.token = `${rec.token} {`;
            rec.types = "template_start";
            recordPush(data, rec, rec.token.slice(0, rec.token.indexOf("(")));
        }, 
        //parses tags, attributes, and template elements
        tag = function lexer_markup_tag(end) {
            // markup is two smaller lexers that work together: tag - evaluates markup and
            // template tags content - evaluates text content and code for external lexers
            //
            //type definitions:
            // * start      end     type
            // * <![CDATA[   ]]>    cdata
            // * <!--       -->     comment
            // * <#--       -->     comment
            // * <%--       --%>    comment
            // * {!         !}      comment
            // * <!--[if    -->     conditional
            // * text       text    content
            // * </         >       end
            // * <pre       </pre>  ignore (html only)
            // * text       text    script
            // * <!         >       sgml
            // * <          />      singleton
            // * <          >       start
            // * text       text    style
            // * <!--#      -->     template
            // * <%         %>      template
            // * {{{        }}}     template
            // * {{         }}      template
            // * {%         %}      template
            // * [%         %]      template
            // * {@         @}      template
            // * {#         #}      template
            // * {#         /}      template
            // * {?         /}      template
            // * {^         /}      template
            // * {@         /}      template
            // * {<         /}      template
            // * {+         /}      template
            // * {~         }       template
            // * <?         ?>      template
            // * {:else}            template_else
            // * <#else     >       template_else
            // * {@}else{@}         template_else
            // * <%}else{%>         template_else
            // * {{         }}      template_end
            // * <%\s*}     %>      template_end
            // * [%\s*}     %]      template_end
            // * {@\s*}     @}      template_end
            // * {          }       template_end
            // * {{#        }}      template_start
            // * <%         {\s*%>  template_start
            // * [%         {\s*%]  template_start
            // * {@         {\s*@}  template_start
            // * {#         }       template_start
            // * {?         }       template_start
            // * {^         }       template_start
            // * {@         }       template_start
            // * {<         }       template_start
            // * {+         }       template_start
            // * <?xml      ?>      xml
            let igcount = 0, element = "", lastchar = "", ltype = "", tname = "", start = "", cheat = false, earlyexit = false, ignoreme = false, jscom = false, nopush = false, nosort = false, preserve = false, simple = false, singleton = false, attstore = [], comm = ["", 0];
            const record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: parse.linesSpace,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "",
                types: ""
            }, 
            //cftags is a list of supported coldfusion tags
            // * required - means must have a separate matching end tag
            // * optional - means the tag could have a separate end tag, but is probably a
            // singleton
            // * prohibited - means there is no corresponding end tag
            cftags = {
                "cfNTauthenticate": "optional",
                "cfabort": "prohibited",
                "cfajaximport": "optional",
                "cfajaxproxy": "optional",
                "cfapplet": "prohibited",
                "cfapplication": "prohibited",
                "cfargument": "prohibited",
                "cfassociate": "prohibited",
                "cfauthenticate": "prohibited",
                "cfbreak": "prohibited",
                "cfcache": "optional",
                "cfcalendar": "optional",
                "cfcase": "required",
                "cfcatch": "required",
                "cfchart": "optional",
                "cfchartdata": "prohibited",
                "cfchartseries": "optional",
                "cfclient": "required",
                "cfclientsettings": "optional",
                "cfcol": "prohibited",
                "cfcollection": "prohibited",
                "cfcomponent": "required",
                "cfcontent": "optional",
                "cfcontinue": "prohibited",
                "cfcookie": "prohibited",
                "cfdbinfo": "prohibited",
                "cfdefaultcase": "required",
                "cfdirectory": "prohibited",
                "cfdiv": "optional",
                "cfdocument": "optional",
                "cfdocumentitem": "optional",
                "cfdocumentsection": "optional",
                "cfdump": "optional",
                "cfelse": "prohibited",
                "cfelseif": "prohibited",
                "cferror": "prohibited",
                "cfexchangecalendar": "optional",
                "cfexchangeconnection": "optional",
                "cfexchangecontact": "optional",
                "cfexchangeconversation": "optional",
                "cfexchangefilter": "optional",
                "cfexchangefolder": "optional",
                "cfexchangemail": "optional",
                "cfexchangetask": "optional",
                "cfexecute": "required",
                "cfexit": "prohibited",
                "cffeed": "prohibited",
                "cffile": "optional",
                "cffileupload": "optional",
                "cffinally": "required",
                "cfflush": "prohibited",
                "cfform": "required",
                "cfformgroup": "required",
                "cfformitem": "optional",
                "cfforward": "prohibited",
                "cfftp": "prohibited",
                "cffunction": "required",
                "cfgraph": "required",
                "cfgraphdata": "prohibited",
                "cfgrid": "required",
                "cfgridcolumn": "optional",
                "cfgridrow": "optional",
                "cfgridupdate": "optional",
                "cfheader": "prohibited",
                "cfhtmlbody": "optional",
                "cfhtmlhead": "optional",
                "cfhtmltopdf": "optional",
                "cfhtmltopdfitem": "optional",
                "cfhttp": "optional",
                "cfhttpparam": "prohibited",
                "cfif": "required",
                "cfimage": "prohibited",
                "cfimap": "prohibited",
                "cfimapfilter": "optional",
                "cfimport": "prohibited",
                "cfinclude": "prohibited",
                "cfindex": "prohibited",
                "cfinput": "prohibited",
                "cfinsert": "prohibited",
                "cfinterface": "required",
                "cfinvoke": "optional",
                "cfinvokeargument": "prohibited",
                "cflayout": "optional",
                "cflayoutarea": "optional",
                "cfldap": "prohibited",
                "cflocation": "prohibited",
                "cflock": "required",
                "cflog": "prohibited",
                "cflogic": "required",
                "cfloginuser": "prohibited",
                "cflogout": "prohibited",
                "cfloop": "required",
                "cfmail": "required",
                "cfmailparam": "prohibited",
                "cfmailpart": "required",
                "cfmap": "optional",
                "cfmapitem": "optional",
                "cfmediaplayer": "optional",
                "cfmenu": "required",
                "cfmenuitem": "optional",
                "cfmessagebox": "optional",
                "cfmodule": "optional",
                "cfoauth": "optional",
                "cfobject": "prohibited",
                "cfobjectcache": "prohibited",
                "cfoutput": "required",
                "cfpageencoding": "optional",
                "cfparam": "prohibited",
                "cfpdf": "optional",
                "cfpdfform": "optional",
                "cfpdfformparam": "optional",
                "cfpdfparam": "prohibited",
                "cfpdfsubform": "required",
                "cfpod": "optional",
                "cfpop": "prohibited",
                "cfpresentation": "required",
                "cfpresentationslide": "optional",
                "cfpresenter": "optional",
                "cfprint": "optional",
                "cfprocessingdirective": "optional",
                "cfprocparam": "prohibited",
                "cfprocresult": "prohibited",
                "cfprogressbar": "optional",
                "cfproperty": "prohibited",
                "cfquery": "required",
                "cfqueryparam": "prohibited",
                "cfregistry": "prohibited",
                "cfreport": "optional",
                "cfreportparam": "optional",
                "cfrethrow": "prohibited",
                "cfretry": "prohibited",
                "cfreturn": "prohibited",
                "cfsavecontent": "required",
                "cfschedule": "prohibited",
                "cfscript": "required",
                "cfsearch": "prohibited",
                "cfselect": "required",
                "cfservlet": "prohibited",
                "cfservletparam": "prohibited",
                "cfset": "prohibited",
                "cfsetting": "optional",
                "cfsharepoint": "optional",
                "cfsilent": "required",
                "cfsleep": "prohibited",
                "cfslider": "prohibited",
                "cfspreadsheet": "optional",
                "cfsprydataset": "optional",
                "cfstatic": "required",
                "cfstopwatch": "required",
                "cfstoredproc": "optional",
                "cfswitch": "required",
                "cftable": "required",
                "cftextarea": "optional",
                "cfthread": "optional",
                "cfthrow": "prohibited",
                "cftimer": "required",
                "cftooltip": "required",
                "cftrace": "optional",
                "cftransaction": "required",
                "cftree": "required",
                "cftreeitem": "optional",
                "cftry": "required",
                "cfupdate": "prohibited",
                "cfvideo": "prohibited",
                "cfvideoplayer": "optional",
                "cfwddx": "prohibited",
                "cfwebsocket": "optional",
                "cfwhile": "required",
                "cfwindow": "optional",
                "cfx_": "prohibited",
                "cfxml": "required",
                "cfzip": "optional",
                "cfzipparam": "prohibited"
            }, 
            //attribute name
            arname = function lexer_markup_tag_name(x) {
                const eq = x.indexOf("=");
                if (eq > 0 && ((eq < x.indexOf("\"") && x.indexOf("\"") > 0) || (eq < x.indexOf("'") && x.indexOf("'") > 0))) {
                    return [x.slice(0, eq), x.slice(eq + 1)];
                }
                return [x, ""];
            }, 
            // attribute parser
            attributeRecord = function lexer_markup_tag_attributeRecord() {
                let ind = 0, eq = 0, dq = 0, sq = 0, slice = "", name = "", cft = cftags[tname
                    .toLowerCase()
                    .replace(/\/$/, "")], store = [], len = attstore.length;
                const qc = (options.lexer_options.markup.quote_convert === undefined)
                    ? "none"
                    : options.lexer_options.markup.quote_convert, begin = parse.count, stack = tname.replace(/\/$/, ""), syntax = "<{\"'=/", convertQ = function lexer_markup_tag_attributeRecord_convertQ() {
                    if (ignoreme === true || qc === "none" || record.types !== "attribute" || (qc === "single" && record.token.indexOf("\"") < 0) || (qc === "double" && record.token.indexOf("'") < 0)) {
                        recordPush(data, record, "");
                    }
                    else {
                        let ee = 0, inner = false;
                        const chars = record.token.split(""), eq = record.token.indexOf("="), len = chars.length - 1;
                        if (chars[eq + 1] !== "\"" && qc === "single" && chars[chars.length - 1] !== "\"") {
                            recordPush(data, record, "");
                        }
                        else if (chars[eq + 1] !== "'" && qc === "double" && chars[chars.length - 1] !== "'") {
                            recordPush(data, record, "");
                        }
                        else {
                            ee = eq + 2;
                            if (qc === "double") {
                                if (record.token.slice(eq + 2, len).indexOf("\"") > -1) {
                                    inner = true;
                                }
                                chars[eq + 1] = "\"";
                                chars[chars.length - 1] = "\"";
                            }
                            else {
                                if (record.token.slice(eq + 2, len).indexOf("'") > -1) {
                                    inner = true;
                                }
                                chars[eq + 1] = "'";
                                chars[chars.length - 1] = "'";
                            }
                            if (inner === true) {
                                do {
                                    if (chars[ee] === "'" && qc === "single") {
                                        chars[ee] = "\"";
                                    }
                                    else if (chars[ee] === "\"" && qc === "double") {
                                        chars[ee] = "'";
                                    }
                                    ee = ee + 1;
                                } while (ee < len);
                            }
                            record.token = chars.join("");
                            recordPush(data, record, "");
                        }
                    }
                }, templateAtt = function lexer_markup_tag_attributeRecord_templateAtt(sample, token) {
                    if (sample.charAt(0) === "{" && "{%#@:/?^<+~=".indexOf(sample.charAt(1)) > -1) {
                        record.types = "template_attribute";
                    }
                    else if (sample.charAt(0) === "<") {
                        record.types = "template_attribute";
                    }
                    else if (sample === "[%") {
                        record.types = "template_attribute";
                    }
                    else {
                        record.token = token;
                        convertQ();
                        return;
                    }
                    record.token = token;
                    convertQ();
                    record.types = "attribute";
                };
                if (attstore.length < 1) {
                    return;
                }
                // fix for singleton tags, since "/" at the end of the tag is not an attribute
                if (attstore[attstore.length - 1][0] === "/") {
                    attstore.pop();
                    element = element.replace(/>$/, "/>");
                }
                // reconnects attribute names to their respective values if separated on "="
                eq = attstore.length;
                dq = 1;
                if (dq < eq) {
                    do {
                        name = attstore[dq - 1][0];
                        if (name.charAt(name.length - 1) === "=" && attstore[dq][0].indexOf("=") < 0) {
                            attstore[dq - 1][0] = name + attstore[dq][0];
                            attstore.splice(dq, 1);
                            eq = eq - 1;
                            dq = dq - 1;
                        }
                        dq = dq + 1;
                    } while (dq < eq);
                }
                // sort the attributes
                if ((options.lexer_options.markup.attribute_sort === true || options.lexer_options.markup.tag_sort === true) && jscom === false && options.language !== "jsx" && nosort === false && tname !== "cfif" && tname !== "cfelseif" && tname !== "cfset") {
                    // if making use of the 'attribute_sort_list` option
                    if (asl > 0) {
                        const tempstore = [];
                        dq = 0;
                        eq = 0;
                        len = attstore.length;
                        // loop through the attribute_sort_list looking for attribute name matches
                        do {
                            // loop through the attstore
                            eq = 0;
                            do {
                                name = attstore[eq][0].split("=")[0];
                                if (attribute_sort_list[dq] === name) {
                                    tempstore.push(attstore[eq]);
                                    attstore.splice(eq, 1);
                                    len = len - 1;
                                    break;
                                }
                                eq = eq + 1;
                            } while (eq < len);
                            dq = dq + 1;
                        } while (dq < asl);
                        attstore = parse.safeSort(attstore, "", false);
                        attstore = tempstore.concat(attstore);
                        len = attstore.length;
                    }
                    else {
                        attstore = parse.safeSort(attstore, "", false);
                    }
                }
                // preparation for a coldfusion edge case
                if (tname.slice(0, 3).toLowerCase() === "cf_") {
                    cft = "required";
                }
                record.begin = begin;
                record.stack = stack;
                record.types = "attribute";
                store = [];
                if (ind < len) {
                    do {
                        if (attstore[ind] === undefined) {
                            break;
                        }
                        attstore[ind][0] = attstore[ind][0].replace(/\s+$/, "");
                        record.lines = attstore[ind][1];
                        eq = attstore[ind][0].indexOf("=");
                        dq = attstore[ind][0].indexOf("\"");
                        sq = attstore[ind][0].indexOf("'");
                        if ((/^\/(\/|\*)/).test(attstore[ind][0]) === true && options.language === "jsx") {
                            record.types = "comment_attribute";
                            record.token = attstore[ind][0];
                            convertQ();
                        }
                        else if (eq > -1 && store.length > 0) {
                            // put certain attributes together for coldfusion
                            record.token = store.join(" ");
                            convertQ();
                            if (attstore[ind][0].indexOf("=") > 0 && attstore[ind][0].indexOf("//") < 0 && attstore[ind][0].charAt(0) !== ";") {
                                record.token = attstore[ind][0].replace(/\s$/, "");
                            }
                            else {
                                record.token = attstore[ind][0];
                            }
                            convertQ();
                            store = [];
                        }
                        else if (ltype === "sgml") {
                            store.push(attstore[ind][0]);
                        }
                        else if (cft !== undefined && eq < 0 && attstore[ind][0].indexOf("=") < 0) {
                            // put certain attributes together for coldfusion
                            store.push(attstore[ind][0]);
                        }
                        else if ((cft !== undefined && eq < 0) || (dq > 0 && dq < eq) || (sq > 0 && sq < eq) || syntax.indexOf(attstore[ind][0].charAt(0)) > -1) {
                            // tags stored as attributes of other tags
                            templateAtt(attstore[ind][0].replace(/^("|')/, "").slice(0, 2), attstore[ind][0].replace(/\s$/, ""));
                        }
                        else if (eq < 0 && cft === undefined) {
                            // in most markup languages an attribute without an expressed value has its name
                            // as its string value
                            if (html === "html" && "[{(".indexOf(attstore[ind][0].charAt(0)) < 0 && attstore[ind][0].charAt(0) !== "#" && (/^\*?ng[A-Z]/).test(attstore[ind][0]) === false) {
                                record.token = attstore[ind][0].toLowerCase();
                            }
                            else if (options.language === "xml" || options.language === "coldfusion") {
                                if (options.lexer_options.markup.quote_convert === "single") {
                                    record.token = `${attstore[ind][0]}='${attstore[ind][0]}'`;
                                }
                                else {
                                    record.token = `${attstore[ind][0]}="${attstore[ind][0]}"`;
                                }
                            }
                            else {
                                record.token = attstore[ind][0];
                            }
                            convertQ();
                        }
                        else {
                            // separates out the attribute name from its value
                            slice = attstore[ind][0].slice(eq + 1);
                            if (syntax.indexOf(slice.charAt(0)) < 0 && cft === undefined) {
                                slice = "\"" + slice + "\"";
                            }
                            name = attstore[ind][0].slice(0, eq);
                            if (html === "html" && "[{(".indexOf(name.charAt(0)) < 0 && cft === undefined && (/^\*?ng[A-Z]/).test(attstore[ind][0]) === false) {
                                name = name.toLowerCase();
                            }
                            if (options.language === "jsx" && (/^(\s*\{)/).test(slice) === true) {
                                record.token = name + "={";
                                record.types = "jsx_attribute_start";
                                recordPush(data, record, "jsx_attribute");
                                sparser.lexers.script(slice.slice(1, slice.length - 1));
                                record.begin = parse.count;
                                if ((/\s\}$/).test(slice) === true) {
                                    slice = slice.slice(0, slice.length - 1);
                                    slice = (/\s+$/).exec(slice)[0];
                                    if (slice.indexOf("\n") < 0) {
                                        record.lines = 1;
                                    }
                                    else {
                                        record.lines = slice.split("\n").length;
                                    }
                                }
                                else {
                                    record.lines = 0;
                                }
                                record.begin = parse.structure[parse.structure.length - 1][1];
                                record.stack = parse.structure[parse.structure.length - 1][0];
                                record.token = "}";
                                record.types = "jsx_attribute_end";
                                convertQ();
                                record.types = "attribute";
                                record.begin = begin;
                                record.stack = stack;
                            }
                            else {
                                name = name + "=" + slice;
                                templateAtt(slice.replace(/^("|')/, "").slice(0, 2), name.replace(/(\s+)$/, ""));
                            }
                        }
                        ind = ind + 1;
                    } while (ind < len);
                }
                if (store.length > 0) {
                    record.token = store.join(" ");
                    convertQ();
                }
            };
            ext = false;
            // this complex series of conditions determines an elements delimiters look to
            // the types being pushed to quickly reason about the logic no type is pushed
            // for start tags or singleton tags just yet some types set the `preserve` flag,
            // which means to preserve internal white space The `nopush` flag is set when
            // parsed tags are to be ignored and forgotten
            (function lexer_markup_tag_types() {
                if (end === "]>") {
                    end = ">";
                    sgmlflag = sgmlflag - 1;
                    ltype = "end";
                }
                else if (end === "---") {
                    ltype = "comment";
                    start = "---";
                }
                else if (end === ")" && options.language === "vapor") {
                    ltype = "template";
                }
                else if (b[a] === "<") {
                    if (b[a + 1] === "/") {
                        if (b[a + 2] === "#") {
                            ltype = "template_end";
                        }
                        else {
                            ltype = "end";
                        }
                        end = ">";
                    }
                    else if (b[a + 1] === "!") {
                        if (b[a + 2] === "-" && b[a + 3] === "-") {
                            if (b[a + 4] === "#") {
                                end = "-->";
                                ltype = "template";
                            }
                            else if (b[a + 4] === "-" && (/<cf[a-z]/i).test(source) === true) {
                                end = "--->";
                                ltype = "comment";
                                start = "<!---";
                            }
                            else {
                                end = "-->";
                                ltype = "comment";
                                start = "<!--";
                            }
                        }
                        else if (b[a + 2] === "[" && b[a + 3] === "C" && b[a + 4] === "D" && b[a + 5] === "A" && b[a + 6] === "T" && b[a + 7] === "A" && b[a + 8] === "[") {
                            end = "]]>";
                            ltype = "cdata";
                            preserve = true;
                        }
                        else {
                            end = ">";
                            sgmlflag = sgmlflag + 1;
                            ltype = "sgml";
                        }
                    }
                    else if (b[a + 1] === "?") {
                        end = "?>";
                        if (b[a + 2] === "x" && b[a + 3] === "m" && b[a + 4] === "l") {
                            ltype = "xml";
                            simple = true;
                        }
                        else {
                            preserve = true;
                            ltype = "template";
                        }
                    }
                    else if (b[a + 1] === "%") {
                        preserve = true;
                        if (b[a + 2] === "-" && b[a + 3] === "-") {
                            end = "--%>";
                            ltype = "comment";
                            start = "<%--";
                        }
                        else if (b[a + 2] === "#") {
                            end = "%>";
                            ltype = "comment";
                            start = "<%#";
                        }
                        else {
                            end = "%>";
                            ltype = "template";
                        }
                    }
                    else if ((b[a + 1] === "p" || b[a + 1] === "P") && (b[a + 2] === "r" || b[a + 2] === "R") && (b[a + 3] === "e" || b[a + 3] === "E") && (b[a + 4] === ">" || (/\s/).test(b[a + 4]) === true)) {
                        end = "</pre>";
                        preserve = true;
                        ltype = "ignore";
                    }
                    else if ((b[a + 1] === "x" || b[a + 1] === "X") && (b[a + 2] === "m" || b[a + 2] === "M") && (b[a + 3] === "l" || b[a + 3] === "L") && b[a + 4] === ":" && (b[a + 5] === "t" || b[a + 5] === "T") && (b[a + 6] === "e" || b[a + 6] === "E") && (b[a + 7] === "x" || b[a + 7] === "X") && (b[a + 8] === "t" || b[a + 8] === "T") && (b[a + 9] === ">" || (/\s/).test(b[a + 9]) === true)) {
                        end = "</xsl:text>";
                        preserve = true;
                        ltype = "ignore";
                    }
                    else if ((b[a + 1] === "c" || b[a + 1] === "C") && (b[a + 2] === "f" || b[a + 2] === "F") && (b[a + 3] === "q" || b[a + 3] === "Q") && (b[a + 4] === "u" || b[a + 4] === "U") && (b[a + 5] === "e" || b[a + 5] === "E") && (b[a + 6] === "r" || b[a + 6] === "R") && (b[a + 7] === "y" || b[a + 7] === "Y") && (b[a + 8] === ">" || (/\s/).test(b[a + 8]) === true)) {
                        end = "</" + b.slice(a + 1, a + 8).join("") + ">";
                        preserve = true;
                        ltype = "content_preserve";
                    }
                    else if (b[a + 1] === "<") {
                        if (b[a + 2] === "<") {
                            end = ">>>";
                        }
                        else {
                            end = ">>";
                        }
                        ltype = "template";
                    }
                    else if (b[a + 1] === "#") {
                        if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {
                            end = ">";
                            ltype = "template_else";
                        }
                        else if (b[a + 2] === "-" && b[a + 3] === "-") {
                            end = "-->";
                            ltype = "comment";
                            start = "<#--";
                        }
                        else {
                            end = ">";
                            ltype = "template_start";
                        }
                    }
                    else {
                        simple = true;
                        end = ">";
                    }
                }
                else if (b[a] === "{") {
                    preserve = true;
                    if (options.language === "jsx") {
                        ext = true;
                        earlyexit = true;
                        record.token = "{";
                        record.types = "script_start";
                        recordPush(data, record, "");
                        parse.structure.push(["script", parse.count]);
                        return;
                    }
                    if (options.language === "dustjs") {
                        if (b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {
                            a = a + 6;
                            earlyexit = true;
                            record.token = "{:else}";
                            record.types = "template_else";
                            recordPush(data, record, "else");
                            return;
                        }
                        if (b[a + 1] === "!") {
                            end = "!}";
                            ltype = "comment";
                            start = "{!";
                        }
                        else if (b[a + 1] === "/") {
                            end = "}";
                            ltype = "template_end";
                        }
                        else if (b[a + 1] === "~") {
                            end = "}";
                            ltype = "singleton";
                        }
                        else if (b[a + 1] === ">") {
                            end = "/}";
                            ltype = "singleton";
                        }
                        else if (b[a + 1] === "#" || b[a + 1] === "?" || b[a + 1] === "^" || b[a + 1] === "@" || b[a + 1] === "<" || b[a + 1] === "+") {
                            end = "}";
                            ltype = "template_start";
                        }
                        else {
                            end = "}";
                            ltype = "template";
                        }
                    }
                    else if (b[a + 1] === "{") {
                        if (b[a + 2] === "{") {
                            end = "}}}";
                            ltype = "template";
                        }
                        else if (b[a + 2] === "#") {
                            end = "}}";
                            ltype = "template_start";
                        }
                        else if (b[a + 2] === "/") {
                            end = "}}";
                            ltype = "template_end";
                        }
                        else if (b[a + 2] === "e" && b[a + 3] === "n" && b[a + 4] === "d") {
                            end = "}}";
                            ltype = "template_end";
                        }
                        else if (b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e") {
                            end = "}}";
                            ltype = "template_else";
                        }
                        else {
                            end = "}}";
                            ltype = "template";
                        }
                    }
                    else if (b[a + 1] === "%") {
                        end = "%}";
                        ltype = "template";
                    }
                    else if (b[a + 1] === "#") {
                        end = "#}";
                        ltype = "comment";
                        start = "{#";
                    }
                    else {
                        end = b[a + 1] + "}";
                        ltype = "template";
                    }
                    if (b[a + 1] === "@" && b[a + 2] === "}" && b[a + 3] === "e" && b[a + 4] === "l" && b[a + 5] === "s" && b[a + 6] === "e" && b[a + 7] === "{" && b[a + 8] === "@" && b[a + 9] === "}") {
                        a = a + 9;
                        earlyexit = true;
                        record.token = "{@}else{@}";
                        record.types = "template_else";
                        recordPush(data, record, "else");
                        return;
                    }
                }
                else if (b[a] === "[" && b[a + 1] === "%") {
                    end = "%]";
                    ltype = "template";
                }
                else if (b[a] === "#" && options.language === "apacheVelocity") {
                    if (b[a + 1] === "*") {
                        end = "*#";
                        ltype = "comment";
                        start = "#*";
                    }
                    else if (b[a + 1] === "[" && b[a + 2] === "[") {
                        end = "]]#";
                        ltype = "comment";
                        start = "#[[";
                    }
                    else if (b[a + 1] === "#") {
                        end = "\n";
                        ltype = "comment";
                        start = "##";
                    }
                    else if (b[a + 1] === "e" && b[a + 2] === "l" && b[a + 3] === "s" && b[a + 4] === "e" && (/\s/).test(b[a + 5]) === true) {
                        end = "\n";
                        ltype = "template_else";
                    }
                    else if (b[a + 1] === "i" && b[a + 2] === "f") {
                        end = "\n";
                        ltype = "template_start";
                    }
                    else if (b[a + 1] === "f" && b[a + 2] === "o" && b[a + 3] === "r" && b[a + 4] === "e" && b[a + 5] === "a" && b[a + 6] === "c" && b[a + 7] === "h") {
                        end = "\n";
                        ltype = "template_start";
                    }
                    else if (b[a + 1] === "e" && b[a + 2] === "n" && b[a + 3] === "d") {
                        end = "\n";
                        ltype = "template_end";
                    }
                    else {
                        end = "\n";
                        ltype = "template";
                    }
                }
                else if (b[a] === "$" && options.language === "apacheVelocity") {
                    end = "\n";
                    ltype = "template";
                }
                if (options.lexer_options.markup.unformatted === true) {
                    preserve = true;
                }
            }());
            if (earlyexit === true) {
                return;
            }
            // This is the real tag lexer. Everything that follows is attribute handling and
            // edge cases
            lastchar = end.charAt(end.length - 1);
            if (ltype === "comment" && b[a] === "<") {
                comm = parse.wrapCommentBlock({
                    chars: b,
                    end: c,
                    lexer: "markup",
                    opening: start,
                    start: a,
                    terminator: end
                });
                element = comm[0];
                a = comm[1];
                if (element.replace(start, "").replace(/(^\s*)/, "").indexOf("parse-ignore-start") === 0) {
                    record.token = element;
                    record.types = "ignore";
                    recordPush(data, record, "");
                    return;
                }
            }
            else if (a < c) {
                let bcount = 0, braccount = 0, jsxcount = 0, e = 0, f = 0, parncount = 0, lines = 1, quote = "", jsxquote = "", stest = false, quotetest = false, dustatt = [], attribute = [];
                const lex = [], 
                //finds slash escape sequences
                slashy = function lexer_markup_tag_slashy() {
                    let x = a;
                    do {
                        x = x - 1;
                    } while (b[x] === "\\");
                    x = a - x;
                    if (x % 2 === 1) {
                        return false;
                    }
                    return true;
                }, 
                // attribute lexer
                attributeLexer = function lexer_markup_tag_attributeLexer(quotes) {
                    let atty = "", name, aa = 0, bb = 0;
                    if (quotes === true) {
                        atty = attribute.join("");
                        name = arname(atty);
                        if (name[0] === "data-parse-ignore" || name[0] === "data-prettydiff-ignore") {
                            ignoreme = true;
                        }
                        quote = "";
                    }
                    else {
                        atty = attribute
                            .join("");
                        if (options.language !== "jsx" || (options.language === "jsx" && atty.charAt(atty.length - 1) !== "}")) {
                            atty = atty.replace(/\s+/g, " ");
                        }
                        name = arname(atty);
                        if (name[0] === "data-parse-ignore" || name[0] === "data-prettydiff-ignore") {
                            ignoreme = true;
                        }
                        if (options.language === "jsx" && attribute[0] === "{" && attribute[attribute.length - 1] === "}") {
                            jsxcount = 0;
                        }
                    }
                    if (atty.slice(0, 3) === "<%=" || atty.slice(0, 2) === "{%") {
                        nosort = true;
                    }
                    atty = atty
                        .replace(/^\u0020/, "")
                        .replace(/\u0020$/, "");
                    attribute = atty
                        .replace(/\r\n/g, "\n")
                        .split("\n");
                    bb = attribute.length;
                    if (aa < bb) {
                        do {
                            attribute[aa] = attribute[aa].replace(/(\s+)$/, "");
                            aa = aa + 1;
                        } while (aa < bb);
                    }
                    if (options.crlf === true) {
                        atty = attribute.join("\r\n");
                    }
                    else {
                        atty = attribute.join("\n");
                    }
                    atty = bracketSpace(atty);
                    if (atty === "=") {
                        attstore[attstore.length - 1][0] = `${attstore[attstore.length - 1][0]}=`;
                    }
                    else if (atty.charAt(0) === "=" && attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=") < 0) {
                        //if an attribute starts with a `=` then adjoin it to the last attribute
                        attstore[attstore.length - 1][0] = attstore[attstore.length - 1][0] + atty;
                    }
                    else if (atty.charAt(0) !== "=" && attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=") === attstore[attstore.length - 1][0].length - 1) {
                        // if an attribute follows an attribute ending with `=` then adjoin it to the
                        // last attribute
                        attstore[attstore.length - 1][0] = attstore[attstore.length - 1][0] + atty;
                    }
                    else if (options.language === "coldfusion" && attstore.length > 0 && (("+-\u002a/(^").indexOf(atty) > -1 || ("+-\u002a/(^").indexOf(attstore[attstore.length - 1][0].charAt(attstore[attstore.length - 1][0].length - 1)) > -1)) {
                        attstore[attstore.length - 1][0] = `${attstore[attstore.length - 1][0]} ${atty}`;
                    }
                    else if (atty !== "" && atty !== " ") {
                        attstore.push([atty, lines]);
                    }
                    if (attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=\u201c") > 0) {
                        sparser.parseerror = `Quote looking character (\u201c, &#x201c) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                    else if (attstore.length > 0 && attstore[attstore.length - 1][0].indexOf("=\u201d") > 0) {
                        sparser.parseerror = `Quote looking character (\u201d, &#x201d) used instead of actual quotes on line number ${parse.lineNumber}`;
                    }
                    attribute = [];
                    lines = (b[a] === "\n")
                        ? 2
                        : 1;
                };
                do {
                    if (b[a] === "\n") {
                        lines = lines + 1;
                        if (options.language === "apacheVelocity" && lex[0] === "#") {
                            a = a - 1;
                            break;
                        }
                        parse.lineNumber = parse.lineNumber + 1;
                    }
                    if (preserve === true || (((/\s/).test(b[a]) === false && quote !== "}") || quote === "}")) {
                        lex.push(b[a]);
                        if (lex[0] === "<" && lex[1] === ">" && end === ">") {
                            record.token = "<>";
                            record.types = "start";
                            recordPush(data, record, "(empty)");
                            return;
                        }
                        if (lex[0] === "<" && lex[1] === "/" && lex[2] === ">" && end === ">") {
                            record.token = "</>";
                            record.types = "end";
                            recordPush(data, record, "");
                            return;
                        }
                    }
                    if (ltype === "cdata" && b[a] === ">" && b[a - 1] === "]" && b[a - 2] !== "]") {
                        sparser.parseerror = `CDATA tag ${lex.join("")} is not properly terminated with ]]>`;
                        break;
                    }
                    if (ltype === "comment") {
                        quote = "";
                        //comments must ignore fancy encapsulations and attribute parsing
                        if (b[a] === lastchar && lex.length > end.length + 1) {
                            //if current character matches the last character of the tag ending sequence
                            f = lex.length;
                            e = end.length - 1;
                            if (e > -1) {
                                do {
                                    f = f - 1;
                                    if (lex[f] !== end.charAt(e)) {
                                        break;
                                    }
                                    e = e - 1;
                                } while (e > -1);
                            }
                            if (e < 0) {
                                if (end === "endcomment") {
                                    f = f - 1;
                                    if ((/\s/).test(lex[f]) === true) {
                                        do {
                                            f = f - 1;
                                        } while (f > 0 && (/\s/).test(lex[f]) === true);
                                    }
                                    if (lex[f - 2] === "{" && lex[f - 1] === "%" && lex[f] === "-") {
                                        end = "-%}";
                                        lastchar = "}";
                                    }
                                    else if (lex[f - 1] === "{" && lex[f] === "%") {
                                        end = "%}";
                                        lastchar = "}";
                                    }
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        if (quote === "") {
                            if (lex[0] + lex[1] === "<!" && ltype !== "cdata") {
                                if (b[a] === "[") {
                                    if (b[a + 1] === "<") {
                                        ltype = "start";
                                        break;
                                    }
                                    if ((/\s/).test(b[a + 1]) === true) {
                                        do {
                                            a = a + 1;
                                            if (b[a] === "\n") {
                                                lines = lines + 1;
                                            }
                                        } while (a < c - 1 && (/\s/).test(b[a + 1]) === true);
                                    }
                                    if (b[a + 1] === "<") {
                                        ltype = "start";
                                        break;
                                    }
                                }
                                if (b[a] !== ">" && b[a + 1] === "<") {
                                    sparser.parseerror = `SGML tag ${lex.join("")} is missing termination with '[' or '>'.`;
                                    break;
                                }
                            }
                            if (options.language === "jsx") {
                                if (b[a] === "{") {
                                    jsxcount = jsxcount + 1;
                                }
                                else if (b[a] === "}") {
                                    jsxcount = jsxcount - 1;
                                }
                            }
                            if (data.types[parse.count] === "sgml" && b[a] === "[" && lex.length > 4) {
                                data.types[parse.count] = "template_start";
                                count.start = count.start + 1;
                                break;
                            }
                            if (b[a] === "<" && options.language !== "coldfusion" && preserve === false && lex.length > 1 && end !== ">>" && end !== ">>>" && simple === true) {
                                sparser.parseerror = `Parse error on line ${parse.lineNumber} on element: ${lex.join("")}`;
                            }
                            if (stest === true && (/\s/).test(b[a]) === false && b[a] !== lastchar) {
                                //attribute start
                                stest = false;
                                quote = jsxquote;
                                igcount = 0;
                                lex.pop();
                                if (a < c) {
                                    do {
                                        if (b[a] === "\n") {
                                            parse.lineNumber = parse.lineNumber + 1;
                                        }
                                        if (options.lexer_options.markup.unformatted === true) {
                                            lex.push(b[a]);
                                        }
                                        else {
                                            attribute.push(b[a]);
                                        }
                                        if ((b[a] === "<" || b[a] === ">") && (quote === "" || quote === ">") && options.language !== "jsx") {
                                            if (quote === "" && b[a] === "<") {
                                                quote = ">";
                                                braccount = 1;
                                            }
                                            else if (quote === ">") {
                                                if (b[a] === "<") {
                                                    braccount = braccount + 1;
                                                }
                                                else if (b[a] === ">") {
                                                    braccount = braccount - 1;
                                                    if (braccount === 0) {
                                                        // the following detects if a coldfusion tag is embedded within another markup
                                                        // tag
                                                        tname = tagName(attribute.join(""));
                                                        if (cftags[tname] === "required") {
                                                            quote = "</" + tname + ">";
                                                        }
                                                        else {
                                                            quote = "";
                                                            igcount = 0;
                                                            attributeLexer(false);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        else if (quote === "") {
                                            if (b[a + 1] === lastchar) {
                                                //if at end of tag
                                                if (attribute[attribute.length - 1] === "/" || (attribute[attribute.length - 1] === "?" && ltype === "xml")) {
                                                    attribute.pop();
                                                    if (preserve === true) {
                                                        lex.pop();
                                                    }
                                                    a = a - 1;
                                                }
                                                if (attribute.length > 0) {
                                                    attributeLexer(false);
                                                }
                                                break;
                                            }
                                            if ((/^=?("|')?((\{(\{|%|#|@|:|\/|\?|\^|<|\+|~|=))|(\[%)|<)/).test(b[a] + b[a + 1] + b[a + 2] + b[a + 3]) === true) {
                                                attribute.pop();
                                                if (b[a] !== "=" && attribute.length > 0) {
                                                    attributeLexer(false);
                                                }
                                                quote = "";
                                                do {
                                                    attribute.push(b[a]);
                                                    if (b[a] === dustatt[dustatt.length - 1]) {
                                                        dustatt.pop();
                                                        if (b[a] === "}" && b[a + 1] === "}") {
                                                            attribute.push("}");
                                                            a = a + 1;
                                                            if (b[a + 1] === "}") {
                                                                attribute.push("}");
                                                                a = a + 1;
                                                            }
                                                        }
                                                        if (dustatt.length < 1) {
                                                            attributeLexer(false);
                                                            b[a] = " ";
                                                            break;
                                                        }
                                                    }
                                                    else if ((b[a] === "\"" || b[a] === "'") && dustatt[dustatt.length - 1] !== "\"" && dustatt[dustatt.length - 1] !== "'") {
                                                        dustatt.push(b[a]);
                                                    }
                                                    else if (b[a] === "{" && "{%#@:/?^<+~=".indexOf(b[a + 1]) && dustatt[dustatt.length - 1] !== "}") {
                                                        dustatt.push("}");
                                                    }
                                                    else if (b[a] === "<" && dustatt[dustatt.length - 1] !== ">") {
                                                        dustatt.push(">");
                                                    }
                                                    else if (b[a] === "[" && b[a + 1] === ":" && dustatt[dustatt.length - 1] !== "]") {
                                                        dustatt.push("]");
                                                    }
                                                    a = a + 1;
                                                } while (a < c);
                                            }
                                            else if (b[a] === "{" && b[a - 1] === "=" && options.language !== "jsx") {
                                                quote = "}";
                                            }
                                            else if (b[a] === "\"" || b[a] === "'") {
                                                quote = b[a];
                                                if (b[a - 1] === "=" &&
                                                    (b[a + 1] === "<" ||
                                                        (b[a + 1] === "{" && b[a + 2] === "%") ||
                                                        ((/\s/).test(b[a + 1]) === true && b[a - 1] !== "="))) {
                                                    igcount = a;
                                                }
                                            }
                                            else if (b[a] === "(") {
                                                quote = ")";
                                                parncount = 1;
                                            }
                                            else if (options.language === "jsx") {
                                                //jsx variable attribute
                                                if ((b[a - 1] === "=" || (/\s/).test(b[a - 1]) === true) && b[a] === "{") {
                                                    quote = "}";
                                                    bcount = 1;
                                                }
                                                else if (b[a] === "/") {
                                                    //jsx comments
                                                    if (b[a + 1] === "*") {
                                                        quote = "\u002a/";
                                                    }
                                                    else if (b[a + 1] === "/") {
                                                        quote = "\n";
                                                    }
                                                }
                                            }
                                            else if (lex[0] !== "{" && b[a] === "{" && (b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                                                //opening embedded template expression
                                                if (b[a + 1] === "{") {
                                                    if (b[a + 2] === "{") {
                                                        quote = "}}}";
                                                    }
                                                    else {
                                                        quote = "}}";
                                                    }
                                                }
                                                else {
                                                    quote = b[a + 1] + "}";
                                                }
                                            }
                                            if ((/\s/).test(b[a]) === true && quote === "") {
                                                // testing for a run of spaces between an attribute's = and a quoted value.
                                                // Unquoted values separated by space are separate attributes
                                                if (attribute[attribute.length - 2] === "=") {
                                                    e = a + 1;
                                                    if (e < c) {
                                                        do {
                                                            if ((/\s/).test(b[e]) === false) {
                                                                if (b[e] === "\"" || b[e] === "'") {
                                                                    a = e - 1;
                                                                    quotetest = true;
                                                                    attribute.pop();
                                                                }
                                                                break;
                                                            }
                                                            e = e + 1;
                                                        } while (e < c);
                                                    }
                                                }
                                                if (quotetest === true) {
                                                    quotetest = false;
                                                }
                                                else if (jsxcount === 0 || (jsxcount === 1 && attribute[0] === "{")) {
                                                    //if there is an unquoted space attribute is complete
                                                    attribute.pop();
                                                    attributeLexer(false);
                                                    stest = true;
                                                    break;
                                                }
                                            }
                                        }
                                        else if (b[a] === "(" && quote === ")") {
                                            parncount = parncount + 1;
                                        }
                                        else if (b[a] === ")" && quote === ")") {
                                            parncount = parncount - 1;
                                            if (parncount === 0) {
                                                quote = "";
                                                if (b[a + 1] === end.charAt(0)) {
                                                    attributeLexer(false);
                                                    break;
                                                }
                                            }
                                        }
                                        else if (options.language === "jsx" && (quote === "}" || (quote === "\n" && b[a] === "\n") || (quote === "\u002a/" && b[a - 1] === "*" && b[a] === "/"))) {
                                            //jsx attributes
                                            if (quote === "}") {
                                                if (b[a] === "{") {
                                                    bcount = bcount + 1;
                                                }
                                                else if (b[a] === quote) {
                                                    bcount = bcount - 1;
                                                    if (bcount === 0) {
                                                        jsxcount = 0;
                                                        quote = "";
                                                        element = attribute.join("");
                                                        if (options.lexer_options.markup.unformatted === false) {
                                                            if (options.language === "jsx") {
                                                                if ((/^(\s*)$/).test(element) === false) {
                                                                    attstore.push([element, lines]);
                                                                }
                                                            }
                                                            else {
                                                                element = element.replace(/\s+/g, " ");
                                                                if (element !== " ") {
                                                                    attstore.push([element, lines]);
                                                                }
                                                            }
                                                        }
                                                        attribute = [];
                                                        lines = 1;
                                                        break;
                                                    }
                                                }
                                            }
                                            else {
                                                jsxquote = "";
                                                jscom = true;
                                                element = attribute.join("");
                                                if (element !== " ") {
                                                    attstore.push([element, lines]);
                                                }
                                                attribute = [];
                                                lines = (quote === "\n")
                                                    ? 2
                                                    : 1;
                                                quote = "";
                                                break;
                                            }
                                        }
                                        else if (b[a] === "{" && b[a + 1] === "%" && b[igcount - 1] === "=" && (quote === "\"" || quote === "'")) {
                                            quote = quote + "{%";
                                            igcount = 0;
                                        }
                                        else if (b[a - 1] === "%" && b[a] === "}" && (quote === "\"{%" || quote === "'{%")) {
                                            quote = quote.charAt(0);
                                            igcount = 0;
                                        }
                                        else if (b[a] === "<" && end === ">" && b[igcount - 1] === "=" && (quote === "\"" || quote === "'")) {
                                            quote = quote + "<";
                                            igcount = 0;
                                        }
                                        else if (b[a] === ">" && (quote === "\"<" || quote === "'<")) {
                                            quote = quote.charAt(0);
                                            igcount = 0;
                                        }
                                        else if (igcount === 0 && quote !== ">" && (quote.length < 2 || (quote.charAt(0) !== "\"" && quote.charAt(0) !== "'"))) {
                                            //terminate attribute at the conclusion of a quote pair
                                            f = 0;
                                            if (lex.length > 1) {
                                                tname = lex[1] + lex[2];
                                                tname = tname.toLowerCase();
                                            }
                                            // in coldfusion quotes are escaped in a string with double the characters:
                                            // "cat"" and dog"
                                            if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\"" || b[a] === "'")) {
                                                attribute.push(b[a + 1]);
                                                a = a + 1;
                                            }
                                            else {
                                                e = quote.length - 1;
                                                if (e > -1) {
                                                    do {
                                                        if (b[a - f] !== quote.charAt(e)) {
                                                            break;
                                                        }
                                                        f = f + 1;
                                                        e = e - 1;
                                                    } while (e > -1);
                                                }
                                                if (e < 0) {
                                                    attributeLexer(true);
                                                    if (b[a + 1] === lastchar) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        else if (igcount > 0 && (/\s/).test(b[a]) === false) {
                                            igcount = 0;
                                        }
                                        a = a + 1;
                                    } while (a < c);
                                }
                            }
                            else if (end !== "%>" && end !== "\n" && (b[a] === "\"" || b[a] === "'")) {
                                //opening quote
                                quote = b[a];
                            }
                            else if (ltype !== "comment" && end !== "\n" && b[a] === "<" && b[a + 1] === "!" && b[a + 2] === "-" && b[a + 3] === "-" && b[a + 4] !== "#" && data.types[parse.count] !== "conditional") {
                                quote = "-->";
                            }
                            else if (b[a] === "{" && lex[0] !== "{" && end !== "\n" && end !== "%>" && end !== "%]" && (options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                                //opening embedded template expression
                                if (b[a + 1] === "{") {
                                    if (b[a + 2] === "{") {
                                        quote = "}}}";
                                    }
                                    else {
                                        quote = "}}";
                                    }
                                }
                                else if (options.language === "dustjs") {
                                    if (attribute.length < 1 && (attstore.length < 1 || (/\s/).test(b[a - 1]) === true)) {
                                        lex.pop();
                                        do {
                                            if (b[a] === "\n") {
                                                lines = lines + 1;
                                            }
                                            attribute.push(b[a]);
                                            a = a + 1;
                                        } while (a < c && b[a] !== "}");
                                        attribute.push("}");
                                        attstore.push([attribute.join(""), lines]);
                                        attribute = [];
                                        lines = 1;
                                    }
                                    else {
                                        quote = "}";
                                    }
                                }
                                else {
                                    quote = b[a + 1] + "}";
                                    if (attribute.length < 1 && (attstore.length < 1 || (/\s/).test(b[a - 1]) === true)) {
                                        lex.pop();
                                        do {
                                            if (b[a] === "\n") {
                                                lines = lines + 1;
                                            }
                                            attribute.push(b[a]);
                                            a = a + 1;
                                        } while (a < c && b[a - 1] + b[a] !== quote);
                                        attribute.push("}");
                                        attstore.push([attribute.join(""), lines]);
                                        attribute = [];
                                        lines = 1;
                                        quote = "";
                                    }
                                }
                                if (quote === end) {
                                    quote = "";
                                }
                            }
                            else if ((simple === true || ltype === "sgml") && end !== "\n" && (/\s/).test(b[a]) === true && b[a - 1] !== "<") {
                                //identify a space in a regular start or singleton tag
                                if (ltype === "sgml") {
                                    lex.push(" ");
                                }
                                else {
                                    stest = true;
                                }
                            }
                            else if (simple === true && options.language === "jsx" && b[a] === "/" && (b[a + 1] === "*" || b[a + 1] === "/")) {
                                //jsx comment immediately following tag name
                                stest = true;
                                lex[lex.length - 1] = " ";
                                attribute.push(b[a]);
                                if (b[a + 1] === "*") {
                                    jsxquote = "\u002a/";
                                }
                                else {
                                    jsxquote = "\n";
                                }
                            }
                            else if ((b[a] === lastchar || (end === "\n" && b[a + 1] === "<")) && (lex.length > end.length + 1 || lex[0] === "]") && (options.language !== "jsx" || jsxcount === 0)) {
                                if (end === "\n") {
                                    if ((/\s/).test(lex[lex.length - 1]) === true) {
                                        do {
                                            lex.pop();
                                            a = a - 1;
                                        } while ((/\s/).test(lex[lex.length - 1]) === true);
                                    }
                                    break;
                                }
                                if (lex[0] === "{" && lex[1] === "%" && lex.join("").replace(/\s+/g, "") === "{%comment%}") {
                                    end = "endcomment";
                                    lastchar = "t";
                                    preserve = true;
                                    ltype = "comment";
                                }
                                else if (lex[0] === "{" && lex[1] === "%" && lex[2] === "-" && lex.join("").replace(/\s+/g, "") === "{%-comment-%}") {
                                    end = "endcomment";
                                    lastchar = "t";
                                    preserve = true;
                                    ltype = "comment";
                                }
                                else {
                                    //if current character matches the last character of the tag ending sequence
                                    f = lex.length;
                                    e = end.length - 1;
                                    if (e > -1) {
                                        do {
                                            f = f - 1;
                                            if (lex[f] !== end.charAt(e)) {
                                                break;
                                            }
                                            e = e - 1;
                                        } while (e > -1);
                                    }
                                    if (e < 0) {
                                        break;
                                    }
                                }
                            }
                        }
                        else if (b[a] === quote.charAt(quote.length - 1) && ((options.language === "jsx" && end === "}" && (b[a - 1] !== "\\" || slashy() === false)) || options.language !== "jsx" || end !== "}")) {
                            //find the closing quote or embedded template expression
                            f = 0;
                            if (lex.length > 1) {
                                tname = lex[1] + lex[2];
                                tname = tname.toLowerCase();
                            }
                            // in coldfusion quotes are escaped in a string with double the characters:
                            // "cat"" and dog"
                            if (tname === "cf" && b[a] === b[a + 1] && (b[a] === "\"" || b[a] === "'")) {
                                attribute.push(b[a + 1]);
                                a = a + 1;
                            }
                            else {
                                e = quote.length - 1;
                                if (e > -1) {
                                    do {
                                        if (b[a - f] !== quote.charAt(e)) {
                                            break;
                                        }
                                        f = f + 1;
                                        e = e - 1;
                                    } while (e > -1);
                                }
                                if (e < 0) {
                                    quote = "";
                                }
                            }
                        }
                    }
                    a = a + 1;
                } while (a < c);
                //nopush flags mean an early exit
                if (nopush) {
                    return;
                }
                //a correction to incomplete template tags that use multiple angle braces
                if (options.correct === true) {
                    if (b[a + 1] === ">" && lex[0] === "<" && lex[1] !== "<") {
                        do {
                            a = a + 1;
                        } while (b[a + 1] === ">");
                    }
                    else if (lex[0] === "<" && lex[1] === "<" && b[a + 1] !== ">" && lex[lex.length - 2] !== ">") {
                        do {
                            lex.splice(1, 1);
                        } while (lex[1] === "<");
                    }
                }
                igcount = 0;
                element = lex.join("");
                tname = tagName(element);
                element = bracketSpace(element);
                if (tname === "xml") {
                    html = "xml";
                }
                else if (html === "" && tname === "!DOCTYPE" && element.toLowerCase().indexOf("xhtml") > 0) {
                    html = "xml";
                }
                else if (html === "" && tname === "html") {
                    html = "html";
                }
                if (element.replace(start, "").replace(/^\s+/, "").indexOf("parse-ignore-start") === 0) {
                    a = a + 1;
                    do {
                        lex.push(b[a]);
                        if (b[a] === "d" && lex.slice(lex.length - 16).join("") === "parse-ignore-end") {
                            break;
                        }
                        a = a + 1;
                    } while (a < c);
                    do {
                        lex.push(b[a]);
                        if (b[a] === end.charAt(end.length - 1) && b.slice(a - (end.length - 1), a + 1).join("") === end) {
                            break;
                        }
                        a = a + 1;
                    } while (a < c);
                    record.token = lex.join("");
                    record.types = "ignore";
                    recordPush(data, record, "");
                    return;
                }
            }
            record.token = element;
            record.types = ltype;
            tname = tagName(element);
            // Twig language allows {% block %} elements to be singleton or start.  You don't
            // know until you encounter a {% endblock %} tag
            if (tname === "endblock" && element.slice(0, 2) === "{%") {
                const endName = element.replace(/\{%\s*endblock\s+/, "").replace(/\s*%\}/, "");
                let aa = parse.count, bb = parse.count, startName = "";
                do {
                    if (data.types[aa].indexOf("end") > 0) {
                        aa = data.begin[aa];
                        if (aa < 0) {
                            break;
                        }
                    }
                    else if ((/\{%\s*block/).test(data.token[aa]) === true) {
                        if (endName === "") {
                            break;
                        }
                        startName = data.token[aa].replace(/\{%\s*block\s+/, "").split(/\s+/)[0].replace(/\s+/, "");
                        if (endName === startName) {
                            break;
                        }
                    }
                    aa = aa - 1;
                } while (aa > -1);
                count.start = count.start + 1;
                data.types[aa] = "template_start";
                data.ender[aa] = parse.count + 1;
                record.begin = aa;
                record.stack = "block";
                record.token = element;
                record.types = "template_end";
                if (aa > -1) {
                    do {
                        if (data.types[bb].indexOf("end") > 0) {
                            bb = data.begin[bb];
                            data.begin[bb] = aa;
                            data.stack[bb] = "block";
                        }
                        else if (data.begin[bb] < aa) {
                            data.begin[bb] = aa;
                            if (data.types[bb].indexOf("start") < 0) {
                                data.ender[bb] = parse.count + 1;
                            }
                            data.stack[bb] = "block";
                        }
                        bb = bb - 1;
                    } while (bb > aa);
                }
                parse.structure.push(["block", aa]);
                recordPush(data, record, "");
                return;
            }
            if ((/^(\/?cf)/i).test(tname) === true) {
                tname = tname
                    .toLowerCase()
                    .replace(/\/$/, "")
                    .replace(/^\//, "");
            }
            if (preserve === false && options.language !== "jsx") {
                element = element.replace(/\s+/g, " ");
            }
            //a quick hack to inject records for a type of template comments
            if (tname === "comment" && element.slice(0, 2) === "{%") {
                const lineFindStart = function lexer_markup_tag_lineFindStart(spaces) {
                    if (spaces === "") {
                        linesStart = 0;
                    }
                    else {
                        linesStart = spaces.split("\n").length;
                    }
                    return "";
                }, lineFindEnd = function lexer_markup_tag_lineFindEnd(spaces) {
                    if (spaces === "") {
                        linesEnd = 0;
                    }
                    else {
                        linesEnd = spaces.split("\n").length;
                    }
                    return "";
                };
                let linesStart = 0, linesEnd = 0;
                record.begin = parse.structure[parse.structure.length - 1][1];
                record.ender = parse.count + 3;
                record.stack = parse.structure[parse.structure.length - 1][0];
                record.types = "template_start";
                if (element.charAt(2) === "-") {
                    element = element
                        .replace(/^(\s*\{%-\s*comment\s*-%\})/, "")
                        .replace(/(\{%-\s*endcomment\s*-%\}\s*)$/, "");
                    record.token = "{%- comment -%}";
                    recordPush(data, record, "comment");
                    record.begin = parse.count;
                    element = element.replace(/^\s*/, lineFindStart);
                    element = element.replace(/\s*$/, lineFindEnd);
                    record.lines = linesStart;
                    record.stack = "comment";
                    record.token = element;
                    record.types = "comment";
                    recordPush(data, record, "");
                    record.token = "{%- endcomment -%}";
                }
                else {
                    element = element
                        .replace(/^(\s*\{%\s*comment\s*%\})/, "")
                        .replace(/(\{%\s*endcomment\s*%\}\s*)$/, "");
                    record.token = "{% comment %}";
                    recordPush(data, record, "comment");
                    record.begin = parse.count;
                    element = element.replace(/^\s*/, lineFindStart);
                    element = element.replace(/\s*$/, lineFindEnd);
                    record.lines = linesStart;
                    record.stack = "comment";
                    record.token = element;
                    record.types = "comment";
                    recordPush(data, record, "");
                    record.token = "{% endcomment %}";
                }
                record.lines = linesEnd;
                record.types = "template_end";
                recordPush(data, record, "");
                return;
            }
            // a type correction for template tags who have variable start tag names but a
            // consistent ending tag name
            if (element.indexOf("{{") === 0 && element.slice(element.length - 2) === "}}") {
                if (tname === "end") {
                    ltype = "template_end";
                }
                else if (tname === "else") {
                    ltype = "template_else";
                }
            }
            else if (element.slice(0, 2) === "<%" && element.slice(element.length - 2) === "%>") {
                if ((/^(<%\s+end\s+-?%>)$/).test(element) === true) {
                    ltype = "template_end";
                }
                else if (((/\sdo\s/).test(element) === true && (/\s-?%>$/).test(element) === true) || (/^(<%(%|-|=)?\s*if)/).test(element) === true) {
                    ltype = "template_start";
                }
            }
            record.types = ltype;
            //update a flag for subatomic parsing in SGML tags
            if (end !== "]>" && sgmlflag > 0 && element.charAt(element.length - 1) !== "[" && (element.slice(element.length - 2) === "]>" || (/^(<!((doctype)|(notation))\s)/i).test(element) === true)) {
                sgmlflag = sgmlflag - 1;
            }
            // cheat identifies HTML singleton elements as singletons even if formatted as
            // start tags, such as <br> (which is really <br/>)
            cheat = (function lexer_markup_tag_cheat() {
                let cfval = "", struc = [];
                const ender = (/(\/>)$/), htmlsings = {
                    area: "singleton",
                    base: "singleton",
                    basefont: "singleton",
                    br: "singleton",
                    col: "singleton",
                    embed: "singleton",
                    eventsource: "singleton",
                    frame: "singleton",
                    hr: "singleton",
                    image: "singleton",
                    img: "singleton",
                    input: "singleton",
                    isindex: "singleton",
                    keygen: "singleton",
                    link: "singleton",
                    meta: "singleton",
                    param: "singleton",
                    progress: "singleton",
                    source: "singleton",
                    wbr: "singleton"
                }, fixsingleton = function lexer_markup_tag_cheat_fixsingleton() {
                    let aa = parse.count, bb = 0;
                    const vname = tname.slice(1);
                    if (aa > -1) {
                        do {
                            if (data.types[aa] === "end") {
                                bb = bb + 1;
                            }
                            else if (data.types[aa] === "start") {
                                bb = bb - 1;
                                if (bb < 0) {
                                    return false;
                                }
                            }
                            if (bb === 0 && data.token[aa].toLowerCase().indexOf(vname) === 1) {
                                if (cftags[tname] === undefined) {
                                    data.types[aa] = "start";
                                }
                                else {
                                    data.types[aa] = "template_start";
                                }
                                count.start = count.start + 1;
                                data.token[aa] = data
                                    .token[aa]
                                    .replace(/(\s*\/>)$/, ">");
                                return false;
                            }
                            aa = aa - 1;
                        } while (aa > -1);
                    }
                    return false;
                }, peertest = function lexer_markup_tag_cheat_peertest(name, item) {
                    if (htmlblocks[name] === undefined) {
                        return false;
                    }
                    if (name === item) {
                        return true;
                    }
                    if (name === "dd" && item === "dt") {
                        return true;
                    }
                    if (name === "dt" && item === "dd") {
                        return true;
                    }
                    if (name === "td" && item === "th") {
                        return true;
                    }
                    if (name === "th" && item === "td") {
                        return true;
                    }
                    if (name === "colgroup" && (item === "tbody" || item === "tfoot" || item === "thead" || item === "tr")) {
                        return true;
                    }
                    if (name === "tbody" && (item === "colgroup" || item === "tfoot" || item === "thead")) {
                        return true;
                    }
                    if (name === "tfoot" && (item === "colgroup" || item === "tbody" || item === "thead")) {
                        return true;
                    }
                    if (name === "thead" && (item === "colgroup" || item === "tbody" || item === "tfoot")) {
                        return true;
                    }
                    if (name === "tr" && item === "colgroup") {
                        return true;
                    }
                    return false;
                }, addHtmlEnd = function (count) {
                    record.lines = (data.lines[parse.count] > 0) ? 1 : 0;
                    record.token = `</${parse.structure[parse.structure.length - 1][0]}>`;
                    record.types = "end";
                    recordPush(data, record, "");
                    if (count > 0) {
                        do {
                            record.begin = parse.structure[parse.structure.length - 1][1];
                            record.stack = parse.structure[parse.structure.length - 1][0];
                            record.token = `</${parse.structure[parse.structure.length - 1][0]}>`;
                            recordPush(data, record, "");
                            count = count - 1;
                        } while (count > 0);
                    }
                    record.begin = parse.structure[parse.structure.length - 1][1];
                    record.lines = parse.linesSpace;
                    record.stack = parse.structure[parse.structure.length - 1][0];
                    record.token = element;
                    record.types = "end";
                    data.lines[parse.count - 1] = 0;
                };
                //determine if the current end tag is actually part of an HTML singleton
                if (ltype === "end" && tname.slice(0, 3) !== "/cf") {
                    const lastToken = data.token[parse.count];
                    if (data.types[parse.count - 1] === "singleton" && lastToken.charAt(lastToken.length - 2) !== "/" && "/" + tagName(lastToken) === tname) {
                        data.types[parse.count - 1] = "start";
                    }
                    else if (tname !== "/span" &&
                        tname !== "/div" &&
                        tname !== "/script" &&
                        options.lexer_options.markup.tag_merge === true &&
                        (html !== "html" || (html === "html" && tname !== "/li"))) {
                        if (tname === "/" + tagName(data.token[parse.count]) && data.types[parse.count] === "start") {
                            parse.structure.pop();
                            data.token[parse.count] = data
                                .token[parse.count]
                                .replace(/>$/, "/>");
                            data.types[parse.count] = "singleton";
                            singleton = true;
                            count.start = count.start - 1;
                            return false;
                        }
                        if (tname === "/" + tagName(data.token[data.begin[parse.count]]) && data.types[parse.count].indexOf("attribute") > -1 && data.types[data.begin[parse.count]] === "start") {
                            parse.structure.pop();
                            data.token[data.begin[parse.count]] = data
                                .token[data.begin[parse.count]]
                                .replace(/>$/, "/>");
                            data.types[data.begin[parse.count]] = "singleton";
                            singleton = true;
                            count.start = count.start - 1;
                            return false;
                        }
                    }
                }
                //renames the types value for the following two template tags
                if (tname === "/#assign" || tname === "/#global") {
                    let dd = parse.count - 1, tcount = 1;
                    if (dd > -1) {
                        do {
                            if (data.types[dd] === "start" || data.types[dd] === "template_start") {
                                tcount = tcount - 1;
                            }
                            else if (data.types[dd] === "end" || data.types[dd] === "template_end") {
                                tcount = tcount + 1;
                            }
                            if (tcount === 1) {
                                if ((data.token[dd].indexOf("<#assign") === 0 && tname === "/#assign") || (data.token[dd].indexOf("<#global") === 0 && tname === "/#global")) {
                                    data.types[dd] = "template_start";
                                    count.start = count.start + 1;
                                    return false;
                                }
                            }
                            if (tcount === 0) {
                                return false;
                            }
                            dd = dd - 1;
                        } while (dd > -1);
                    }
                    return false;
                }
                //determines if custom coldfusion tags are singletons
                cfval = cftags[tname];
                if (data.types[parse.count] === "end" && tname.slice(0, 3) === "/cf" && cfval !== undefined) {
                    if (tname === "/cftransaction") {
                        cftransaction = false;
                    }
                    if (cfval !== undefined) {
                        data.types[parse.count] = "template_end";
                    }
                    if ((cfval === "optional" || cfval === "prohibited") && tname !== "/cftransaction") {
                        return fixsingleton();
                    }
                    return false;
                }
                //processes all other coldfusion tags
                if (tname.slice(0, 2) === "cf") {
                    if (tname === "cfelse" || tname === "cfelseif") {
                        record.token = element;
                        record.types = "template_else";
                        recordPush(data, record, tname);
                        singleton = true;
                        return false;
                    }
                    if (tname === "cftransaction" && cftransaction === true) {
                        if (element.charAt(1) === "/") {
                            record.types = "template_end";
                        }
                        else {
                            cfval = "prohibited";
                        }
                    }
                    else {
                        cfval = cftags[tname];
                    }
                    if (tname === "cfscript" && element.indexOf("</cfscript") !== 0) {
                        ext = true;
                    }
                    if (cfval === "optional" || cfval === "prohibited" || tname.slice(0, 3) === "cf_") {
                        if (options.correct === true && ender.test(element) === false) {
                            element = element.slice(0, element.length - 1) + "/>";
                        }
                        record.token = element.replace(/\s+/, " ");
                        record.types = "template";
                        // The following madness is required because cfmodule may be a singleton or a block.
                        // You don't know until you encounter the end tag
                        if (tname === "cfmodule" && element.charAt(1) === "/") {
                            let ss = parse.count, tt = 1;
                            do {
                                if (data.token[ss].toLowerCase() === "<cfmodule>") {
                                    tt = tt - 1;
                                    if (tt < 1) {
                                        break;
                                    }
                                }
                                else if (data.token[ss].toLowerCase() === "</cfmodule>") {
                                    tt = tt + 1;
                                }
                                ss = ss - 1;
                            } while (ss > -1);
                            data.types[ss] = "template_start";
                            count.start = count.start + 1;
                            tt = Math.min(ss + 1, parse.count);
                            struc = [["cfmodule", ss]];
                            ss = parse.count + 1;
                            do {
                                data.begin[tt] = struc[struc.length - 1][1];
                                data.stack[tt] = struc[struc.length - 1][0];
                                if (data.types[tt] === "end" || data.types[tt].indexOf("_end") > 0) {
                                    if (struc.length > 1) {
                                        struc.pop();
                                    }
                                }
                                else if (data.types[tt] === "start" || data.types[tt].indexOf("_start") > 0) {
                                    struc.push([tagName(data.token[tt]), tt]);
                                }
                                tt = tt + 1;
                            } while (tt < ss);
                            parse.structure.push(struc[0]);
                            record.begin = struc[0][1];
                            record.stack = "cfmodule";
                            record.types = "template_end";
                        }
                        recordPush(data, record, "");
                        singleton = true;
                        return false;
                    }
                    if (cfval === "required" && tname !== "cfquery") {
                        if (tname === "cftransaction" && cftransaction === false) {
                            cftransaction = true;
                        }
                        record.token = element;
                        record.types = (ltype === "end")
                            ? "template_end"
                            : "template_start";
                        recordPush(data, record, tname);
                        singleton = true;
                    }
                    return false;
                }
                if (html === "html") {
                    // html gets tag names in lowercase, if you want to preserve case sensitivity
                    // beautify as XML
                    if (element.charAt(0) === "<" && element.charAt(1) !== "!" && element.charAt(1) !== "?" && (parse.count < 0 || data.types[parse.count].indexOf("template") < 0) && cftags[tname] === undefined && tname.slice(0, 3) !== "cf_") {
                        element = element.toLowerCase();
                    }
                    if (htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && peertest(tname.slice(1), parse.structure[parse.structure.length - 2][0]) === true) {
                        // looks for HTML tags missing an ending pair when encountering an ending tag for a parent node
                        addHtmlEnd(0);
                    }
                    else if (parse.structure.length > 3 &&
                        htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" &&
                        htmlblocks[parse.structure[parse.structure.length - 2][0]] === "block" &&
                        htmlblocks[parse.structure[parse.structure.length - 3][0]] === "block" &&
                        peertest(tname, parse.structure[parse.structure.length - 4][0]) === true) {
                        // looks for consecutive missing end tags
                        addHtmlEnd(3);
                    }
                    else if (parse.structure.length > 2 &&
                        htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" &&
                        htmlblocks[parse.structure[parse.structure.length - 2][0]] === "block" &&
                        peertest(tname, parse.structure[parse.structure.length - 3][0]) === true) {
                        // looks for consecutive missing end tags
                        addHtmlEnd(2);
                    }
                    else if (parse.structure.length > 1 &&
                        htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" &&
                        peertest(tname, parse.structure[parse.structure.length - 2][0]) === true) {
                        // looks for consecutive missing end tags
                        addHtmlEnd(1);
                    }
                    else if (peertest(tname, parse.structure[parse.structure.length - 1][0]) === true) {
                        // certain tags cannot contain other certain tags if such tags are peers
                        addHtmlEnd(0);
                    }
                    else if (tname.charAt(0) === "/" && htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block" && parse.structure[parse.structure.length - 1][0] !== tname.slice(1)) {
                        // looks for consecutive missing end tags if the current element is an end tag
                        fixHtmlEnd(element, false);
                        record.begin = parse.structure[parse.structure.length - 1][1];
                        record.lines = parse.linesSpace;
                        record.stack = parse.structure[parse.structure.length - 1][0];
                        record.token = element;
                        record.types = "end";
                        data.lines[parse.count - 1] = 0;
                    }
                    // generalized corrections for the handling of singleton tags
                    if (data.types[parse.count] === "end" && htmlsings[tname.slice(1)] === "singleton" && element.toLowerCase().indexOf("/cftransaction") !== 1) {
                        return fixsingleton();
                    }
                    //inserts a trailing slash into singleton tags if they do not already have it
                    if (htmlsings[tname] === "singleton") {
                        if (options.correct === true && ender.test(element) === false) {
                            element = element.slice(0, element.length - 1) + " />";
                        }
                        return true;
                    }
                }
                return false;
            }());
            //This escape flag is set in the cheat function
            if (singleton === true) {
                attributeRecord();
                return;
            }
            //tags with the following names are singletons
            if (tname.charAt(0) === "#" && data.types[parse.count] === "start" && (tname === "#assign" || tname === "#break" || tname === "#case" || tname === "#default" || tname === "#fallback" || tname === "#flush" || tname === "#ftl" || tname === "#global" || tname === "#import" || tname === "#include" || tname === "#local" || tname === "#t" || tname === "#lt" || tname === "#rt" || tname === "#nested" || tname === "#nt" || tname === "#recover" || tname === "#recurse" || tname === "#return" || tname === "#sep" || tname === "#setting" || tname === "#stop" || tname === "#visit")) {
                simple = true;
            }
            //correction for dustjs tags to template singleton types
            if (options.language === "dustjs" && data.types[parse.count] === "template_start") {
                const first = element.charAt(1), ending = element.slice(element.length - 2);
                if ((ending === "/}" || ending.charAt(0) === first) && (first === "#" || first === "?" || first === "^" || first === "@" || first === "<" || first === "+")) {
                    data.types[parse.count] = "template";
                }
            }
            // determine if the markup tag potentially contains code interpreted by a
            // different lexer
            if ((tname === "script" || tname === "style" || tname === "cfscript") && element.slice(element.length - 2) !== "/>") {
                //get the attribute value for "type"
                let len = attstore.length - 1, attValue = "", attr = [];
                if (len > -1) {
                    do {
                        attr = arname(attstore[len][0]);
                        if (attr[0] === "type") {
                            attValue = attr[1];
                            if (attValue.charAt(0) === "\"" || attValue.charAt(0) === "'") {
                                attValue = attValue.slice(1, attValue.length - 1);
                            }
                            break;
                        }
                        len = len - 1;
                    } while (len > -1);
                }
                //ext is flag to send information between the tag lexer and the content lexer
                if (tname === "script" && (attValue === "" || attValue === "text/javascript" || attValue === "babel" || attValue === "module" || attValue === "application/javascript" || attValue === "application/x-javascript" || attValue === "text/ecmascript" || attValue === "application/ecmascript" || attValue === "text/jsx" || attValue === "application/jsx" || attValue === "text/cjs")) {
                    ext = true;
                }
                else if (tname === "style" && options.language !== "jsx" && (attValue === "" || attValue === "text/css")) {
                    ext = true;
                }
                else if (tname === "cfscript") {
                    ext = true;
                }
                if (ext === true) {
                    len = a + 1;
                    if (len < c) {
                        do {
                            if ((/\s/).test(b[len]) === false) {
                                if (b[len] === "<") {
                                    if (b.slice(len + 1, len + 4).join("") === "!--") {
                                        len = len + 4;
                                        if (len < c) {
                                            do {
                                                if ((/\s/).test(b[len]) === false) {
                                                    ext = false;
                                                    break;
                                                }
                                                if (b[len] === "\n" || b[len] === "\r") {
                                                    break;
                                                }
                                                len = len + 1;
                                            } while (len < c);
                                        }
                                    }
                                    else {
                                        ext = false;
                                    }
                                }
                                break;
                            }
                            len = len + 1;
                        } while (len < c);
                    }
                }
            }
            //am I a singleton or a start type?
            if (simple === true && ignoreme === false && ltype !== "xml" && ltype !== "sgml") {
                if (cheat === true || element.slice(element.length - 2) === "/>") {
                    ltype = "singleton";
                }
                else {
                    ltype = "start";
                }
                record.types = ltype;
            }
            // additional logic is required to find the end of a tag with the attribute
            // data-parse-ignore
            if (simple === true && preserve === false && ignoreme && end === ">" && element.slice(element.length - 2) !== "/>") {
                let tags = [], atstring = [];
                if (cheat === true) {
                    ltype = "singleton";
                }
                else {
                    attstore.forEach(function lexer_markup_tag_atstore(value) {
                        atstring.push(value[0]);
                    });
                    preserve = true;
                    ltype = "ignore";
                    a = a + 1;
                    if (a < c) {
                        let delim = "", ee = 0, ff = 0, endtag = false;
                        do {
                            if (b[a] === "\n") {
                                parse.lineNumber = parse.lineNumber + 1;
                            }
                            tags.push(b[a]);
                            if (delim === "") {
                                if (b[a] === "\"") {
                                    delim = "\"";
                                }
                                else if (b[a] === "'") {
                                    delim = "'";
                                }
                                else if (tags[0] !== "{" && b[a] === "{" && (options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                                    if (b[a + 1] === "{") {
                                        if (b[a + 2] === "{") {
                                            delim = "}}}";
                                        }
                                        else {
                                            delim = "}}";
                                        }
                                    }
                                    else if (options.language === "dustjs") {
                                        delim = "}";
                                    }
                                    else {
                                        delim = b[a + 1] + "}";
                                    }
                                }
                                else if (b[a] === "<" && simple === true) {
                                    if (b[a + 1] === "/") {
                                        endtag = true;
                                    }
                                    else {
                                        endtag = false;
                                    }
                                }
                                else if (b[a] === lastchar && b[a - 1] !== "/") {
                                    if (endtag === true) {
                                        igcount = igcount - 1;
                                        if (igcount < 0) {
                                            break;
                                        }
                                    }
                                    else {
                                        igcount = igcount + 1;
                                    }
                                }
                            }
                            else if (b[a] === delim.charAt(delim.length - 1)) {
                                ff = 0;
                                ee = delim.length - 1;
                                if (ee > -1) {
                                    do {
                                        if (b[a - ff] !== delim.charAt(ee)) {
                                            break;
                                        }
                                        ff = ff + 1;
                                        ee = ee - 1;
                                    } while (ee > -1);
                                }
                                if (ee < 0) {
                                    delim = "";
                                }
                            }
                            a = a + 1;
                        } while (a < c);
                    }
                }
                element = element + tags.join("");
                element = element.replace(">", ` ${atstring.join(" ")}>`);
                record.token = element;
                record.types = "content-ignore";
                attstore = [];
            }
            // some template tags can be evaluated as a block start/end based on syntax
            // alone
            if (record.types.indexOf("template") > -1) {
                if (element.slice(0, 2) === "{%") {
                    let names = [
                        "autoescape",
                        "case",
                        "capture",
                        "comment",
                        "embed",
                        "filter",
                        "for",
                        "form",
                        "if",
                        "macro",
                        "paginate",
                        "raw",
                        "sandbox",
                        "spaceless",
                        "switch",
                        "tablerow",
                        "unless",
                        "verbatim"
                    ];
                    if ((tname === "case" || tname === "default") && (parse.structure[parse.structure.length - 1][0] === "switch" || parse.structure[parse.structure.length - 1][0] === "case")) {
                        record.types = "template_else";
                    }
                    else if (tname === "else" || tname === "elseif" || tname === "when" || tname === "elif" || tname === "elsif") {
                        record.types = "template_else";
                    }
                    else {
                        let namelen = names.length - 1;
                        do {
                            if (tname === names[namelen]) {
                                record.types = "template_start";
                                break;
                            }
                            if (tname === "end" + names[namelen]) {
                                record.types = "template_end";
                                break;
                            }
                            namelen = namelen - 1;
                        } while (namelen > -1);
                    }
                }
                else if (element.slice(0, 2) === "<%" && options.language === "silverstripe") {
                    if (tname === "if" || tname === "loop" || tname === "with" || tname === "control" || tname === "cached" || tname === "uncached") {
                        record.types = "template_start";
                    }
                    else if (tname === "else" || tname === "else_if") {
                        record.types = "template_else";
                    }
                    else if (tname === "end_if" || tname === "end_loop" || tname === "end_with" || tname === "end_control" || tname === "end_cached" || tname === "end_uncached") {
                        record.types = "template_end";
                    }
                }
                else if (element.slice(0, 2) === "{{" && element.charAt(3) !== "{") {
                    if ((/^(\{\{\s*-?\s*end\s*-?\s*\}\})$/).test(element) === true) {
                        record.types = "template_end";
                    }
                    else if (tname === "define" || tname === "form" || tname === "if" || tname === "range" || tname === "with") {
                        record.types = "template_start";
                    }
                }
                else if (record.types === "template") {
                    if (element.indexOf("else") > 2) {
                        record.types = "template_else";
                    }
                    else if ((/^(<%\s*\})/).test(element) === true || (/^(\[%\s*\})/).test(element) === true || (/^(\{@\s*\})/).test(element) === true) {
                        record.types = "template_end";
                    }
                    else if ((/(\{\s*%>)$/).test(element) === true || (/(\{\s*%\])$/).test(element) === true || (/(\{\s*@\})$/).test(element) === true) {
                        record.types = "template_start";
                    }
                    else if ((/\{\s*\?>$/).test(element) === true) {
                        record.types = "template_start";
                    }
                    else if ((/^<\?(=|(php))\s*\}/).test(element) === true) {
                        record.types = "template_end";
                    }
                }
                if (record.types === "template_start" || record.types === "template_else") {
                    if ((/^<\?(=|(php))\s*/).test(element) === true) {
                        tname = element;
                    }
                    else if (tname === "" || tname === "@" || tname === "#" || tname === "%") {
                        tname = tname + element.slice(1).replace(tname, "").replace(/^\s+/, "");
                        tname = tname.slice(0, tname.indexOf("(")).replace(/\s+/, "");
                    }
                }
            }
            // identify script and style hidden within a CDATA escape
            if (ltype === "cdata" && (record.stack === "script" || record.stack === "style")) {
                let counta = parse.count, countb = parse.count, stack = record.stack;
                if (data.types[countb] === "attribute") {
                    do {
                        counta = counta - 1;
                        countb = countb - 1;
                    } while (data.types[countb] === "attribute" && countb > -1);
                }
                record.begin = counta;
                element = element
                    .replace(/^(\s*<!\[cdata\[)/i, "")
                    .replace(/(\]\]>\s*)$/, "");
                record.token = "<![CDATA[";
                record.types = "cdata_start";
                recordPush(data, record, "");
                parse.structure.push(["cdata", parse.count]);
                if (stack === "script") {
                    sparser.lexers.script(element);
                }
                else {
                    sparser.lexers.style(element);
                }
                record.begin = parse.structure[parse.structure.length - 1][1];
                record.token = "]]>";
                record.types = "cdata_end";
                recordPush(data, record, "");
                parse.structure.pop();
            }
            else {
                recordPush(data, record, tname);
            }
            attributeRecord();
            // inserts a script space in anticipation of word wrap since JSX has unique white space rules
            if (options.wrap > 0 && options.language === "jsx") {
                let current_length = 0, bb = parse.count, cc = 0;
                if (data.types[bb].indexOf("attribute") > -1) {
                    do {
                        current_length = current_length + data.token[bb].length + 1;
                        bb = bb - 1;
                    } while (data.lexer[bb] !== "markup" || data.types[bb].indexOf("attribute") > -1);
                    if (data.lines[bb] === 1) {
                        current_length = current_length + data.token[bb].length + 1;
                    }
                }
                else if (data.lines[bb] === 1) {
                    current_length = data.token[bb].length + 1;
                }
                cc = bb - 1;
                if (current_length > 0 && data.types[cc] !== "script_end") {
                    if (data.types[cc].indexOf("attribute") > -1) {
                        do {
                            current_length = current_length + data.token[cc].length + 1;
                            cc = cc - 1;
                        } while (data.lexer[cc] !== "markup" || data.types[cc].indexOf("attribute") > -1);
                        if (data.lines[cc] === 1) {
                            current_length = current_length + data.token[cc].length + 1;
                        }
                    }
                    else if (data.lines[cc] === 1) {
                        current_length = data.token[cc].length + 1;
                    }
                    if (current_length > options.wrap && data.lines[bb] === 1) {
                        record.begin = data.begin[bb];
                        record.ender = bb + 2;
                        record.lexer = data.lexer[bb];
                        record.lines = 1;
                        record.stack = data.stack[bb];
                        record.token = "{";
                        record.types = "script_start";
                        parse.splice({
                            data: data,
                            howmany: 0,
                            index: bb,
                            record: record
                        });
                        record.begin = bb;
                        record.lexer = "script";
                        record.lines = 0;
                        record.stack = "script";
                        if (options.quote_convert === "single") {
                            record.token = "' '";
                        }
                        else {
                            record.token = "\" \"";
                        }
                        record.types = "string";
                        parse.splice({
                            data: data,
                            howmany: 0,
                            index: bb + 1,
                            record: record
                        });
                        record.lexer = "markup";
                        record.token = "}";
                        record.types = "script_end";
                        parse.splice({
                            data: data,
                            howmany: 0,
                            index: bb + 2,
                            record: record
                        });
                        data.ender[bb + 3] = data.ender[bb + 3] + 3;
                        bb = bb + 4;
                        do {
                            data.begin[bb] = data.begin[bb] + 3;
                            data.ender[bb] = data.ender[bb] + 3;
                            bb = bb + 1;
                        } while (bb < parse.count);
                    }
                }
            }
            //sorts child elements
            if (options.lexer_options.markup.tag_sort === true && data.types[parse.count] === "end" && data.types[parse.count - 1] !== "start" && tname !== "/script" && tname !== "/style" && tname !== "/cfscript") {
                let bb = 0, d = 0, startStore = 0, jsxatt = false, endData;
                const children = [], store = {
                    begin: [],
                    ender: [],
                    lexer: [],
                    lines: [],
                    stack: [],
                    token: [],
                    types: []
                }, storeRecord = function lexer_markup_tag_sorttag_storeRecord(index) {
                    const output = {
                        begin: data.begin[index],
                        ender: data.ender[index],
                        lexer: data.lexer[index],
                        lines: data.lines[index],
                        stack: data.stack[index],
                        token: data.token[index],
                        types: data.types[index]
                    };
                    return output;
                }, childsort = function lexer_markup_tag_sorttag_childsort(a, b) {
                    if (data.token[a[0]] > data.token[b[0]]) {
                        return -1;
                    }
                    return 1;
                };
                bb = parse.count - 1;
                if (bb > -1) {
                    let endStore = 0;
                    do {
                        if (data.types[bb] === "start") {
                            d = d - 1;
                            if (d < 0) {
                                startStore = bb + 1;
                                if (data.types[startStore] === "attribute" || data.types[startStore] === "jsx_attribute_start") {
                                    jsxatt = false;
                                    do {
                                        startStore = startStore + 1;
                                        if (jsxatt === false && data.types[startStore] !== "attribute") {
                                            break;
                                        }
                                        if (data.types[startStore] === "jsx_attribute_start") {
                                            jsxatt = true;
                                        }
                                        else if (data.types[startStore] === "jsx_attribute_end") {
                                            jsxatt = false;
                                        }
                                    } while (startStore < c);
                                }
                                break;
                            }
                        }
                        else if (data.types[bb] === "end") {
                            d = d + 1;
                            if (d === 1) {
                                endStore = bb;
                            }
                        }
                        if (d === 0) {
                            if (data.types[bb] === "start") {
                                children.push([bb, endStore]);
                            }
                            else {
                                if (data.types[bb] === "singleton" && (data.types[bb + 1] === "attribute" || data.types[bb + 1] === "jsx_attribute_start")) {
                                    let cc = bb + 1;
                                    jsxatt = false;
                                    do {
                                        if (data.types[cc] === "jsx_attribute_start") {
                                            jsxatt = true;
                                        }
                                        else if (data.types[cc] === "jsx_attribute_end") {
                                            jsxatt = false;
                                        }
                                        if (jsxatt === false && data.types[cc + 1] !== "attribute" && data.types[cc + 1] !== "jsx_attribute_start") {
                                            break;
                                        }
                                        cc = cc + 1;
                                    } while (cc < parse.count);
                                    children.push([bb, cc]);
                                }
                                else if (data.types[bb] !== "attribute" && data.types[bb] !== "jsx_attribute_start") {
                                    children.push([bb, bb]);
                                }
                            }
                        }
                        bb = bb - 1;
                    } while (bb > -1);
                }
                if (children.length < 2) {
                    return;
                }
                children.sort(childsort);
                bb = children.length - 1;
                if (bb > -1) {
                    do {
                        recordPush(store, storeRecord(children[bb][0]), "");
                        if (children[bb][0] !== children[bb][1]) {
                            d = children[bb][0] + 1;
                            if (d < children[bb][1]) {
                                do {
                                    recordPush(store, storeRecord(d), "");
                                    d = d + 1;
                                } while (d < children[bb][1]);
                            }
                            recordPush(store, storeRecord(children[bb][1]), "");
                        }
                        bb = bb - 1;
                    } while (bb > -1);
                }
                endData = {
                    begin: data.begin.pop(),
                    ender: data.ender.pop(),
                    lexer: data.lexer.pop(),
                    lines: data.lines.pop(),
                    stack: data.stack.pop(),
                    token: data.token.pop(),
                    types: data.types.pop()
                };
                (function lexer_markup_tag_sorttag_slice() {
                    parse.datanames.forEach(function lexer_markup_tag_sorttag_slice_datanames(value) {
                        data[value] = data[value].slice(0, startStore);
                    });
                }());
                parse.concat(data, store);
                count.end = count.end - 1;
                recordPush(data, endData, "");
            }
            parse.linesSpace = 0;
        }, 
        // parses everything other than markup tags
        content = function lexer_markup_content() {
            let lex = [], ltoke = "", jsxbrace = (data.token[parse.count] === "{"), liner = parse.linesSpace, now = a;
            const name = (ext === true)
                ? (jsxbrace === true)
                    ? "script"
                    : (parse.structure[parse.structure.length - 1][1] > -1)
                        ? tagName(data.token[parse.structure[parse.structure.length - 1][1]].toLowerCase())
                        : tagName(data.token[data.begin[parse.count]].toLowerCase())
                : "", square = (data.types[parse.count] === "template_start" && data.token[parse.count].indexOf("<!") === 0 && data.token[parse.count].indexOf("<![") < 0 && data.token[parse.count].charAt(data.token[parse.count].length - 1) === "["), record = {
                begin: parse.structure[parse.structure.length - 1][1],
                ender: -1,
                lexer: "markup",
                lines: liner,
                stack: parse.structure[parse.structure.length - 1][0],
                token: "",
                types: "content"
            }, esctest = function lexer_markup_content_esctest() {
                let aa = a - 1, bb = 0;
                if (b[a - 1] !== "\\") {
                    return false;
                }
                if (aa > -1) {
                    do {
                        if (b[aa] !== "\\") {
                            break;
                        }
                        bb = bb + 1;
                        aa = aa - 1;
                    } while (aa > -1);
                }
                if (bb % 2 === 1) {
                    return true;
                }
                return false;
            };
            if (a < c) {
                let end = "", quote = "", quotes = 0;
                do {
                    if (b[a] === "\n") {
                        parse.lineNumber = parse.lineNumber + 1;
                    }
                    // external code requires additional parsing to look for the appropriate end
                    // tag, but that end tag cannot be quoted or commented
                    if (ext === true) {
                        if (quote === "") {
                            if (b[a] === "/") {
                                if (b[a + 1] === "*") {
                                    quote = "*";
                                }
                                else if (b[a + 1] === "/") {
                                    quote = "/";
                                }
                                else if (name === "script" && "([{!=,;.?:&<>".indexOf(b[a - 1]) > -1) {
                                    if (options.language !== "jsx" || b[a - 1] !== "<") {
                                        quote = "reg";
                                    }
                                }
                            }
                            else if ((b[a] === "\"" || b[a] === "'" || b[a] === "`") && esctest() === false) {
                                quote = b[a];
                            }
                            else if (b[a] === "{" && jsxbrace === true) {
                                quotes = quotes + 1;
                            }
                            else if (b[a] === "}" && jsxbrace === true) {
                                if (quotes === 0) {
                                    sparser.lexers.script(lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, ""));
                                    parse.structure[parse.structure.length - 1][1] + 1;
                                    if (data.types[parse.count] === "end" && data.lexer[data.begin[parse.count] - 1] === "script") {
                                        record.lexer = "script";
                                        record.token = (options.correct === true) ? ";" : "x;";
                                        record.types = "separator";
                                        recordPush(data, record, "");
                                        record.lexer = "markup";
                                    }
                                    record.token = "}";
                                    record.types = "script_end";
                                    recordPush(data, record, "");
                                    parse.structure.pop();
                                    break;
                                }
                                quotes = quotes - 1;
                            }
                            end = b
                                .slice(a, a + 10)
                                .join("")
                                .toLowerCase();
                            //cfscript requires use of the script lexer
                            if (name === "cfscript" && end === "</cfscript") {
                                a = a - 1;
                                if (lex.length < 1) {
                                    break;
                                }
                                sparser.lexers.script(lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, ""));
                                break;
                            }
                            //script requires use of the script lexer
                            if (name === "script") {
                                if (a === c - 9) {
                                    end = end.slice(0, end.length - 1);
                                }
                                else {
                                    end = end.slice(0, end.length - 2);
                                }
                                if (end === "</script") {
                                    let outside = lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, "");
                                    a = a - 1;
                                    if (lex.length < 1) {
                                        break;
                                    }
                                    if ((/^(<!--+)/).test(outside) === true && (/(--+>)$/).test(outside) === true) {
                                        record.token = "<!--";
                                        record.types = "comment";
                                        recordPush(data, record, "");
                                        outside = outside.replace(/^(<!--+)/, "").replace(/(--+>)$/, "");
                                        sparser.lexers.script(outside);
                                        record.token = "-->";
                                        recordPush(data, record, "");
                                    }
                                    else {
                                        sparser.lexers.script(outside);
                                    }
                                    break;
                                }
                            }
                            //style requires use of the style lexer
                            if (name === "style") {
                                if (a === c - 8) {
                                    end = end.slice(0, end.length - 1);
                                }
                                else if (a === c - 9) {
                                    end = end.slice(0, end.length - 2);
                                }
                                else {
                                    end = end.slice(0, end.length - 3);
                                }
                                if (end === "</style") {
                                    let outside = lex.join("").replace(/^(\s+)/, "").replace(/(\s+)$/, "");
                                    a = a - 1;
                                    if (lex.length < 1) {
                                        break;
                                    }
                                    if ((/^(<!--+)/).test(outside) === true && (/(--+>)$/).test(outside) === true) {
                                        record.token = "<!--";
                                        record.types = "comment";
                                        recordPush(data, record, "");
                                        outside = outside.replace(/^(<!--+)/, "").replace(/(--+>)$/, "");
                                        sparser.lexers.style(outside);
                                        record.token = "-->";
                                        recordPush(data, record, "");
                                    }
                                    else {
                                        sparser.lexers.style(outside);
                                    }
                                    break;
                                }
                            }
                        }
                        else if (quote === b[a] && (quote === "\"" || quote === "'" || quote === "`" || (quote === "*" && b[a + 1] === "/")) && esctest() === false) {
                            quote = "";
                        }
                        else if (quote === "`" && b[a] === "$" && b[a + 1] === "{" && esctest() === false) {
                            quote = "}";
                        }
                        else if (quote === "}" && b[a] === "}" && esctest() === false) {
                            quote = "`";
                        }
                        else if (quote === "/" && (b[a] === "\n" || b[a] === "\r")) {
                            quote = "";
                        }
                        else if (quote === "reg" && b[a] === "/" && esctest() === false) {
                            quote = "";
                        }
                        else if (quote === "/" && b[a] === ">" && b[a - 1] === "-" && b[a - 2] === "-") {
                            end = b
                                .slice(a + 1, a + 11)
                                .join("")
                                .toLowerCase();
                            if (name === "cfscript" && end === "</cfscript") {
                                quote = "";
                            }
                            end = end.slice(0, end.length - 2);
                            if (name === "script" && end === "</script") {
                                quote = "";
                            }
                            end = end.slice(0, end.length - 1);
                            if (name === "style" && end === "</style") {
                                quote = "";
                            }
                        }
                    }
                    //typically this logic is for artifacts nested within an SGML tag
                    if (square === true && b[a] === "]") {
                        a = a - 1;
                        ltoke = lex.join("");
                        if (options.lexer_options.markup.parse_space === false) {
                            ltoke = ltoke.replace(/\s+$/, "");
                        }
                        liner = 0;
                        record.token = ltoke;
                        recordPush(data, record, "");
                        break;
                    }
                    //general content processing
                    if (ext === false && lex.length > 0 && ((b[a] === "<" && b[a + 1] !== "=" && (/\s|\d/).test(b[a + 1]) === false) || (b[a] === "[" && b[a + 1] === "%") || (b[a] === "{" && (options.language === "jsx" || options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")))) {
                        //dustjs template handling
                        if (options.language === "dustjs" && b[a] === "{" && b[a + 1] === ":" && b[a + 2] === "e" && b[a + 3] === "l" && b[a + 4] === "s" && b[a + 5] === "e" && b[a + 6] === "}") {
                            a = a + 6;
                            ltoke = lex.join("");
                            if (options.lexer_options.markup.parse_space === false) {
                                ltoke = ltoke.replace(/\s+$/, "");
                            }
                            liner = 0;
                            record.token = ltoke;
                            recordPush(data, record, "");
                            record.token = "{:else}";
                            record.types = "template_else";
                            recordPush(data, record, "");
                            break;
                        }
                        //regular content
                        a = a - 1;
                        if (options.lexer_options.markup.parse_space === true || parse.structure[parse.structure.length - 1][0] === "comment") {
                            ltoke = lex.join("");
                        }
                        else {
                            ltoke = lex.join("").replace(/\s+$/, "");
                        }
                        ltoke = bracketSpace(ltoke);
                        liner = 0;
                        record.token = ltoke;
                        if (options.wrap > 0 && options.lexer_options.markup.preserve_text !== true) {
                            let aa = options.wrap, len = ltoke.length, startSpace = "", endSpace = "";
                            const wrap = options.wrap, store = [], wrapper = function beautify_markup_apply_content_wrapper() {
                                if (ltoke.charAt(aa) === " ") {
                                    store.push(ltoke.slice(0, aa));
                                    ltoke = ltoke.slice(aa + 1);
                                    len = ltoke.length;
                                    aa = wrap;
                                    return;
                                }
                                do {
                                    aa = aa - 1;
                                } while (aa > 0 && ltoke.charAt(aa) !== " ");
                                if (aa > 0) {
                                    store.push(ltoke.slice(0, aa));
                                    ltoke = ltoke.slice(aa + 1);
                                    len = ltoke.length;
                                    aa = wrap;
                                }
                                else {
                                    aa = wrap;
                                    do {
                                        aa = aa + 1;
                                    } while (aa < len && ltoke.charAt(aa) !== " ");
                                    store.push(ltoke.slice(0, aa));
                                    ltoke = ltoke.slice(aa + 1);
                                    len = ltoke.length;
                                    aa = wrap;
                                }
                            };
                            // HTML anchor lists do not get wrapping unless the content itself exceeds the wrapping limit
                            if (data.token[data.begin[parse.count]] === "<a>" &&
                                data.token[data.begin[data.begin[parse.count]]] === "<li>" &&
                                data.lines[data.begin[parse.count]] === 0 &&
                                parse.linesSpace === 0 &&
                                ltoke.length < options.wrap) {
                                recordPush(data, record, "");
                                break;
                            }
                            if (len < wrap) {
                                recordPush(data, record, "");
                                break;
                            }
                            if (parse.linesSpace < 1) {
                                let bb = parse.count;
                                do {
                                    aa = aa - data.token[bb].length;
                                    if (data.types[bb].indexOf("attribute") > -1) {
                                        aa = aa - 1;
                                    }
                                    if (data.lines[bb] > 0 && data.types[bb].indexOf("attribute") < 0) {
                                        break;
                                    }
                                    bb = bb - 1;
                                } while (bb > 0 && aa > 0);
                                if (aa < 1) {
                                    aa = ltoke.indexOf(" ");
                                }
                            }
                            ltoke = lex.join("");
                            if (options.lexer_options.markup.parse_space === true) {
                                startSpace = ((/\s/).test(ltoke.charAt(0)) === true)
                                    ? (/\s+/).exec(ltoke)[0]
                                    : "";
                                endSpace = ((/\s/).test(ltoke.charAt(ltoke.length - 1)) === true)
                                    ? (/\s+$/).exec(ltoke)[0]
                                    : "";
                            }
                            ltoke = ltoke.replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ");
                            do {
                                wrapper();
                            } while (aa < len);
                            if (ltoke !== "" && ltoke !== " ") {
                                store.push(ltoke);
                            }
                            if (options.crlf === true) {
                                ltoke = store.join("\r\n");
                            }
                            else {
                                ltoke = store.join("\n");
                            }
                            ltoke = startSpace + ltoke + endSpace;
                        }
                        liner = 0;
                        record.token = ltoke;
                        recordPush(data, record, "");
                        break;
                    }
                    lex.push(b[a]);
                    a = a + 1;
                } while (a < c);
            }
            if (options.lexer_options.markup.parse_space === false) {
                if (a > now && a < c) {
                    if ((/\s/).test(b[a]) === true) {
                        let x = a;
                        parse.linesSpace = 1;
                        do {
                            if (b[x] === "\n") {
                                parse.linesSpace = parse.linesSpace + 1;
                            }
                            x = x - 1;
                        } while (x > now && (/\s/).test(b[x]) === true);
                    }
                    else {
                        parse.linesSpace = 0;
                    }
                }
                else if (a !== now || (a === now && ext === false)) {
                    //regular content at the end of the supplied source
                    ltoke = lex.join("").replace(/\s+$/, "");
                    liner = 0;
                    //this condition prevents adding content that was just added in the loop above
                    if (record.token !== ltoke) {
                        record.token = ltoke;
                        recordPush(data, record, "");
                        parse.linesSpace = 0;
                    }
                }
            }
            ext = false;
        };
        // trim the attribute_sort_list values
        if (asl > 0) {
            do {
                attribute_sort_list[a] = attribute_sort_list[a].replace(/^\s+/, "").replace(/\s+$/, "");
                a = a + 1;
            } while (a < asl);
            a = 0;
        }
        if (options.language === "html") {
            html = "html";
        }
        else if (options.language === "xml" || options.language === "sgml") {
            html = "xml";
        }
        do {
            if ((/\s/).test(b[a]) === true) {
                if (options.lexer_options.markup.parse_space === true || (data.types[parse.count] === "template_start" && parse.structure[parse.structure.length - 1][0] === "comment")) {
                    content();
                }
                else {
                    a = parse.spacer({ array: b, end: c, index: a });
                }
            }
            else if (ext) {
                content();
            }
            else if (b[a] === "<") {
                tag("");
            }
            else if (b[a] === "[" && b[a + 1] === "%") {
                tag("%]");
            }
            else if (b[a] === "{" && (options.language === "jsx" || options.language === "dustjs" || b[a + 1] === "{" || b[a + 1] === "%" || b[a + 1] === "@" || b[a + 1] === "#")) {
                tag("");
            }
            else if (b[a] === "]" && sgmlflag > 0) {
                tag("]>");
            }
            else if (options.language === "vapor") {
                if (b[a] === "#") {
                    tag(")");
                }
                else if (b[a] === "{" && data.token[parse.count].charAt(0) === "#") {
                    vaporStart();
                }
                else if (b[a] === "}") {
                    vaporEnd();
                }
                else {
                    content();
                }
            }
            else if (options.language === "jekyll" && b[a] === "-" && b[a + 1] === "-" && b[a + 2] === "-") {
                tag("---");
            }
            else if (options.language === "apacheVelocity" && (/\d/).test(b[a + 1]) === false && (/\s/).test(b[a + 1]) === false) {
                if (b[a] === "#" && ((/\w/).test(b[a + 1]) === true || b[a + 1] === "*" || b[a + 1] === "#" || (b[a + 1] === "[" && b[a + 2] === "["))) {
                    tag("");
                }
                else if (b[a] === "$" && b[a + 1] !== "$" && b[a + 1] !== "=" && b[a + 1] !== "[") {
                    tag("");
                }
                else {
                    content();
                }
            }
            else {
                content();
            }
            a = a + 1;
        } while (a < c);
        if (data.token[parse.count].charAt(0) !== "/" && htmlblocks[parse.structure[parse.structure.length - 1][0]] === "block") {
            fixHtmlEnd(data.token[parse.count], true);
        }
        if (count.end !== count.start && sparser.parseerror === "") {
            if (count.end > count.start) {
                let x = count.end - count.start, plural = (x === 1)
                    ? ""
                    : "s";
                sparser.parseerror = `${x} more end type${plural} than start types.`;
            }
            else {
                let x = count.start - count.end, plural = (x === 1)
                    ? ""
                    : "s";
                sparser.parseerror = `${x} more start type${plural} than end types.`;
            }
        }
        return data;
    };
    sparser.lexers.markup = markup;
}());

(function minify_style_init() {
    const style = function minify_style(options) {
        const data = options.parsed, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", len = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, build = [];
        let a = prettydiff.start, b = 0, c = 0, list = [], count = 0, countx = 0;
        //beautification loop
        if (options.top_comments === true && options.minify_keep_comments === false && data.types[a] === "comment" && prettydiff.start === 0) {
            if (a > 0) {
                build.push(lf);
            }
            do {
                build.push(data.token[a]);
                build.push(lf);
                a = a + 1;
            } while (a < len && data.types[a] === "comment");
        }
        if (a < len) {
            do {
                if (data.types[a] === "comment" && options.minify_keep_comments === true) {
                    if (data.types[a - 1] !== "comment" && a > 0) {
                        build.push(lf);
                        build.push(lf);
                    }
                    build.push(data.token[a]);
                    if (data.types[a + 1] !== "comment") {
                        build.push(lf);
                    }
                    build.push(lf);
                }
                else if (data.types[a] !== "comment") {
                    build.push(data.token[a]);
                    if (options.wrap > 0 && options.minify_wrap === true) {
                        count = count + data.token[a].length;
                        if (a < len - 1) {
                            if (count + data.token[a + 1].length > options.wrap) {
                                countx = count;
                                count = 0;
                                if (data.types[a] === "property") {
                                    build.pop();
                                    a = a - 1;
                                }
                                else if (data.token[a] === ":") {
                                    build.pop();
                                    build.pop();
                                    a = a - 2;
                                }
                                build.push(lf);
                            }
                            b = data.token[a + 1].indexOf(",");
                            if ((data.token[a + 1].length > options.wrap || (b > 0 && countx + b < options.wrap)) && data.types[a + 1] === "selector") {
                                list = data.token[a + 1].split(",");
                                b = 0;
                                c = list.length;
                                if (countx + list[0].length + 1 < options.wrap) {
                                    build.pop();
                                    do {
                                        countx = countx + list[b].length + 1;
                                        if (countx > options.wrap) {
                                            break;
                                        }
                                        build.push(list[b]);
                                        build.push(",");
                                        b = b + 1;
                                    } while (b < c);
                                }
                                else {
                                    countx = 0;
                                }
                                if (b < c) {
                                    do {
                                        countx = countx + list[b].length + 1;
                                        if (countx > options.wrap) {
                                            countx = list[b].length + 1;
                                            build.push(lf);
                                        }
                                        build.push(list[b]);
                                        build.push(",");
                                        b = b + 1;
                                    } while (b < c);
                                    build.pop();
                                }
                                count = countx;
                                countx = 0;
                                a = a + 1;
                            }
                        }
                    }
                }
                a = a + 1;
            } while (a < len);
            prettydiff.iterator = len - 1;
        }
        if (options.new_line === true && a === data.token.length && build[build.length - 1].indexOf(lf) < 0) {
            build.push(lf);
        }
        return build.join("");
    };
    prettydiff.minify.style = style;
}());

(function minify_script_init() {
    const script = function minify_script(options) {
        (function minify_script_options() {
            if (options.language === "json") {
                options.wrap = 0;
            }
            else if (options.language === "titanium") {
                options.correct = false;
            }
        }());
        const data = options.parsed, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", lexer = "script", invisibles = ["x;", "x}", "x{", "x(", "x)"], end = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, build = [], lastsemi = function minify_script_lastsemi() {
            let aa = a, bb = 0;
            do {
                if (data.types[aa] === "end") {
                    bb = bb + 1;
                }
                else if (data.types[aa] === "start") {
                    bb = bb - 1;
                }
                if (bb < 0) {
                    if (data.token[aa - 1] === "for") {
                        build.push(";");
                        count = count + 1;
                    }
                    return;
                }
                aa = aa - 1;
            } while (aa > -1);
        };
        let a = prettydiff.start, count = 0, external = "";
        if (options.top_comments === true && options.minify_keep_comments === false && data.types[a] === "comment" && prettydiff.start === 0) {
            if (a > 0) {
                build.push(lf);
            }
            do {
                build.push(data.token[a]);
                build.push(lf);
                a = a + 1;
            } while (a < end && data.types[a] === "comment");
        }
        do {
            if (data.lexer[a] === lexer || prettydiff.minify[data.lexer[a]] === undefined) {
                if (data.types[a] === "comment" && options.minify_keep_comments === true) {
                    if (data.types[a - 1] !== "comment" && a > 0) {
                        build.push(lf);
                        build.push(lf);
                    }
                    build.push(data.token[a]);
                    if (data.types[a + 1] !== "comment") {
                        build.push(lf);
                    }
                    build.push(lf);
                }
                else if (data.types[a] !== "comment") {
                    if (data.types[a - 1] === "operator" && data.types[a] === "operator" && data.token[a] !== "!") {
                        build.push(" ");
                        count = count + 1;
                    }
                    if ((data.types[a] === "word" || data.types[a] === "references") && (data.types[a + 1] === "word" ||
                        data.types[a + 1] === "reference" ||
                        data.types[a + 1] === "literal" ||
                        data.types[a + 1] === "number" ||
                        data.token[a + 1] === "x{")) {
                        if (data.types[a - 1] === "literal" &&
                            data.token[a - 1].charAt(0) !== "\"" &&
                            data.token[a - 1].charAt(0) !== "'") {
                            build.push(" ");
                            count = count + 1;
                        }
                        build.push(data.token[a]);
                        build.push(" ");
                        count = count + data.token[a].length + 1;
                    }
                    else if (data.token[a] === "x;" && data.token[a + 1] !== "}") {
                        build.push(";");
                        count = count + 1;
                    }
                    else if (data.token[a] === ";" && data.token[a + 1] === "}") {
                        lastsemi();
                    }
                    else if (invisibles.indexOf(data.token[a]) < 0) {
                        build.push(data.token[a]);
                        count = count + data.token[a].length;
                    }
                }
                if (a < end - 1 && count + data.token[a + 1].length > options.wrap && options.wrap > 0 && options.minify_wrap === true) {
                    if (build[build.length - 1] === " ") {
                        build.pop();
                    }
                    if (data.token[a + 1] === ";") {
                        build.pop();
                        build.push(lf);
                        build.push(data.token[a]);
                    }
                    else {
                        build.push(lf);
                    }
                    count = 0;
                }
            }
            else {
                let skip = a, quit = false;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip) {
                        break;
                    }
                    if (data.token[skip - 1] === "return" && data.types[a] === "end" && data.begin[a] === skip) {
                        break;
                    }
                    a = a + 1;
                } while (a < end);
                prettydiff.start = skip;
                prettydiff.end = a;
                if (a > end - 1) {
                    a = skip;
                    quit = true;
                    prettydiff.end = end - 2;
                }
                external = prettydiff.minify[data.lexer[a]](options).replace(/\s+$/, "");
                if (options.wrap > 0 && options.minify_wrap === true && data.token[skip - 1] !== "return") {
                    build.push(lf);
                }
                build.push(external);
                if (quit === true) {
                    break;
                }
                if (options.wrap > 0 && options.minify_wrap === true) {
                    build.push(lf);
                    count = 0;
                }
            }
            a = a + 1;
        } while (a < end);
        prettydiff.iterator = end - 1;
        if (options.new_line === true && a === data.token.length && build[build.length - 1].indexOf(lf) < 0) {
            build.push(lf);
        }
        return build.join("");
    };
    prettydiff.minify.script = script;
}());

(function beautify_style_init() {
    const style = function beautify_style(options) {
        const data = options.parsed, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", len = (prettydiff.end > 0)
            ? prettydiff.end + 1
            : data.token.length, build = [], 
        //a single unit of indentation
        tab = (function beautify_style_tab() {
            let aa = 0, bb = [];
            do {
                bb.push(options.indent_char);
                aa = aa + 1;
            } while (aa < options.indent_size);
            return bb.join("");
        }()), pres = options.preserve + 1, 
        //new lines plus indentation
        nl = function beautify_style_nl(tabs) {
            const linesout = [], total = (function beautify_style_nl_total() {
                if (a === len - 1) {
                    return 1;
                }
                if (data.lines[a + 1] - 1 > pres) {
                    return pres;
                }
                if (data.lines[a + 1] > 1) {
                    return data.lines[a + 1] - 1;
                }
                return 1;
            }());
            let index = 0;
            if (tabs < 0) {
                tabs = 0;
            }
            do {
                linesout.push(lf);
                index = index + 1;
            } while (index < total);
            if (tabs > 0) {
                index = 0;
                do {
                    linesout.push(tab);
                    index = index + 1;
                } while (index < tabs);
            }
            build.push(linesout.join(""));
        }, vertical = function beautify_style_vertical() {
            const start = data.begin[a], startChar = data.token[start], endChar = data.token[a], store = [];
            let b = a, c = 0, item, longest = 0;
            if (start < 0 || b <= start) {
                return;
            }
            do {
                b = b - 1;
                if (data.begin[b] === start) {
                    if (data.token[b] === ":") {
                        item = [b - 1, 0];
                        do {
                            b = b - 1;
                            if ((((data.token[b] === ";" && startChar === "{") || (data.token[b] === "," && startChar === "(")) && data.begin[b] === start) || (data.token[b] === endChar && data.begin[data.begin[b]] === start)) {
                                break;
                            }
                            if (data.types[b] !== "comment" && data.types[b] !== "selector" && data.token[b] !== startChar && data.begin[b] === start) {
                                item[1] = data.token[b].length + item[1];
                            }
                        } while (b > start + 1);
                        if (item[1] > longest) {
                            longest = item[1];
                        }
                        store.push(item);
                    }
                }
                else if (data.types[b] === "end") {
                    if (b < data.begin[b]) {
                        break;
                    }
                    b = data.begin[b];
                }
            } while (b > start);
            b = store.length;
            if (b < 2) {
                return;
            }
            do {
                b = b - 1;
                if (store[b][1] < longest) {
                    c = store[b][1];
                    do {
                        data.token[store[b][0]] = data.token[store[b][0]] + " ";
                        c = c + 1;
                    } while (c < longest);
                }
            } while (b > 0);
        };
        let indent = options.indent_level, a = prettydiff.start, when = ["", ""];
        if (options.vertical === true && options.compressed_css === false) {
            a = len;
            do {
                a = a - 1;
                if (data.token[a] === "}" || data.token[a] === ")") {
                    vertical();
                }
            } while (a > 0);
            a = prettydiff.start;
        }
        //beautification loop
        do {
            if (data.types[a + 1] === "end" || data.types[a + 1] === "template_end" || data.types[a + 1] === "template_else") {
                indent = indent - 1;
            }
            if (data.types[a] === "template" && data.lines[a] > 0) {
                build.push(data.token[a]);
                nl(indent);
            }
            else if (data.types[a] === "template_else") {
                build.push(data.token[a]);
                indent = indent + 1;
                nl(indent);
            }
            else if (data.types[a] === "start" || data.types[a] === "template_start") {
                indent = indent + 1;
                build.push(data.token[a]);
                if (data.types[a + 1] !== "end" && data.types[a + 1] !== "template_end" && (options.compressed_css === false || (options.compressed_css === true && data.types[a + 1] === "selector"))) {
                    nl(indent);
                }
            }
            else if ((data.token[a] === ";" && (options.compressed_css === false || (options.compressed_css === true && data.types[a + 1] === "selector"))) || data.types[a] === "end" || data.types[a] === "template_end" || data.types[a] === "comment") {
                build.push(data.token[a]);
                if (data.types[a + 1] === "value") {
                    if (data.lines[a + 1] === 1) {
                        build.push(" ");
                    }
                    else if (data.lines[a + 1] > 1) {
                        nl(indent);
                    }
                }
                else if (data.types[a + 1] !== "separator") {
                    if (data.types[a + 1] !== "comment" || (data.types[a + 1] === "comment" && data.lines[a + 1] > 1)) {
                        nl(indent);
                    }
                    else {
                        build.push(" ");
                    }
                }
            }
            else if (data.token[a] === ":") {
                build.push(data.token[a]);
                if (options.compressed_css === false) {
                    build.push(" ");
                }
            }
            else if (data.types[a] === "selector") {
                if (options.css_insert_lines === true && data.types[a - 1] === "end" && data.lines[a] < 3) {
                    build.push(lf);
                }
                if (data.token[a].indexOf("when(") > 0) {
                    when = data.token[a].split("when(");
                    build.push(when[0].replace(/\s+$/, ""));
                    nl(indent + 1);
                    build.push(`when (${when[1]}`);
                }
                else {
                    build.push(data.token[a]);
                }
                if (data.types[a + 1] === "start") {
                    if (options.braces === true) {
                        nl(indent);
                    }
                    else if (options.compressed_css === false) {
                        build.push(" ");
                    }
                }
            }
            else if (data.token[a] === ",") {
                build.push(data.token[a]);
                if (data.types[a + 1] === "selector" || data.types[a + 1] === "property") {
                    nl(indent);
                }
                else if (options.compressed_css === false) {
                    build.push(" ");
                }
            }
            else if (data.stack[a] === "map" && data.token[a + 1] === ")" && a - data.begin[a] > 5) {
                build.push(data.token[a]);
                nl(indent);
            }
            else if (data.token[a] === "x;") {
                nl(indent);
            }
            else if ((data.types[a] === "variable" || data.types[a] === "function") && options.css_insert_lines === true && data.types[a - 1] === "end" && data.lines[a] < 3) {
                build.push(lf);
                build.push(data.token[a]);
            }
            else if (data.token[a] !== ";" || (data.token[a] === ";" && (options.compressed_css === false || (options.compressed_css === true && data.token[a + 1] !== "}")))) {
                build.push(data.token[a]);
            }
            a = a + 1;
        } while (a < len);
        prettydiff.iterator = len - 1;
        return build.join("");
    };
    prettydiff.beautify.style = style;
}());

(function minify_markup_init() {
    const markup = function minify_markup(options) {
        const data = options.parsed, lexer = "markup", c = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", externalIndex = {}, levels = (function minify_markup_levels() {
            const level = (prettydiff.start > 0)
                ? Array(prettydiff.start).fill(0, 0, prettydiff.start)
                : [], nextIndex = function minify_markup_levels_next() {
                let x = a + 1, y = 0;
                if (data.types[x] === "comment" || data.types[x] === "attribute" || data.types[x] === "jsx_attribute_start") {
                    do {
                        if (data.types[x] === "jsx_attribute_start") {
                            y = x;
                            do {
                                if (data.types[x] === "jsx_attribute_end" && data.begin[x] === y) {
                                    break;
                                }
                                x = x + 1;
                            } while (x < c);
                        }
                        else if (data.types[x] !== "comment" && data.types[x] !== "attribute") {
                            return x;
                        }
                        x = x + 1;
                    } while (x < c);
                }
                return x;
            }, external = function minify_markup_levels_external() {
                let skip = a;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip && data.types[a + 1] !== "start" && data.types[a + 1] !== "singleton") {
                        break;
                    }
                    level.push(-20);
                    a = a + 1;
                } while (a < c);
                externalIndex[skip] = a;
                level.push(-20);
                next = nextIndex();
            }, comment = function minify_markup_levels_comment() {
                let x = a, test = false;
                if (data.lines[a + 1] === 0) {
                    do {
                        if (data.lines[x] > 0) {
                            test = true;
                            break;
                        }
                        x = x - 1;
                    } while (x > comstart);
                    x = a;
                }
                else {
                    test = true;
                }
                do {
                    level.push(-20);
                    x = x - 1;
                } while (x > comstart);
                if (test === true) {
                    if (data.types[x] === "attribute" || data.types[x] === "jsx_attribute_start") {
                        level[data.begin[x]] = -10;
                    }
                    else {
                        level[x] = -10;
                    }
                }
                else {
                    level[x] = -20;
                }
                comstart = -1;
            };
            let a = prettydiff.start, next = 0, comstart = -1;
            // data.lines -> space before token
            // level -> space after token
            do {
                if (data.lexer[a] === lexer) {
                    if (data.types[a].indexOf("attribute") > -1) {
                        if (data.types[a] === "attribute") {
                            data.token[a] = data.token[a].replace(/\s+/g, " ");
                        }
                        if (data.types[a - 1].indexOf("attribute") < 0) {
                            level[a - 1] = -10;
                        }
                        if (data.types[a] === "comment_attribute" && data.token[a].slice(0, 2) === "//") {
                            level.push(-10);
                        }
                        else if (data.types[a] === "jsx_attribute_start") {
                            level.push(-20);
                        }
                        else if (data.types[a] === "jsx_attribute_end") {
                            level.push(-10);
                        }
                        else if (a < c - 1 && data.types[a + 1].indexOf("attribute") < 0) {
                            if (data.lines[a + 1] > 0 && data.lexer[a + 1] === lexer && data.types[a + 1] !== "start" && data.types[a + 1] !== "xml" && data.types[a + 1] !== "sgml") {
                                level.push(-10);
                            }
                            else {
                                level.push(-20);
                            }
                        }
                        else {
                            level.push(-10);
                        }
                    }
                    else if (data.types[a] === "comment") {
                        if (options.minify_keep_comments === true) {
                            level.push(0);
                        }
                        else {
                            if (comstart < 0) {
                                comstart = a;
                            }
                            if (data.types[a + 1] !== "comment") {
                                comment();
                            }
                        }
                    }
                    else if (data.types[a] !== "comment") {
                        if (data.types[a] === "content") {
                            data.token[a] = data.token[a].replace(/\s+/g, " ");
                        }
                        next = nextIndex();
                        if (data.lines[next] > 0 && (data.types[a] === "content" ||
                            data.types[a] === "singleton" ||
                            data.types[next] === "content" ||
                            data.types[next] === "singleton" ||
                            (data.types[next] !== undefined && data.types[next].indexOf("attribute") > 0))) {
                            level.push(-10);
                        }
                        else {
                            level.push(-20);
                        }
                    }
                }
                else {
                    external();
                }
                a = a + 1;
            } while (a < c);
            return level;
        }());
        return (function minify_markup_apply() {
            const build = [], 
            // a new line character plus the correct amount of identation for the given line
            // of code
            attributeEnd = function minify_markup_apply_attributeEnd() {
                const parent = data.token[a], regend = (/(\/|\?)?>$/), end = regend.exec(parent);
                let y = a + 1, x = 0, jsx = false;
                if (end === null) {
                    return;
                }
                data.token[a] = parent.replace(regend, "");
                do {
                    if (data.types[y] === "jsx_attribute_end" && data.begin[data.begin[y]] === a) {
                        jsx = false;
                    }
                    else if (data.begin[y] === a) {
                        if (data.types[y] === "jsx_attribute_start") {
                            jsx = true;
                        }
                        else if (data.types[y].indexOf("attribute") < 0 && jsx === false) {
                            break;
                        }
                    }
                    else if (jsx === false && (data.begin[y] < a || data.types[y].indexOf("attribute") < 0)) {
                        break;
                    }
                    y = y + 1;
                } while (y < c);
                if (data.types[y - 1] === "comment_attribute") {
                    x = y;
                    do {
                        y = y - 1;
                    } while (y > a && data.types[y - 1] === "comment_attribute");
                    if (data.lines[x] < 1) {
                        levels[y - 1] = -20;
                    }
                }
                data.token[y - 1] = data.token[y - 1] + end[0];
            };
            let a = prettydiff.start, b = 0, next = 0, external = "", lastLevel = 0, count = 0, linelen = 0, lines = [];
            if (options.top_comments === true && data.types[a] === "comment" && prettydiff.start === 0) {
                if (a > 0) {
                    build.push(lf);
                }
                do {
                    build.push(data.token[a]);
                    build.push(lf);
                    a = a + 1;
                } while (a < c && data.types[a] === "comment");
            }
            do {
                if (data.lexer[a] === lexer || prettydiff.minify[data.lexer[a]] === undefined) {
                    if ((data.types[a] === "start" || data.types[a] === "singleton" || data.types[a] === "xml" || data.types[a] === "sgml") && data.types[a].indexOf("attribute") < 0 && a < c - 1 && data.types[a + 1] !== undefined && data.types[a + 1].indexOf("attribute") > -1) {
                        attributeEnd();
                    }
                    if (options.minify_keep_comments === true || (data.types[a] !== "comment" && data.types[a] !== "comment_attribute")) {
                        if (data.types[a] === "comment") {
                            if (data.types[a - 1] !== "comment") {
                                build.push(lf);
                                build.push(lf);
                            }
                            build.push(data.token[a]);
                            if (data.types[a + 1] !== "comment") {
                                build.push(lf);
                            }
                            build.push(lf);
                        }
                        else {
                            build.push(data.token[a]);
                        }
                        count = count + data.token[a].length;
                        if ((data.types[a] === "template" || data.types[a] === "template_start") && data.types[a - 1] === "content" && options.mode === "minify" && levels[a] === -20) {
                            build.push(" ");
                            count = count + 1;
                        }
                        if (levels[a] > -1) {
                            lastLevel = levels[a];
                        }
                        else if (levels[a] === -10 && data.types[a] !== "jsx_attribute_start") {
                            build.push(" ");
                            count = count + 1;
                        }
                    }
                    next = a + 1;
                    if (next < c - 1 && data.types[next].indexOf("comment") > -1 && options.minify_keep_comments === false) {
                        do {
                            next = next + 1;
                        } while (next < c - 1 && data.types[next].indexOf("comment") > -1);
                    }
                    if (next < c - 1 && count + data.token[next].length > options.wrap && options.wrap > 0 && options.minify_wrap === true) {
                        if (build[build.length - 1] === " ") {
                            build.pop();
                        }
                        if ((data.types[next] === "content" || data.types[next] === "attribute") && data.token[next].indexOf(" ") > 0) {
                            lines = data.token[next].split(" ");
                            b = 0;
                            linelen = lines.length;
                            if (count + lines[0] + 1 > options.wrap) {
                                build.push(lf);
                                count = 0;
                            }
                            do {
                                count = count + lines[b].length + 1;
                                if (count > options.wrap) {
                                    count = lines[b].length + 1;
                                    build.push(lf);
                                }
                                build.push(lines[b]);
                                build.push(" ");
                                b = b + 1;
                            } while (b < linelen);
                            if (next < c - 2 && count + data.token[next + 1].length > options.wrap) {
                                if (build[build.length - 1] === " ") {
                                    build.pop();
                                }
                                build.push(lf);
                                count = 0;
                            }
                            a = next;
                        }
                        else {
                            build.push(lf);
                            count = 0;
                        }
                    }
                }
                else {
                    if (externalIndex[a] === a && data.types[a] !== "reference") {
                        if (data.types[a] !== "comment") {
                            build.push(data.token[a]);
                            count = count + data.token[a].length;
                        }
                    }
                    else {
                        prettydiff.end = externalIndex[a];
                        options.indent_level = lastLevel;
                        prettydiff.start = a;
                        external = prettydiff.minify[data.lexer[a]](options).replace(/\s+$/, "");
                        if (options.wrap > 0 && options.minify_wrap === true) {
                            build.push(lf);
                        }
                        build.push(external);
                        if (levels[prettydiff.iterator] > -1 && externalIndex[a] > a) {
                            build.push(lf);
                        }
                        else if (options.wrap > 0 && options.minify_wrap === true) {
                            build.push(lf);
                        }
                        a = prettydiff.iterator;
                    }
                }
                a = a + 1;
            } while (a < c);
            prettydiff.iterator = c - 1;
            if (build[0] === lf || build[0] === " ") {
                build[0] = "";
            }
            if (options.new_line === true && a === data.token.length && build[build.length - 1].indexOf(lf) < 0) {
                build.push(lf);
            }
            return build.join("");
        }());
    };
    prettydiff.minify.markup = markup;
}());
(function options_init() {
    const optionDef = {
        attribute_sort: {
            api: "any",
            default: false,
            definition: "Alphanumerically sort markup attributes. Attribute sorting is ignored on tags that contain attributes template attributes.",
            label: "Sort Attributes",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        attribute_sort_list: {
            api: "any",
            default: "",
            definition: "A comma separated list of attribute names. Attributes will be sorted according to this list and then alphanumerically. This option requires 'attribute_sort' have a value of true.",
            label: "Sort Attribute List",
            lexer: "markup",
            mode: "any",
            type: "string"
        },
        brace_line: {
            api: "any",
            default: false,
            definition: "If true an empty line will be inserted after opening curly braces and before clo" +
                "sing curly braces.",
            label: "Brace Lines",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        brace_padding: {
            api: "any",
            default: false,
            definition: "Inserts a space after the start of a container and before the end of the contain" +
                "er if the contents of that container are not indented; such as: conditions, func" +
                "tion arguments, and escaped sequences of template strings.",
            label: "Brace Padding",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        brace_style: {
            api: "any",
            default: "none",
            definition: "Emulates JSBeautify's brace_style option using existing Pretty Diff options.",
            label: "Brace Style",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "collapse": "Sets options.format_object to 'indent' and options.neverflatten to true.",
                "collapse-preserve-inline": "Sets options.bracepadding to true and options.format_object to 'inline'.",
                "expand": "Sets options.braces to true, options.format_object to 'indent', and options.never" +
                    "flatten to true.",
                "none": "Ignores this option"
            }
        },
        braces: {
            api: "any",
            default: false,
            definition: "Determines if opening curly braces will exist on the same line as their conditio" +
                "n or be forced onto a new line. (Allman style indentation).",
            label: "Style of Indent",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        case_space: {
            api: "any",
            default: false,
            definition: "If the colon separating a case's expression (of a switch/case block) from its statement should be followed by a space instead of indentation, thereby keeping the case on a single line of code.",
            label: "Space Following Case",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        color: {
            api: "any",
            default: "white",
            definition: "The color scheme of the reports.",
            label: "Color",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                "canvas": "A light brown color scheme",
                "shadow": "A black and ashen color scheme",
                "white": "A white and pale grey color scheme"
            }
        },
        comment_line: {
            api: "any",
            default: false,
            definition: "If a blank new line should be forced above comments.",
            label: "Force an Empty Line Above Comments",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        comments: {
            api: "any",
            default: false,
            definition: "This will determine whether comments should always start at position 0 of each l" +
                "ine or if comments should be indented according to the code.",
            label: "Indent Comments",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        complete_document: {
            api: "any",
            default: false,
            definition: "Allows a preference for generating a complete HTML document instead of only gene" +
                "rating content.",
            label: "Generate A Complete HTML File",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        compressed_css: {
            api: "any",
            default: false,
            definition: "If CSS should be beautified in a style where the properties and values are minif" +
                "ed for faster reading of selectors.",
            label: "Compressed CSS",
            lexer: "style",
            mode: "beautify",
            type: "boolean"
        },
        conditional: {
            api: "any",
            default: false,
            definition: "If true then conditional comments used by Internet Explorer are preserved at min" +
                "ification of markup.",
            label: "IE Comments (HTML Only)",
            lexer: "markup",
            mode: "minify",
            type: "boolean"
        },
        config: {
            api: "node",
            default: "",
            definition: "By default Pretty Diff will look into the directory structure contain the value of option 'source' for a file named `.prettydiffrc` for saved option settings. This option allows a user to specify any file at any location in the local file system for configuration settings. A value of 'none' tells the application to bypass reading any configuration file.",
            label: "Custom Config File Location",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        content: {
            api: "any",
            default: false,
            definition: "This will normalize all string content to 'text' so as to eliminate some differe" +
                "nces from the output.",
            label: "Ignore Content",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        correct: {
            api: "any",
            default: false,
            definition: "Automatically correct some sloppiness in code.",
            label: "Fix Sloppy Code",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        crlf: {
            api: "any",
            default: false,
            definition: "If line termination should be Windows (CRLF) format.  Unix (LF) format is the de" +
                "fault.",
            label: "Line Termination",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        css_insert_lines: {
            api: "any",
            default: false,
            definition: "Inserts new line characters between every CSS code block.",
            label: "Insert Empty Lines",
            lexer: "style",
            mode: "beautify",
            type: "boolean"
        },
        diff: {
            api: "any",
            default: "",
            definition: "The code sample to be compared to 'source' option.  This is required if mode is " +
                "'" + "diff'.",
            label: "Code to Compare",
            lexer: "any",
            mode: "diff",
            type: "string"
        },
        diff_comments: {
            api: "any",
            default: false,
            definition: "If true then comments will be preserved so that both code and comments are compa" +
                "red by the diff engine.",
            label: "Code Comments",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        diff_context: {
            api: "any",
            default: -1,
            definition: "This shortens the diff output by allowing a specified number of equivalent lines" +
                " between each line of difference.  This option is only used with diff_format:htm" +
                "l.",
            label: "Context Size",
            lexer: "any",
            mode: "diff",
            type: "number"
        },
        diff_format: {
            api: "any",
            default: "text",
            definition: "The format of the output.  The command line output format is text, similar to Un" +
                "ix 'diff'.",
            label: "Diff Format",
            lexer: "any",
            mode: "diff",
            type: "string",
            values: {
                "html": "An HTML format for embedding in web pages, or as a complete web page if document" +
                    "_complete is true.",
                "json": "A JSON format.",
                "text": "Formatted similar to the Unix 'diff' command line utility."
            }
        },
        diff_label: {
            api: "any",
            default: "New Sample",
            definition: "This allows for a descriptive label for the diff file code of the diff HTML outp" +
                "ut.",
            label: "Label for Diff Sample",
            lexer: "any",
            mode: "diff",
            type: "string"
        },
        diff_rendered_html: {
            api: "any",
            default: false,
            definition: "Compares complete HTML documents and injects custom CSS so that the differences display not in the code, but in the rendered page in a browser.  This option is currently confined only to markup languages, read_method file, and mode diff.  Option diff_format is ignored.",
            label: "Compare Rendered HTML",
            lexer: "markup",
            mode: "diff",
            type: "boolean"
        },
        diff_space_ignore: {
            api: "any",
            default: false,
            definition: "If white space only differences should be ignored by the diff tool.",
            label: "Remove White Space",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        diff_view: {
            api: "any",
            default: "sidebyside",
            definition: "This determines whether the diff HTML output should display as a side-by-side co" +
                "mparison or if the differences should display in a single table column.",
            label: "Diff View Type",
            lexer: "any",
            mode: "diff",
            type: "string",
            values: {
                "inline": "A single column where insertions and deletions are vertically adjacent.",
                "sidebyside": "Two column comparison of changes."
            }
        },
        else_line: {
            api: "any",
            default: false,
            definition: "If else_line is true then the keyword 'else' is forced onto a new line.",
            label: "Else On New Line",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        end_comma: {
            api: "any",
            default: "never",
            definition: "If there should be a trailing comma in arrays and objects. Value \"multiline\" o" +
                "nly applies to modes beautify and diff.",
            label: "Trailing Comma",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "always": "Always ensure there is a tailing comma",
                "never": "Remove trailing commas",
                "none": "Ignore this option"
            }
        },
        end_quietly: {
            api: "node",
            default: "default",
            definition: "A node only option to determine if terminal summary data should be logged to the" +
                " console.",
            label: "Log Summary to Console",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                "default": "Default minimal summary",
                "log": "Verbose logging",
                "quiet": "No extraneous logging"
            }
        },
        force_attribute: {
            api: "any",
            default: false,
            definition: "If all markup attributes should be indented each onto their own line.",
            label: "Force Indentation of All Attributes",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        force_indent: {
            api: "any",
            default: false,
            definition: "Will force indentation upon all content and tags without regard for the creation" +
                " of new text nodes.",
            label: "Force Indentation of All Content",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        format_array: {
            api: "any",
            default: "default",
            definition: "Determines if all array indexes should be indented, never indented, or left to t" +
                "he default.",
            label: "Formatting Arrays",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "default": "Default formatting",
                "indent": "Always indent each index of an array",
                "inline": "Ensure all array indexes appear on a single line"
            }
        },
        format_object: {
            api: "any",
            default: "default",
            definition: "Determines if all object keys should be indented, never indented, or left to the" +
                " default.",
            label: "Formatting Objects",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "default": "Default formatting",
                "indent": "Always indent each key/value pair",
                "inline": "Ensure all key/value pairs appear on the same single line"
            }
        },
        function_name: {
            api: "any",
            default: false,
            definition: "If a space should follow a JavaScript function name.",
            label: "Space After Function Name",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        help: {
            api: "node",
            default: 80,
            definition: "A node only option to print documentation to the console. The value determines w" +
                "here to wrap text.",
            label: "Help Wrapping Limit",
            lexer: "any",
            mode: "any",
            type: "number"
        },
        indent_char: {
            api: "any",
            default: " ",
            definition: "The string characters to comprise a single indentation. Any string combination i" +
                "s accepted.",
            label: "Indentation Characters",
            lexer: "any",
            mode: "beautify",
            type: "string"
        },
        indent_level: {
            api: "any",
            default: 0,
            definition: "How much indentation padding should be applied to beautification? This option is" +
                " internally used for code that requires switching between libraries.",
            label: "Indentation Padding",
            lexer: "any",
            mode: "beautify",
            type: "number"
        },
        indent_size: {
            api: "any",
            default: 4,
            definition: "The number of 'indent_char' values to comprise a single indentation.",
            label: "Indent Size",
            lexer: "any",
            mode: "beautify",
            type: "number"
        },
        jsscope: {
            api: "any",
            default: "none",
            definition: "An educational tool to generate HTML output of JavaScript code to identify scope" +
                " regions and declared references by color.  This option is ignored unless the code language is JavaScript or TypeScript.",
            label: "JavaScript Scope Identification",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                html: "generates HTML output with escaped angle braces and ampersands for embedding as " +
                    "code, which is handy in code producing tools",
                none: "prevents use of this option",
                report: "generates HTML output that renders in web browsers"
            }
        },
        language: {
            api: "any",
            default: "auto",
            definition: "The lowercase single word common name of the source code's programming language. The value 'auto' imposes language and lexer auto-detection, which ignores deliberately specified lexer values. The value 'text' is converted to 'auto' if options 'mode' is not 'diff'. Value 'text' allows literal comparisons.",
            label: "Language",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        language_default: {
            api: "any",
            default: "text",
            definition: "The fallback option if option 'lang' is set to 'auto' and a language cannot be d" +
                "etected.",
            label: "Language Auto-Detection Default",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        language_name: {
            api: "any",
            default: "JavaScript",
            definition: "The formatted proper name of the code sample's language for use in reports read " +
                "by people.",
            label: "Formatted Name of the Code's Language",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        lexer: {
            api: "any",
            default: "auto",
            definition: "This option determines which sets of rules to use in the language parser. If opt" +
                "ion 'language' has a value of 'auto', which is the default value, this option is" +
                " ignored. The value 'text' is converted to 'auto' if options 'mode' is not 'diff'. Value 'text' allows literal comparisons.",
            label: "Parsing Lexer",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                auto: "The value 'auto' imposes language and lexer auto-detection, which ignores deliberately specified language values.",
                markup: "parses languages like XML and HTML",
                script: "parses languages with a C style syntax, such as JavaScript",
                style: "parses CSS like languages"
            }
        },
        list_options: {
            api: "node",
            default: false,
            definition: "A Node.js only option that writes current option settings to the console.",
            label: "Options List",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        method_chain: {
            api: "any",
            default: 3,
            definition: "When to break consecutively chained methods and properties onto separate lines. " +
                "A negative value disables this option. A value of 0 ensures method chains are ne" +
                "ver broken.",
            label: "Method Chains",
            lexer: "script",
            mode: "beautify",
            type: "number"
        },
        minify_keep_comments: {
            api: "any",
            default: false,
            definition: "Prevents minification from stripping out comments.",
            label: "Keep Comments",
            lexer: "any",
            mode: "minify",
            type: "boolean"
        },
        minify_wrap: {
            api: "any",
            default: false,
            definition: "Whether minified script should wrap after a specified character width.  This opt" +
                "ion requires a value from option 'wrap'.",
            label: "Minification Wrapping",
            lexer: "script",
            mode: "minify",
            type: "boolean"
        },
        mode: {
            api: "any",
            default: "diff",
            definition: "The operation to be performed.",
            label: "Mode",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                beautify: "beautifies code and returns a string",
                diff: "returns either command line list of differences or an HTML report",
                minify: "minifies code and returns a string",
                parse: "using option 'parseFormat' returns an object with shallow arrays, a multidimensi" +
                    "onal array, or an HTML report"
            }
        },
        never_flatten: {
            api: "any",
            default: false,
            definition: "If destructured lists in script should never be flattend.",
            label: "Never Flatten Destructured Lists",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        new_line: {
            api: "any",
            default: false,
            definition: "Insert an empty line at the end of output.",
            label: "New Line at End of Code",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        no_case_indent: {
            api: "any",
            default: false,
            definition: "If a case statement should receive the same indentation as the containing switch" +
                " block.",
            label: "Case Indentation",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        no_lead_zero: {
            api: "any",
            default: false,
            definition: "Whether leading 0s in CSS values immediately preceding a decimal should be remo" +
                "ved or prevented.",
            label: "Leading 0s",
            lexer: "style",
            mode: "any",
            type: "boolean"
        },
        no_semicolon: {
            api: "any",
            default: false,
            definition: "Removes semicolons that would be inserted by ASI. This option is in conflict with option 'correct' and takes precedence over conflicting features. Use of this option is a possible security/stability risk.",
            label: "No Semicolons",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        node_error: {
            api: "node",
            default: false,
            definition: "A Node.js only option if parse errors should be written to the console.",
            label: "Write Parse Errors in Node",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        object_sort: {
            api: "any",
            default: false,
            definition: "Sorts markup attributes and properties by key name in script and style.",
            label: "Object/Attribute Sort",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        output: {
            api: "node",
            default: "",
            definition: "A file path for which to write output. If this option is not specified output will be printed to the shell.",
            label: "Output Location",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        parse_format: {
            api: "any",
            default: "parallel",
            definition: "Determines the output format for 'parse' mode.",
            label: "Parse Format",
            lexer: "any",
            mode: "parse",
            type: "string",
            values: {
                htmltable: "generates the 'table' type output for the DOM but escapes the HTML tags for rend" +
                    "ering as HTML code in a HTML tool",
                parallel: "returns an object containing series of parallel arrays",
                sequential: "returns an array where each index is a child object containing the parsed token" +
                    " and all descriptive data",
                table: "generates a colorful grid of output for either the dom or command line interface"
            }
        },
        parse_space: {
            api: "any",
            default: false,
            definition: "Whether whitespace tokens should be included in markup parse output.",
            label: "Retain White Space Tokens in Parse Output",
            lexer: "markup",
            mode: "parse",
            type: "boolean"
        },
        preserve: {
            api: "any",
            default: 0,
            definition: "The maximum number of consecutive empty lines to retain.",
            label: "Preserve Consecutive New Lines",
            lexer: "any",
            mode: "beautify",
            type: "number"
        },
        preserve_comment: {
            api: "any",
            default: false,
            definition: "Prevent comment reformatting due to option wrap.",
            label: "Eliminate Word Wrap Upon Comments",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        preserve_text: {
            api: "any",
            default: false,
            definition: "If text in the provided markup code should be preserved exactly as provided. Thi" +
                "s option eliminates beautification and wrapping of text content.",
            label: "Preserve Markup Text White Space",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        quote: {
            api: "any",
            default: false,
            definition: "If true and mode is 'diff' then all single quote characters will be replaced by " +
                "double quote characters in both the source and diff file input so as to eliminat" +
                "e some differences from the diff report HTML output.",
            label: "Normalize Quotes",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        quote_convert: {
            api: "any",
            default: "none",
            definition: "If the quotes of script strings or markup attributes should be converted to sing" +
                "le quotes or double quotes.",
            label: "Indent Size",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                "double": "Converts single quotes to double quotes",
                "none": "Ignores this option",
                "single": "Converts double quotes to single quotes"
            }
        },
        read_method: {
            api: "node",
            default: "auto",
            definition: "The option determines how Node.js should receive input.  All output will be prin" +
                "ted to the shell unless the option 'output' is specified, which will write outpu" +
                "t to a file.",
            label: "Read Method",
            lexer: "any",
            mode: "any",
            type: "string",
            values: {
                auto: "changes to value subdirectory, file, or screen depending on source resolution",
                directory: "process all files in the specified directory only",
                file: "reads a file and outputs to a file.  file requires option 'output'",
                screen: "reads from screen and outputs to screen",
                subdirectory: "process all files in a directory and its subdirectories"
            }
        },
        selector_list: {
            api: "any",
            default: false,
            definition: "If comma separated CSS selectors should present on a single line of code.",
            label: "Indent Size",
            lexer: "style",
            mode: "beautify",
            type: "boolean"
        },
        semicolon: {
            api: "any",
            default: false,
            definition: "If true and mode is 'diff' and lang is 'javascript' all semicolon characters tha" +
                "t immediately precede any white space containing a new line character will be re" +
                "moved so as to eliminate some differences from the code comparison.",
            label: "Indent Size",
            lexer: "script",
            mode: "diff",
            type: "boolean"
        },
        source: {
            api: "any",
            default: "",
            definition: "The source code or location for interpretation. This option is required for all " +
                "modes.",
            label: "Source Sample",
            lexer: "any",
            mode: "any",
            type: "string"
        },
        source_label: {
            api: "any",
            default: "Source Sample",
            definition: "This allows for a descriptive label of the source file code for the diff HTML o" +
                "utput.",
            label: "Label for Source Sample",
            lexer: "any",
            mode: "diff",
            type: "string"
        },
        space: {
            api: "any",
            default: true,
            definition: "Inserts a space following the function keyword for anonymous functions.",
            label: "Function Space",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        space_close: {
            api: "any",
            default: false,
            definition: "Markup self-closing tags end will end with ' />' instead of '/>'.",
            label: "Close Markup Self-Closing Tags with a Space",
            lexer: "markup",
            mode: "beautify",
            type: "boolean"
        },
        styleguide: {
            api: "any",
            default: "none",
            definition: "Provides a collection of option presets to easily conform to popular JavaScript " +
                "style guides.",
            label: "Script Styleguide",
            lexer: "script",
            mode: "beautify",
            type: "string",
            values: {
                "airbnb": "https://github.com/airbnb/javascript",
                "crockford": "http://jslint.com/",
                "google": "https://google.github.io/styleguide/jsguide.html",
                "jquery": "https://contribute.jquery.org/style-guide/js/",
                "jslint": "http://jslint.com/",
                "mediawiki": "https://www.mediawiki.org/wiki/Manual:Coding_conventions/JavaScript",
                "mrdoob": "https://github.com/mrdoob/three.js/wiki/Mr.doob's-Code-Style%E2%84%A2",
                "none": "Ignores this option",
                "semistandard": "https://github.com/Flet/semistandard",
                "standard": "https://standardjs.com/",
                "yandex": "https://github.com/ymaps/codestyle/blob/master/javascript.md"
            }
        },
        summary_only: {
            api: "node",
            default: false,
            definition: "Node only option to output only number of differences.",
            label: "Output Diff Only Without A Summary",
            lexer: "any",
            mode: "diff",
            type: "boolean"
        },
        tag_merge: {
            api: "any",
            default: false,
            definition: "Allows immediately adjacement start and end markup tags of the same name to be c" +
                "ombined into a single self-closing tag.",
            label: "Merge Adjacent Start and End tags",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        tag_sort: {
            api: "any",
            default: false,
            definition: "Sort child items of each respective markup parent element.",
            label: "Sort Markup Child Items",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        ternary_line: {
            api: "any",
            default: false,
            definition: "If ternary operators in JavaScript ? and : should remain on the same line.",
            label: "Keep Ternary Statements On One Line",
            lexer: "script",
            mode: "beautify",
            type: "boolean"
        },
        top_comments: {
            api: "any",
            default: false,
            definition: "If mode is 'minify' this determines whether comments above the first line of cod" +
                "e should be kept.",
            label: "Retain Comment At Code Start",
            lexer: "any",
            mode: "minify",
            type: "boolean"
        },
        unformatted: {
            api: "any",
            default: false,
            definition: "If markup tags should have their insides preserved. This option is only available to markup and does not support child tokens that require a different lexer.",
            label: "Markup Tag Preservation",
            lexer: "markup",
            mode: "any",
            type: "boolean"
        },
        variable_list: {
            api: "any",
            default: "none",
            definition: "If consecutive JavaScript variables should be merged into a comma separated list" +
                " or if variables in a list should be separated.",
            label: "Variable Declaration Lists",
            lexer: "script",
            mode: "any",
            type: "string",
            values: {
                "each": "Ensurce each reference is a single declaration statement.",
                "list": "Ensure consecutive declarations are a comma separated list.",
                "none": "Ignores this option."
            }
        },
        version: {
            api: "node",
            default: false,
            definition: "A Node.js only option to write the version information to the console.",
            label: "Version",
            lexer: "any",
            mode: "any",
            type: "boolean"
        },
        vertical: {
            api: "any",
            default: false,
            definition: "If lists of assignments and properties should be vertically aligned. This option" +
                " is not used with the markup lexer.",
            label: "Vertical Alignment",
            lexer: "any",
            mode: "beautify",
            type: "boolean"
        },
        wrap: {
            api: "any",
            default: 0,
            definition: "Character width limit before applying word wrap. A 0 value disables this option." +
                " A negative value concatenates script strings.",
            label: "Wrap",
            lexer: "any",
            mode: "any",
            type: "number"
        }
    };
    prettydiff.api
        .optionDef = optionDef;
}());

(function beautify_markup_init() {
    const markup = function beautify_markup(options) {
        const data = options.parsed, lexer = "markup", c = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, lf = (options.crlf === true)
            ? "\r\n"
            : "\n", externalIndex = {}, levels = (function beautify_markup_levels() {
            const level = (prettydiff.start > 0)
                ? Array(prettydiff.start).fill(0, 0, prettydiff.start)
                : [], nextIndex = function beautify_markup_levels_next() {
                let x = a + 1, y = 0;
                if (data.types[x] === undefined) {
                    return x - 1;
                }
                if (data.types[x] === "comment" || (a < c - 1 && data.types[x].indexOf("attribute") > -1)) {
                    do {
                        if (data.types[x] === "jsx_attribute_start") {
                            y = x;
                            do {
                                if (data.types[x] === "jsx_attribute_end" && data.begin[x] === y) {
                                    break;
                                }
                                x = x + 1;
                            } while (x < c);
                        }
                        else if (data.types[x] !== "comment" && data.types[x].indexOf("attribute") < 0) {
                            return x;
                        }
                        x = x + 1;
                    } while (x < c);
                }
                return x;
            }, anchorList = function beautify_markup_levels_anchorList() {
                let aa = a;
                const stop = data.begin[a];
                // verify list is only a link list before making changes
                do {
                    aa = aa - 1;
                    if (data.token[aa] === "</li>" && data.begin[data.begin[aa]] === stop && data.token[aa - 1] === "</a>" && data.begin[aa - 1] === data.begin[aa] + 1) {
                        aa = data.begin[aa];
                    }
                    else {
                        return;
                    }
                } while (aa > stop + 1);
                // now make the changes
                aa = a;
                do {
                    aa = aa - 1;
                    if (data.types[aa + 1] === "attribute") {
                        level[aa] = -10;
                    }
                    else if (data.token[aa] !== "</li>") {
                        level[aa] = -20;
                    }
                } while (aa > stop + 1);
            }, comment = function beautify_markup_levels_comment() {
                let x = a, test = false;
                if (data.lines[a + 1] === 0 && options.force_indent === false) {
                    do {
                        if (data.lines[x] > 0) {
                            test = true;
                            break;
                        }
                        x = x - 1;
                    } while (x > comstart);
                    x = a;
                }
                else {
                    test = true;
                }
                // the first condition applies indentation while the else block does not
                if (test === true) {
                    let ind = (data.types[next] === "end" || data.types[next] === "template_end")
                        ? indent + 1
                        : indent;
                    do {
                        level.push(ind);
                        x = x - 1;
                    } while (x > comstart);
                    // correction so that a following end tag is not indented 1 too much
                    if (ind === indent + 1) {
                        level[a] = indent;
                    }
                    // indentation must be applied to the tag preceeding the comment
                    if (data.types[x] === "attribute" || data.types[x] === "template_attribute" || data.types[x] === "jsx_attribute_start") {
                        level[data.begin[x]] = ind;
                    }
                    else {
                        level[x] = ind;
                    }
                }
                else {
                    do {
                        level.push(-20);
                        x = x - 1;
                    } while (x > comstart);
                    level[x] = -20;
                }
                comstart = -1;
            }, content = function beautify_markup_levels_content() {
                let ind = indent;
                if (options.force_indent === true || options.force_attribute === true) {
                    level.push(indent);
                    return;
                }
                if (next < c && (data.types[next].indexOf("end") > -1 || data.types[next].indexOf("start") > -1) && data.lines[next] > 0) {
                    level.push(indent);
                    ind = ind + 1;
                    if (data.types[a] === "singleton" && a > 0 && data.types[a - 1].indexOf("attribute") > -1 && data.types[data.begin[a - 1]] === "singleton") {
                        if (data.begin[a] < 0 || (data.types[data.begin[a - 1]] === "singleton" && data.begin[data.ender[a] - 1] !== a)) {
                            level[a - 1] = indent;
                        }
                        else {
                            level[a - 1] = indent + 1;
                        }
                    }
                }
                else if (data.types[a] === "singleton" && a > 0 && data.types[a - 1].indexOf("attribute") > -1) {
                    level[a - 1] = indent;
                    count = data.token[a].length;
                    level.push(-10);
                }
                else if (data.lines[next] === 0) {
                    level.push(-20);
                }
                else if (
                // wrap if
                // * options.wrap is 0
                // * next token is singleton with an attribute and exceeds wrap
                // * next token is template or singleton and exceeds wrap
                (options.wrap === 0 ||
                    (a < c - 2 && data.token[a].length + data.token[a + 1].length + data.token[a + 2].length + 1 > options.wrap && data.types[a + 2].indexOf("attribute") > -1) ||
                    (data.token[a].length + data.token[a + 1].length > options.wrap)) &&
                    (data.types[a + 1] === "singleton" || data.types[a + 1] === "template")) {
                    level.push(indent);
                }
                else {
                    count = count + 1;
                    level.push(-10);
                }
                if (a > 0 && data.types[a - 1].indexOf("attribute") > -1 && data.lines[a] < 1) {
                    level[a - 1] = -20;
                }
                if (count > options.wrap) {
                    let d = a, e = Math.max(data.begin[a], 0);
                    if (data.types[a] === "content" && options.preserve_text === false) {
                        let countx = 0, chars = data.token[a].replace(/\s+/g, " ").split(" ");
                        do {
                            d = d - 1;
                            if (level[d] < 0) {
                                countx = countx + data.token[d].length;
                                if (level[d] === -10) {
                                    countx = countx + 1;
                                }
                            }
                            else {
                                break;
                            }
                        } while (d > 0);
                        d = 0;
                        e = chars.length;
                        do {
                            if (chars[d].length + countx > options.wrap) {
                                chars[d] = lf + chars[d];
                                countx = chars[d].length;
                            }
                            else {
                                chars[d] = ` ${chars[d]}`;
                                countx = countx + chars[d].length;
                            }
                            d = d + 1;
                        } while (d < e);
                        if (chars[0].charAt(0) === " ") {
                            data.token[a] = chars.join("").slice(1);
                        }
                        else {
                            level[a - 1] = ind;
                            data.token[a] = chars.join("").replace(lf, "");
                        }
                        if (data.token[a].indexOf(lf) > 0) {
                            count = data.token[a].length - data.token[a].lastIndexOf(lf);
                        }
                    }
                    else {
                        do {
                            d = d - 1;
                            if (level[d] > -1) {
                                count = data.token[a].length;
                                if (data.lines[a + 1] > 0) {
                                    count = count + 1;
                                }
                                return;
                            }
                            if (data.types[d].indexOf("start") > -1) {
                                count = 0;
                                return;
                            }
                            if ((data.types[d] !== "attribute" || (data.types[d] === "attribute" && data.types[d + 1] !== "attribute")) && data.lines[d + 1] > 0) {
                                if (data.types[d] !== "singleton" || (data.types[d] === "singleton" && data.types[d + 1] !== "attribute")) {
                                    count = data.token[a].length;
                                    if (data.lines[a + 1] > 0) {
                                        count = count + 1;
                                    }
                                    break;
                                }
                            }
                        } while (d > e);
                        level[d] = ind;
                    }
                }
            }, external = function beautify_markup_levels_external() {
                let skip = a;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip && data.types[a + 1] !== "start" && data.types[a + 1] !== "singleton") {
                        break;
                    }
                    level.push(0);
                    a = a + 1;
                } while (a < c);
                externalIndex[skip] = a;
                level.push(indent - 1);
                next = nextIndex();
                if (data.lexer[next] === lexer && data.stack[a].indexOf("attribute") < 0 && (data.types[next] === "end" || data.types[next] === "template_end")) {
                    indent = indent - 1;
                }
            }, attribute = function beautify_markup_levels_attribute() {
                const parent = a - 1, wrap = function beautify_markup_levels_attribute_wrap(index) {
                    const item = data.token[index].replace(/\s+/g, " ").split(" "), ilen = item.length;
                    let bb = 1, acount = item[0].length;
                    if ((/=("|')?(<|(\{(\{|%|#|@|!|\?|^))|(\[%))/).test(data.token[index]) === true) {
                        return;
                    }
                    do {
                        if (acount + item[bb].length > options.wrap) {
                            acount = item[bb].length;
                            item[bb] = lf + item[bb];
                        }
                        else {
                            item[bb] = ` ${item[bb]}`;
                            acount = acount + item[bb].length;
                        }
                        bb = bb + 1;
                    } while (bb < ilen);
                    data.token[index] = item.join("");
                };
                let y = a, len = data.token[parent].length + 1, plural = false, lev = (function beautify_markup_levels_attribute_level() {
                    if (data.types[a].indexOf("start") > 0) {
                        let x = a;
                        do {
                            if (data.types[x].indexOf("end") > 0 && data.begin[x] === a) {
                                if (x < c - 1 && data.types[x + 1].indexOf("attribute") > -1) {
                                    plural = true;
                                    break;
                                }
                            }
                            x = x + 1;
                        } while (x < c);
                    }
                    else if (a < c - 1 && data.types[a + 1].indexOf("attribute") > -1) {
                        plural = true;
                    }
                    if (data.types[next] === "end" || data.types[next] === "template_end") {
                        if (data.types[parent] === "singleton") {
                            return indent + 2;
                        }
                        return indent + 1;
                    }
                    if (data.types[parent] === "singleton") {
                        return indent + 1;
                    }
                    return indent;
                }()), earlyexit = false, attStart = false;
                if (plural === false && data.types[a] === "comment_attribute") {
                    // lev must be indent unless the "next" type is end then its indent + 1
                    level.push(indent);
                    if (data.types[parent] === "singleton") {
                        level[parent] = indent + 1;
                    }
                    else {
                        level[parent] = indent;
                    }
                    return;
                }
                if (lev < 1) {
                    lev = 1;
                }
                // first, set levels and determine if there are template attributes
                do {
                    count = count + data.token[a].length + 1;
                    if (data.types[a].indexOf("attribute") > 0) {
                        if (data.types[a] === "template_attribute") {
                            level.push(-10);
                        }
                        else if (data.types[a] === "comment_attribute") {
                            level.push(lev);
                        }
                        else if (data.types[a].indexOf("start") > 0) {
                            attStart = true;
                            if (a < c - 2 && data.types[a + 2].indexOf("attribute") > 0) {
                                level.push(-20);
                                a = a + 1;
                                externalIndex[a] = a;
                            }
                            else {
                                if (parent === a - 1 && plural === false) {
                                    level.push(lev);
                                }
                                else {
                                    level.push(lev + 1);
                                }
                                if (data.lexer[a + 1] !== lexer) {
                                    a = a + 1;
                                    external();
                                }
                            }
                        }
                        else if (data.types[a].indexOf("end") > 0) {
                            if (level[a - 1] !== -20) {
                                level[a - 1] = level[data.begin[a]] - 1;
                            }
                            if (data.lexer[a + 1] !== lexer) {
                                level.push(-20);
                            }
                            else {
                                level.push(lev);
                            }
                        }
                        else {
                            level.push(lev);
                        }
                        earlyexit = true;
                    }
                    else if (data.types[a] === "attribute") {
                        len = len + data.token[a].length + 1;
                        if (options.unformatted === true) {
                            level.push(-10);
                        }
                        else if (options.force_attribute === true || attStart === true || (a < c - 1 && data.types[a + 1] !== "template_attribute" && data.types[a + 1].indexOf("attribute") > 0)) {
                            level.push(lev);
                        }
                        else {
                            level.push(-10);
                        }
                    }
                    else if (data.begin[a] < parent + 1) {
                        break;
                    }
                    a = a + 1;
                } while (a < c);
                a = a - 1;
                if (level[a - 1] > 0 && data.types[a].indexOf("end") > 0 && data.types[a].indexOf("attribute") > 0 && data.types[parent] !== "singleton" && plural === true) {
                    level[a - 1] = level[a - 1] - 1;
                }
                if (level[a] !== -20) {
                    if (options.language === "jsx" && data.types[parent].indexOf("start") > -1 && data.types[a + 1] === "script_start") {
                        level[a] = lev;
                    }
                    else {
                        level[a] = level[parent];
                    }
                }
                if (options.force_attribute === true) {
                    count = 0;
                    level[parent] = lev;
                }
                else {
                    level[parent] = -10;
                }
                if (earlyexit === true || options.unformatted === true || data.token[parent] === "<%xml%>" || data.token[parent] === "<?xml?>") {
                    count = 0;
                    return;
                }
                y = a;
                // second, ensure tag contains more than one attribute
                if (y > parent + 1) {
                    // finally, indent attributes if tag length exceeds the wrap limit
                    if (options.space_close === false) {
                        len = len - 1;
                    }
                    if (len > options.wrap && options.wrap > 0 && options.force_attribute === false) {
                        count = data.token[a].length;
                        do {
                            if (data.token[y].length > options.wrap && (/\s/).test(data.token[y]) === true) {
                                wrap(y);
                            }
                            y = y - 1;
                            level[y] = lev;
                        } while (y > parent);
                    }
                }
                else if (options.wrap > 0 && data.types[a] === "attribute" && data.token[a].length > options.wrap && (/\s/).test(data.token[a]) === true) {
                    wrap(a);
                }
            };
            let a = prettydiff.start, comstart = -1, next = 0, count = 0, indent = (isNaN(options.indent_level) === true)
                ? 0
                : Number(options.indent_level);
            // data.lines -> space before token
            // level -> space after token
            do {
                if (data.lexer[a] === lexer) {
                    if (data.token[a].toLowerCase().indexOf("<!doctype") === 0) {
                        level[a - 1] = indent;
                    }
                    if (data.types[a].indexOf("attribute") > -1) {
                        attribute();
                    }
                    else if (data.types[a] === "comment") {
                        if (comstart < 0) {
                            comstart = a;
                        }
                        if (data.types[a + 1] !== "comment" || (a > 0 && data.types[a - 1].indexOf("end") > -1)) {
                            comment();
                        }
                    }
                    else if (data.types[a] !== "comment") {
                        next = nextIndex();
                        if (data.types[next] === "end" || data.types[next] === "template_end") {
                            indent = indent - 1;
                            if (data.types[next] === "template_end" && data.types[data.begin[next] + 1] === "template_else") {
                                indent = indent - 1;
                            }
                            if (data.token[a] === "</ol>" || data.token[a] === "</ul>") {
                                anchorList();
                            }
                        }
                        if (data.types[a] === "script_end" && data.types[a + 1] === "end") {
                            if (data.lines[a + 1] < 1) {
                                level.push(-20);
                            }
                            else {
                                level.push(-10);
                            }
                        }
                        else if ((options.force_indent === false || (options.force_indent === true && data.types[next] === "script_start")) && (data.types[a] === "content" || data.types[a] === "singleton" || data.types[a] === "template")) {
                            count = count + data.token[a].length;
                            if (data.lines[next] > 0 && data.types[next] === "script_start") {
                                level.push(-10);
                            }
                            else if (options.wrap > 0 && (data.types[a].indexOf("template") < 0 || (next < c && data.types[a].indexOf("template") > -1 && data.types[next].indexOf("template") < 0))) {
                                content();
                            }
                            else if (next < c && (data.types[next].indexOf("end") > -1 || data.types[next].indexOf("start") > -1) && (data.lines[next] > 0 || data.types[next].indexOf("template_") > -1)) {
                                level.push(indent);
                            }
                            else if (data.lines[next] === 0) {
                                level.push(-20);
                            }
                            else {
                                level.push(indent);
                            }
                        }
                        else if (data.types[a] === "start" || data.types[a] === "template_start") {
                            indent = indent + 1;
                            if (data.types[a] === "template_start" && data.types[a + 1] === "template_else") {
                                indent = indent + 1;
                            }
                            if (options.language === "jsx" && data.token[a + 1] === "{") {
                                if (data.lines[a + 1] === 0) {
                                    level.push(-20);
                                }
                                else {
                                    level.push(-10);
                                }
                            }
                            else if (data.types[a] === "start" && data.types[next] === "end") {
                                level.push(-20);
                            }
                            else if (data.types[a] === "start" && data.types[next] === "script_start") {
                                level.push(-10);
                            }
                            else if (options.force_indent === true) {
                                level.push(indent);
                            }
                            else if (data.types[a] === "template_start" && data.types[next] === "template_end") {
                                level.push(-20);
                            }
                            else if (data.lines[next] === 0 && (data.types[next] === "content" || data.types[next] === "singleton" || (data.types[a] === "start" && data.types[next] === "template"))) {
                                level.push(-20);
                            }
                            else {
                                level.push(indent);
                            }
                        }
                        else if (options.force_indent === false && data.lines[next] === 0 && (data.types[next] === "content" || data.types[next] === "singleton")) {
                            level.push(-20);
                        }
                        else if (data.types[a + 2] === "script_end") {
                            level.push(-20);
                        }
                        else if (data.types[a] === "template_else") {
                            if (data.types[next] === "template_end") {
                                level[a - 1] = indent + 1;
                            }
                            else {
                                level[a - 1] = indent - 1;
                            }
                            level.push(indent);
                        }
                        else {
                            level.push(indent);
                        }
                    }
                    if (data.types[a] !== "content" && data.types[a] !== "singleton" && data.types[a] !== "template" && data.types[a] !== "attribute") {
                        count = 0;
                    }
                }
                else {
                    count = 0;
                    external();
                }
                a = a + 1;
            } while (a < c);
            return level;
        }());
        return (function beautify_markup_apply() {
            const build = [], ind = (function beautify_markup_apply_tab() {
                const indy = [options.indent_char], size = options.indent_size - 1;
                let aa = 0;
                if (aa < size) {
                    do {
                        indy.push(options.indent_char);
                        aa = aa + 1;
                    } while (aa < size);
                }
                return indy.join("");
            }()), 
            // a new line character plus the correct amount of identation for the given line
            // of code
            nl = function beautify_markup_apply_nl(tabs) {
                const linesout = [], pres = options.preserve + 1, total = Math.min(data.lines[a + 1] - 1, pres);
                let index = 0;
                if (tabs < 0) {
                    tabs = 0;
                }
                do {
                    linesout.push(lf);
                    index = index + 1;
                } while (index < total);
                if (tabs > 0) {
                    index = 0;
                    do {
                        linesout.push(ind);
                        index = index + 1;
                    } while (index < tabs);
                }
                return linesout.join("");
            }, multiline = function beautify_markup_apply_multiline() {
                const lines = data.token[a].split(lf), line = data.lines[a + 1], lev = (levels[a - 1] > -1)
                    ? (data.types[a] === "attribute")
                        ? levels[a - 1] + 1
                        : levels[a - 1]
                    : (function beautify_markup_apply_multiline_lev() {
                        let bb = a - 1, start = (bb > -1 && data.types[bb].indexOf("start") > -1);
                        if (levels[a] > -1 && data.types[a] === "attribute") {
                            return levels[a] + 1;
                        }
                        do {
                            bb = bb - 1;
                            if (levels[bb] > -1) {
                                if (data.types[a] === "content" && start === false) {
                                    return levels[bb];
                                }
                                return levels[bb] + 1;
                            }
                            if (data.types[bb].indexOf("start") > -1) {
                                start = true;
                            }
                        } while (bb > 0);
                        return 1;
                    }());
                let aa = 0, len = lines.length - 1;
                data.lines[a + 1] = 0;
                do {
                    build.push(lines[aa]);
                    build.push(nl(lev));
                    aa = aa + 1;
                } while (aa < len);
                data.lines[a + 1] = line;
                build.push(lines[len]);
                if (levels[a] === -10) {
                    build.push(" ");
                }
                else if (levels[a] > -1) {
                    build.push(nl(levels[a]));
                }
            }, attributeEnd = function beautify_markup_apply_attributeEnd() {
                const parent = data.token[a], regend = (/(\/|\?)?>$/), end = regend.exec(parent);
                let y = a + 1, space = (options.space_close === true && end !== null && end[0] === "/>")
                    ? " "
                    : "", jsx = false;
                if (end === null) {
                    return;
                }
                data.token[a] = parent.replace(regend, "");
                do {
                    if (data.types[y] === "jsx_attribute_end" && data.begin[data.begin[y]] === a) {
                        jsx = false;
                    }
                    else if (data.begin[y] === a) {
                        if (data.types[y] === "jsx_attribute_start") {
                            jsx = true;
                        }
                        else if (data.types[y].indexOf("attribute") < 0 && jsx === false) {
                            break;
                        }
                    }
                    else if (jsx === false && (data.begin[y] < a || data.types[y].indexOf("attribute") < 0)) {
                        break;
                    }
                    y = y + 1;
                } while (y < c);
                if (data.types[y - 1] === "comment_attribute") {
                    space = nl(levels[y - 2] - 1);
                }
                data.token[y - 1] = data.token[y - 1] + space + end[0];
            };
            let a = prettydiff.start, external = "", lastLevel = options.indent_level;
            do {
                if (data.lexer[a] === lexer || prettydiff.beautify[data.lexer[a]] === undefined) {
                    if ((data.types[a] === "start" || data.types[a] === "singleton" || data.types[a] === "xml" || data.types[a] === "sgml") && data.types[a].indexOf("attribute") < 0 && a < c - 1 && data.types[a + 1] !== undefined && data.types[a + 1].indexOf("attribute") > -1) {
                        attributeEnd();
                    }
                    if (data.token[a] !== undefined && data.token[a].indexOf(lf) > 0 && ((data.types[a] === "content" && options.preserve_text === false) || data.types[a] === "comment" || data.types[a] === "attribute")) {
                        multiline();
                    }
                    else {
                        build.push(data.token[a]);
                        if (levels[a] === -10 && a < c - 1) {
                            build.push(" ");
                        }
                        else if (levels[a] > -1) {
                            lastLevel = levels[a];
                            build.push(nl(levels[a]));
                        }
                    }
                }
                else {
                    if (externalIndex[a] === a && data.types[a] !== "reference") {
                        build.push(data.token[a]);
                    }
                    else {
                        prettydiff.end = externalIndex[a];
                        options.indent_level = lastLevel;
                        prettydiff.start = a;
                        external = prettydiff.beautify[data.lexer[a]](options).replace(/\s+$/, "");
                        build.push(external);
                        if (levels[prettydiff.iterator] > -1 && externalIndex[a] > a) {
                            build.push(nl(levels[prettydiff.iterator]));
                        }
                        a = prettydiff.iterator;
                    }
                }
                a = a + 1;
            } while (a < c);
            prettydiff.iterator = c - 1;
            if (build[0] === lf || build[0] === " ") {
                build[0] = "";
            }
            return build.join("");
        }());
    };
    prettydiff.beautify.markup = markup;
}());
(function diffview_init() {
    const diffview = function diffview_(options) {
        const tab = (function diffview_tab() {
            let a = 0;
            const output = [];
            if (options.indent_char === "" || options.indent_size < 1) {
                return "";
            }
            do {
                output.push(options.indent_char);
                a = a + 1;
            } while (a < options.indent_size);
            return output.join("");
        }()), 
        // translates source code from a string to an array by splitting on line breaks
        stringAsLines = function diffview_stringAsLines(str) {
            const lines = (options.diff_format === "text")
                ? str
                : str
                    .replace(/&/g, "&amp;")
                    .replace(/&#lt;/g, "$#lt;")
                    .replace(/&#gt;/g, "$#gt;")
                    .replace(/</g, "$#lt;")
                    .replace(/>/g, "$#gt;");
            if (options.crlf === true) {
                return lines.split("\r\n");
            }
            return lines.split("\n");
        }, 
        // array representation of base source
        baseTextArray = (typeof options.source === "string")
            ? stringAsLines(options.source)
            : options.source, 
        // array representation of new source
        newTextArray = (typeof options.diff === "string")
            ? stringAsLines(options.diff)
            : options.diff, codeBuild = function diffview_opcodes() {
            const table = {}, one = baseTextArray, two = newTextArray;
            let lena = one.length, lenb = two.length, a = 0, b = 0, c = 0, d = 0, codes = [], clean = function diffview_opcodes_clean(ln) {
                if (ln === undefined) {
                    return;
                }
                return options.diff_space_ignore === true ? ln.replace(/\s+/g, '') : ln;
            }, fix = function diffview_opcodes_fix(code) {
                let len = codes.length - 1, prior = codes[len];
                if (prior !== undefined) {
                    if (prior[0] === code[0]) {
                        if (code[0] === "replace" || code[0] === "equal") {
                            prior[2] = code[2];
                            prior[4] = code[4];
                        }
                        else if (code[0] === "delete") {
                            prior[2] = code[2];
                        }
                        else if (code[0] === "insert") {
                            prior[4] = code[4];
                        }
                        if (codes.length > 1 && prior[2] === code[2] && prior[4] === code[4]) {
                            if (prior[0] === "insert" && clean(two[codes[codes.length - 2][4] - (prior[4] - prior[3])]) === clean(one[codes[codes.length - 2][1]])) {
                                codes.pop();
                                len = len - 1;
                                codes[len] = ["insert", -1, -1, codes[len][3], codes[len][4] - (prior[4] - prior[3])];
                                if (codes[len][4] < 0) {
                                    codes[len][4] = prior[4] - prior[3];
                                }
                                do {
                                    // one-sided replacement undo, more like undelete
                                    table[one[c]][0] = table[one[c]][0] + 1;
                                    c = c - 1;
                                } while (c > codes[codes.length - 2][2]);
                                d = codes[len][4] - 1;
                            }
                        }
                        return;
                    }
                    if (prior[0] === "insert" && prior[4] - prior[3] === 1) {
                        if (code[2] - code[1] === 1) {
                            if (code[0] === "replace") {
                                codes[len] = ["replace", code[1], code[2], prior[3], prior[4]];
                                prior = codes[len];
                                code = ["insert", -1, -2, code[3], code[4]];
                            }
                            else if (code[0] === "delete") {
                                code = ["replace", code[1], code[2], prior[3], prior[4]];
                                codes.pop();
                                len = len - 1;
                                prior = codes[len];
                                if (codes[len][0] === "replace") {
                                    prior[2] = code[2];
                                    prior[4] = code[4];
                                    return;
                                }
                            }
                        }
                        else if (code[0] === "delete") {
                            codes[len] = ["replace", code[1], code[1] + 1, prior[3], prior[4]];
                            prior = codes[len];
                            code[1] = code[1] + 1;
                        }
                        else if (code[0] === "replace") {
                            codes[len] = ["replace", code[1], code[1] + 1, prior[3], prior[4]];
                            prior = codes[len];
                            c = (prior[2] > 0)
                                ? prior[2]
                                : 0;
                            d = (prior[4] > 0)
                                ? prior[4]
                                : 0;
                            return;
                        }
                    }
                    else if (prior[0] === "insert" && code[0] === "delete" && code[2] - code[1] === 1) {
                        prior[4] = prior[4] - 1;
                        code = ["replace", code[1], code[2], prior[4], prior[4] + 1];
                    }
                    else if (prior[0] === "delete" && prior[2] - prior[1] === 1) {
                        if (code[4] - code[3] === 1) {
                            if (code[0] === "replace") {
                                codes[len] = ["replace", prior[1], prior[2], code[3], code[4]];
                                prior = codes[len];
                                code = ["delete", code[1], code[2], -1, -1];
                            }
                            else if (code[0] === "insert") {
                                code = ["replace", prior[1], prior[2], code[3], code[4]];
                                codes.pop();
                                len = len - 1;
                                prior = codes[len];
                                if (codes[len][0] === "replace") {
                                    prior[2] = code[2];
                                    prior[4] = code[4];
                                    return;
                                }
                            }
                        }
                        else if (code[0] === "insert") {
                            codes[len] = ['replace', prior[1], prior[2], code[3], code[3] + 1];
                            prior = codes[len];
                            code[3] = code[3] + 1;
                        }
                        else if (code[0] === "replace") {
                            codes[len] = ["replace", prior[1], prior[2], code[3], code[4] + 1];
                            c = (prior[2] > 0)
                                ? prior[2]
                                : 0;
                            d = (prior[4] > 0)
                                ? prior[4]
                                : 0;
                            return;
                        }
                    }
                    else if (prior[0] === "delete" && code[0] === "insert" && code[4] - code[3] === 1) {
                        prior[2] = prior[2] - 1;
                        code = ["replace", prior[2], prior[2] + 1, code[3], code[4]];
                    }
                    else if (prior[0] === "replace") {
                        if (code[0] === "delete" && code[2] - 1 > a) {
                            c = (code[2] - 1 > 0)
                                ? code[2] - 1
                                : 0;
                            d = (prior[3] > 0)
                                ? prior[3]
                                : 0;
                            codes[len] = ["delete", prior[1], code[2] - 1, -1, -1];
                            return;
                        }
                        if (code[0] === "insert" && code[4] - 1 > b) {
                            c = (prior[1] > 0)
                                ? prior[1]
                                : 0;
                            d = (code[4] - 1 > 0)
                                ? code[4] - 1
                                : 0;
                            codes[len] = ["insert", -1, -1, prior[3], code[4] - 1];
                            return;
                        }
                    }
                }
                if (codes.length > 1 && codes[codes.length - 2][0] === codes[len][0]) {
                    codes[codes.length - 2][2] = codes[len][2];
                    codes[codes.length - 2][4] = codes[len][4];
                    codes.pop();
                    diffview_opcodes_fix(code);
                }
                else {
                    codes.push(code);
                }
            }, equality = function diffview_opcodes_equality() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    table[one[c]][1] = table[one[c]][1] - 1;
                    c = c + 1;
                    d = d + 1;
                } while (c < lena && d < lenb && clean(one[c]) === clean(two[d]));
                fix(["equal", a, c, b, d]);
                b = d - 1;
                a = c - 1;
            }, deletion = function diffview_opcodes_deletion() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    c = c + 1;
                } while (c < lena && table[one[c]][1] < 1);
                fix(["delete", a, c, -1, -1]);
                a = c - 1;
                b = d - 1;
            }, deletionStatic = function diffview_opcodes_deletionStatic() {
                table[one[a]][0] = table[one[a]][0] - 1;
                fix([
                    "delete", a, a + 1,
                    -1,
                    -1
                ]);
                a = c;
                b = d - 1;
            }, insertion = function diffview_opcodes_insertion() {
                do {
                    table[two[d]][1] = table[two[d]][1] - 1;
                    d = d + 1;
                } while (d < lenb && table[two[d]][0] < 1);
                fix(["insert", -1, -1, b, d]);
                a = c - 1;
                b = d - 1;
            }, insertionStatic = function diffview_opcodes_insertionStatic() {
                table[two[b]][1] = table[two[b]][1] - 1;
                fix([
                    "insert", -1, -1, b, b + 1
                ]);
                a = c - 1;
                b = d;
            }, replacement = function diffview_opcodes_replacement() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    table[two[d]][1] = table[two[d]][1] - 1;
                    c = c + 1;
                    d = d + 1;
                } while (c < lena && d < lenb && table[one[c]][1] > 0 && table[two[d]][0] > 0);
                fix(["replace", a, c, b, d]);
                a = c - 1;
                b = d - 1;
            }, replaceUniques = function diffview_opcodes_replaceUniques() {
                do {
                    table[one[c]][0] = table[one[c]][0] - 1;
                    c = c + 1;
                    d = d + 1;
                } while (c < lena && d < lenb && table[one[c]][1] < 1 && table[two[d]][0] < 1);
                fix(["replace", a, c, b, d]);
                a = c - 1;
                b = d - 1;
            };
            // * First Pass, account for lines from first file
            // * build the table from the second file
            do {
                if (table[two[b]] === undefined) {
                    table[two[b]] = [0, 1];
                }
                else {
                    table[two[b]][1] = table[two[b]][1] + 1;
                }
                b = b + 1;
            } while (b < lenb);
            // * Second Pass, account for lines from second file
            // * build the table from the first file
            lena = one.length;
            a = 0;
            do {
                if (table[one[a]] === undefined) {
                    table[one[a]] = [1, 0];
                }
                else {
                    table[one[a]][0] = table[one[a]][0] + 1;
                }
                a = a + 1;
            } while (a < lena);
            a = 0;
            b = 0;
            // find all equality... differences are what's left over solve only for the
            // second set test removing reverse test removing undefined checks for table
            // refs
            do {
                c = a;
                d = b;
                if (clean(one[a]) === clean(two[b])) {
                    equality();
                }
                else if (table[one[a]][1] < 1 && table[two[b]][0] < 1) {
                    replaceUniques();
                }
                else if (table[one[a]][1] < 1 && clean(one[a + 1]) !== clean(two[b + 2])) {
                    deletion();
                }
                else if (table[two[b]][0] < 1 && clean(one[a + 2]) !== clean(two[b + 1])) {
                    insertion();
                }
                else if (table[one[a]][0] - table[one[a]][1] === 1 && clean(one[a + 1]) !== clean(two[b + 2])) {
                    deletionStatic();
                }
                else if (table[two[b]][1] - table[two[b]][0] === 1 && clean(one[a + 2]) !== clean(two[b + 1])) {
                    insertionStatic();
                }
                else if (clean(one[a + 1]) === clean(two[b])) {
                    deletion();
                }
                else if (clean(one[a]) === clean(two[b + 1])) {
                    insertion();
                }
                else {
                    replacement();
                }
                a = a + 1;
                b = b + 1;
            } while (a < lena && b < lenb);
            if (lena - a === lenb - b) {
                if (clean(one[a]) === clean(two[b])) {
                    fix(["equal", a, lena, b, lenb]);
                }
                else {
                    fix(["replace", a, lena, b, lenb]);
                }
            }
            else if (a < lena) {
                fix(["delete", a, lena, -1, -1]);
            }
            else if (b < lenb) {
                fix(["insert", -1, -1, b, lenb]);
            }
            return codes;
        };
        let errorout = 0, 
        // diffline is a count of lines that are not equal
        diffline = 0, 
        // tab is a construct of a standard indentation for code
        opcodes = [];
        if (Array.isArray(options.source) === false && typeof options.source !== "string") {
            return ["Error: source value is not a string or array!", 0, 0];
        }
        if (Array.isArray(options.diff) === false && typeof options.diff !== "string") {
            return ["Error: diff value is not a string or array!", 0, 0];
        }
        opcodes = codeBuild();
        // diffview application contains three primary parts
        // 1.  opcodes - performs the 'largest common subsequence'    calculation to
        // determine which lines are different.  I    did not write this logic.  I have
        // rewritten it for    performance, but original logic is still intact.
        // 2.  charcomp - performs the 'largest common subsequence' upon    characters
        // of two compared lines.
        // 3.  The construction of the output into the 'node' array errorout is a count
        // of differences after the opcodes generate the other two core pieces of logic
        // are quaranteened into an anonymous function.
        return (function diffview_report() {
            let a = 0, i = 0, node = ["<div class='diff'>"], diffplural = "s", linesplural = "s", baseStart = 0, baseEnd = 0, newStart = 0, newEnd = 0, rowcnt = 0, rowItem = -1, rcount = 0, foldcount = 0, foldstart = -1, jump = 0, change = "", btest = false, ntest = false, repeat = false, ctest = true, code, baseItem = "", newItem = "", charcompOutput, finaldoc = "";
            const data = [
                [], [], [], []
            ], json = [], clidata = [], tabFix = new RegExp(`^((${tab.replace(/\\/g, "\\")})+)`), noTab = function diffview_report_noTab(str) {
                let b = 0;
                const strLen = str.length, output = [];
                if (strLen < 1) {
                    return output;
                }
                do {
                    output.push(str[b].replace(tabFix, ""));
                    b = b + 1;
                } while (b < strLen);
                return output;
            }, htmlfix = function diffview_report_htmlfix(item) {
                if (item === undefined) {
                    return "";
                }
                return item
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }, baseTab = (tab === "")
                ? []
                : noTab(baseTextArray), newTab = (tab === "")
                ? []
                : noTab(newTextArray), opcodesLength = opcodes.length, 
            // this is the character comparison logic that performs the 'largest common
            // subsequence' between two lines of code
            charcomp = function diffview_report_charcomp(lineA, lineB) {
                let b = 0, currentdiff = [], dataMinLength = 0, dataA = [], dataB = [];
                const cleanedA = (options.diff_format === "text")
                    ? lineA
                    : lineA
                        .replace(/&#160;/g, " ")
                        .replace(/&nbsp;/g, " ")
                        .replace(/&lt;/g, "<")
                        .replace(/&gt;/g, ">")
                        .replace(/\$#lt;/g, "<")
                        .replace(/\$#gt;/g, ">")
                        .replace(/&amp;/g, "&"), cleanedB = (options.diff_format === "text")
                    ? lineB
                    : lineB
                        .replace(/&#160;/g, " ")
                        .replace(/&nbsp;/g, " ")
                        .replace(/&lt;/g, "<")
                        .replace(/&gt;/g, ">")
                        .replace(/\$#lt;/g, "<")
                        .replace(/\$#gt;/g, ">")
                        .replace(/&amp;/g, "&"), regStart = (/_pdiffdiff\u005f/g), regEnd = (/_epdiffdiff\u005f/g), strStart = "_pdiffdiff\u005f", strEnd = "_epdiffdiff\u005f", tabdiff = (function diffview_report_charcomp_tabdiff() {
                    let tabMatchA = "", tabMatchB = "", splitA = "", splitB = "", matchListA = cleanedA.match(tabFix), matchListB = cleanedB.match(tabFix);
                    if (matchListA === null || matchListB === null || (matchListA[0] === "" && matchListA.length === 1) || (matchListB[0] === "" && matchListB.length === 1)) {
                        return ["", "", cleanedA, cleanedB];
                    }
                    tabMatchA = matchListA[0];
                    tabMatchB = matchListB[0];
                    splitA = cleanedA.split(tabMatchA)[1];
                    splitB = cleanedB.split(tabMatchB)[1];
                    if (tabMatchA.length > tabMatchB.length) {
                        tabMatchA = tabMatchA.slice(0, tabMatchB.length) + strStart + tabMatchA.slice(tabMatchB.length) + strEnd;
                    }
                    else {
                        tabMatchB = tabMatchB.slice(0, tabMatchA.length) + strStart + tabMatchB.slice(tabMatchA.length) + strEnd;
                    }
                    return [tabMatchA, tabMatchB, splitA, splitB];
                }()), whiteout = function diffview_report_charcomp_whiteout(whitediff) {
                    const spacetest = (/<((em)|(pd))>\u0020+<\/((em)|(pd))>/), crtest = (/<((em)|(pd))>\r+<\/((em)|(pd))>/);
                    if (spacetest.test(whitediff) === true) {
                        return whitediff;
                    }
                    if (crtest.test(whitediff) === true) {
                        return whitediff.replace(/\s+/, "(carriage return)");
                    }
                    return whitediff.replace(/\s+/, "(white space differences)");
                }, 
                // compare is the fuzzy string comparison algorithm
                compare = function diffview_report_charcomp_compare(start) {
                    let x = 0, y = 0, whitespace = false, wordtest = false, store = [];
                    const max = Math.max(dataA.length, dataB.length), sorta = function diffview_report_charcomp_compare_sorta(a, b) {
                        if (a[1] - a[0] < b[1] - b[0]) {
                            return 1;
                        }
                        return -1;
                    }, sortb = function diffview_report_charcomp_compare_sortb(a, b) {
                        if (a[0] + a[1] > b[0] + b[1]) {
                            return 1;
                        }
                        return -1;
                    }, whitetest = (/^(\s+)$/);
                    // first gather a list of all matching indexes into an array
                    x = start;
                    do {
                        y = start;
                        do {
                            if (dataA[x] === dataB[y] || dataB[x] === dataA[y]) {
                                store.push([x, y]);
                                if (dataA[y] === dataB[x] && dataA[y + 1] === dataB[x + 1] && whitetest.test(dataB[x - 1]) === true) {
                                    wordtest = true;
                                    store = [[x, y]];
                                }
                                if (dataA[x] === dataB[y] && dataA[x + 1] === dataB[y + 1] && whitetest.test(dataB[y - 1]) === true) {
                                    wordtest = true;
                                    store = [[x, y]];
                                }
                                break;
                            }
                            y = y + 1;
                        } while (y < max);
                        if (wordtest === true) {
                            break;
                        }
                        x = x + 1;
                    } while (x < dataMinLength);
                    // if there are no character matches then quit out
                    if (store.length === 0) {
                        return [dataMinLength, max, 0, whitespace];
                    }
                    // take the list of matches and sort it first sort by size of change with
                    // shortest up front second sort by sum of change start and end the second sort
                    // results in the smallest change from the earliest point
                    store.sort(sorta);
                    if (dataMinLength - start < 5000) {
                        store.sort(sortb);
                    }
                    // x should always be the shorter index (change start)
                    if (store[0][0] < store[0][1]) {
                        x = store[0][0];
                        y = store[0][1];
                    }
                    else {
                        y = store[0][0];
                        x = store[0][1];
                    }
                    // package the output
                    if (dataA[y] === dataB[x]) {
                        if (dataA[y - 1] === dataB[x - 1] && x !== start) {
                            x = x - 1;
                            y = y - 1;
                        }
                        if (options.diff_space_ignore === true && ((whitetest.test(dataA[y - 1]) === true && y - start > 0) || (whitetest.test(dataB[x - 1]) === true && x - start > 0))) {
                            whitespace = true;
                        }
                        return [x, y, 0, whitespace];
                    }
                    if (dataA[x] === dataB[y]) {
                        if (dataA[x - 1] === dataB[y - 1] && x !== start) {
                            x = x - 1;
                            y = y - 1;
                        }
                        if (options.diff_space_ignore === true && ((whitetest.test(dataA[x - 1]) === true && x - start > 0) || (whitetest.test(dataB[y - 1]) === true && y - start > 0))) {
                            whitespace = true;
                        }
                        return [x, y, 1, whitespace];
                    }
                };
                // if same after accounting for character entities then exit
                if (cleanedA === cleanedB) {
                    return [lineA, lineB];
                }
                // prevent extra error counting that occurred before entering this function
                errorout = errorout - 1;
                // diff for tabs
                if (tab !== "" && cleanedA
                    .length !== cleanedB
                    .length && cleanedA
                    .replace(tabFix, "") === cleanedB
                    .replace(tabFix, "") && options
                    .diff_space_ignore === false) {
                    errorout = errorout + 1;
                    if (options.diff_format === "text") {
                        tabdiff[0] = tabdiff[0] + tabdiff[2];
                        tabdiff[0] = tabdiff[0].replace(regStart, "<pd>").replace(regEnd, "</pd>");
                        tabdiff[1] = tabdiff[1] + tabdiff[3];
                        tabdiff[1] = tabdiff[1].replace(regStart, "<pd>").replace(regEnd, "</pd>");
                        return [
                            tabdiff[0], tabdiff[1]
                        ];
                    }
                    tabdiff[0] = tabdiff[0] + tabdiff[2];
                    tabdiff[0] = tabdiff[0]
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>");
                    tabdiff[1] = tabdiff[1] + tabdiff[3];
                    tabdiff[1] = tabdiff[1]
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>");
                    return [
                        tabdiff[0], tabdiff[1]
                    ];
                }
                // turn the pruned input into arrays
                dataA = cleanedA.split("");
                dataB = cleanedB.split("");
                // the length of the shortest array
                dataMinLength = Math.min(dataA.length, dataB.length);
                do { // if undefined break the loop
                    if (dataA[b] === undefined || dataB[b] === undefined) {
                        break;
                    }
                    // iterate until the arrays are not the same
                    if (dataA[b] !== dataB[b]) {
                        // fuzzy string comparison returns an array with these indexes 0 - shorter
                        // ending index of difference 1 - longer ending index of difference 2 - 0 if
                        // index 2 is for dataA or 1 for dataB 3 - whether the difference is only
                        // whitespace
                        currentdiff = compare(b);
                        // supply the difference start indicator
                        if (currentdiff[3] === false) { // count each difference
                            errorout = errorout + 1;
                            if (b > 0) {
                                dataA[b - 1] = dataA[b - 1] + strStart;
                                dataB[b - 1] = dataB[b - 1] + strStart;
                            }
                            else {
                                dataA[b] = strStart + dataA[b];
                                dataB[b] = strStart + dataB[b];
                            }
                            // complex decision tree on how to supply difference end indicator
                            if (currentdiff[2] === 1) {
                                if (currentdiff[0] === 0) {
                                    dataA[0] = dataA[0].replace(regStart, strStart + strEnd);
                                }
                                else if (currentdiff[0] === dataMinLength) {
                                    if (dataB.length === dataMinLength) {
                                        dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;
                                    }
                                    else {
                                        dataA[currentdiff[0] - 1] = dataA[currentdiff[0] - 1] + strEnd;
                                    }
                                }
                                else {
                                    if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {
                                        if (dataA[b].indexOf(strStart) > -1) {
                                            dataA[b] = dataA[b] + strEnd;
                                        }
                                        else {
                                            dataA[b] = strEnd + dataA[b];
                                        }
                                    }
                                    else {
                                        if (dataA[currentdiff[0]].indexOf(strStart) > -1) {
                                            dataA[currentdiff[0]] = dataA[currentdiff[0]] + strEnd;
                                        }
                                        else {
                                            dataA[currentdiff[0]] = strEnd + dataA[currentdiff[0]];
                                        }
                                    }
                                }
                                if (currentdiff[1] > dataB.length - 1 || currentdiff[0] === dataMinLength) {
                                    dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;
                                }
                                else if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {
                                    dataB[b + (currentdiff[1] - currentdiff[0])] = dataB[b + (currentdiff[1] - currentdiff[0])] + strEnd;
                                }
                                else {
                                    dataB[currentdiff[1]] = strEnd + dataB[currentdiff[1]];
                                }
                            }
                            else {
                                if (currentdiff[0] === 0) {
                                    dataB[0] = dataB[0].replace(regStart, strStart + strEnd);
                                }
                                else if (currentdiff[0] === dataMinLength) {
                                    if (dataA.length === dataMinLength) {
                                        dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;
                                    }
                                    else {
                                        dataB[currentdiff[0] - 1] = dataB[currentdiff[0] - 1] + strEnd;
                                    }
                                }
                                else {
                                    if (currentdiff[1] - currentdiff[0] === currentdiff[0]) {
                                        if (dataB[b].indexOf(strStart) > -1) {
                                            dataB[b] = dataB[b] + strEnd;
                                        }
                                        else {
                                            dataB[b] = strEnd + dataB[b];
                                        }
                                    }
                                    else {
                                        if (dataB[currentdiff[0]].indexOf(strStart) > -1) {
                                            dataB[currentdiff[0]] = dataB[currentdiff[0]] + strEnd;
                                        }
                                        else {
                                            dataB[currentdiff[0]] = strEnd + dataB[currentdiff[0]];
                                        }
                                    }
                                }
                                if (currentdiff[1] > dataA.length - 1 || currentdiff[0] === dataMinLength) {
                                    dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;
                                }
                                else if (currentdiff[0] - currentdiff[1] === currentdiff[1]) {
                                    dataA[b + (currentdiff[0] - currentdiff[1])] = dataA[b + (currentdiff[0] - currentdiff[1])] + strEnd;
                                }
                                else {
                                    dataA[currentdiff[1]] = strEnd + dataA[currentdiff[1]];
                                }
                            }
                        }
                        // we must rebase the array with the shorter difference so that the end of the
                        // current difference is on the same index.  This provides a common baseline by
                        // which to find the next unmatching index
                        if (currentdiff[1] > currentdiff[0] && currentdiff[1] - currentdiff[0] < 1000) {
                            if (currentdiff[2] === 1) {
                                do {
                                    dataA.unshift("");
                                    currentdiff[0] = currentdiff[0] + 1;
                                } while (currentdiff[1] > currentdiff[0]);
                            }
                            else {
                                do {
                                    dataB.unshift("");
                                    currentdiff[0] = currentdiff[0] + 1;
                                } while (currentdiff[1] > currentdiff[0]);
                            }
                        }
                        // since the previous logic will grow the shorter array we have to redefine the
                        // shortest length
                        dataMinLength = Math.min(dataA.length, dataB.length);
                        // assign the incrementer to the end of the longer difference
                        b = currentdiff[1];
                    }
                    b = b + 1;
                } while (b < dataMinLength);
                // if one array is longer than the other and not identified as different then
                // identify this difference in length
                if (dataA
                    .length > dataB
                    .length && dataB[dataB.length - 1] !== undefined && dataB[dataB.length - 1]
                    .indexOf(strEnd) < 1) {
                    dataB.push(strStart + strEnd);
                    dataA[dataB.length - 1] = strStart + dataA[dataB.length - 1];
                    dataA[dataA.length - 1] = dataA[dataA.length - 1] + strEnd;
                    errorout = errorout + 1;
                }
                if (dataB
                    .length > dataA
                    .length && dataA[dataA.length - 1] !== undefined && dataA[dataA.length - 1]
                    .indexOf(strEnd) < 1) {
                    dataA.push(strStart + strEnd);
                    dataB[dataA.length - 1] = strStart + dataB[dataA.length - 1];
                    dataB[dataB.length - 1] = dataB[dataB.length - 1] + strEnd;
                    errorout = errorout + 1;
                }
                // options.diff_format output doesn't need XML protected characters to be escaped
                // when its value is 'text'
                if (options.diff_format === "text") {
                    return [
                        dataA
                            .join("")
                            .replace(regStart, "<pd>")
                            .replace(regEnd, "</pd>")
                            .replace(/<pd>\s+<\/pd>/g, whiteout)
                            .replace(/\r<\/pd>/g, "(carriage return)</pd>"),
                        dataB
                            .join("")
                            .replace(regStart, "<pd>")
                            .replace(regEnd, "</pd>")
                            .replace(/<pd>\s+<\/pd>/g, whiteout)
                            .replace(/\r<\/pd>/g, "(carriage return)</pd>")
                    ];
                }
                return [
                    dataA
                        .join("")
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>")
                        .replace(/<em>\s+<\/em>/g, whiteout)
                        .replace(/\r<\/em>/g, "(carriage return)</em>"),
                    dataB
                        .join("")
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(regStart, "<em>")
                        .replace(regEnd, "</em>")
                        .replace(/<em>\s+<\/em>/g, whiteout)
                        .replace(/\r<\/em>/g, "(carriage return)</em>"),
                ];
            };
            if (options.diff_format === "html") {
                if (options.diff_view === "inline") {
                    node.push("<h3 class='texttitle'>");
                    node.push(options.source_label);
                    node.push(" vs. ");
                    node.push(options.diff_label);
                    node.push("</h3><ol class='count'>");
                }
                else {
                    data[0].push("<div class='diff-left'><h3 class='texttitle'>");
                    data[0].push(options.source_label);
                    data[0].push("</h3><ol class='count'>");
                    data[2].push("<div class='diff-right'><h3 class='texttitle'>");
                    data[2].push(options.diff_label);
                    data[2].push("</h3><ol class='count' style='cursor:w-resize'>");
                }
            }
            else {
                foldstart = 0;
            }
            do {
                code = opcodes[a];
                change = code[0];
                baseStart = code[1];
                baseEnd = code[2];
                newStart = code[3];
                newEnd = code[4];
                rowcnt = Math.max(baseEnd - baseStart, newEnd - newStart);
                ctest = true;
                if (options.diff_format === "json") {
                    i = 0;
                    do {
                        if (change === "insert" && newTextArray[newStart + i] === undefined) {
                            break;
                        }
                        if (change !== "insert" && baseTextArray[baseStart + i] === undefined) {
                            break;
                        }
                        if (change !== "equal") {
                            errorout = errorout + 1;
                        }
                        if (change === "equal") {
                            json.push([
                                "=",
                                baseTextArray[baseStart + i]
                            ]);
                        }
                        else if (change === "replace") {
                            json.push([
                                "r",
                                baseTextArray[baseStart + i],
                                newTextArray[newStart + i]
                            ]);
                        }
                        else if (change === "insert") {
                            json.push([
                                "+",
                                newTextArray[newStart + i]
                            ]);
                        }
                        else {
                            json.push([
                                "-",
                                baseTextArray[baseStart + i]
                            ]);
                        }
                        i = i + 1;
                    } while (i < rowcnt);
                }
                else if (options.diff_format === "text") {
                    const text = {
                        angry: "\u001b[1m\u001b[4m",
                        clear: "\u001b[24m\u001b[22m",
                        cyan: "\u001b[36m",
                        green: "\u001b[32m",
                        none: "\u001b[0m",
                        red: "\u001b[31m"
                    };
                    if (foldstart > 49 && change === "equal") {
                        break;
                    }
                    // this is a check against false positives incurred by increasing or reducing of
                    // nesting.  At this time it only checks one level deep.
                    if (tab !== "") {
                        if (btest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof baseTextArray[baseStart + 1] === "string" && typeof newTextArray[newStart] === "string" && baseTab[baseStart + 1] === newTab[newStart] && baseTab[baseStart] !== newTab[newStart] && (typeof newTextArray[newStart - 1] !== "string" || baseTab[baseStart] !== newTab[newStart - 1])) {
                            btest = true;
                        }
                        else if (ntest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof newTextArray[newStart + 1] === "string" && typeof baseTextArray[baseStart] === "string" && newTab[newStart + 1] === baseTab[baseStart] && newTab[newStart] !== baseTab[baseStart] && (typeof baseTextArray[baseStart - 1] !== "string" || newTab[newStart] !== baseTab[baseStart - 1])) {
                            ntest = true;
                        }
                    }
                    if (options
                        .diff_space_ignore === true && change === "replace" && baseTextArray[baseStart] !== undefined && newTextArray[newStart] !== undefined && baseTextArray[baseStart]
                        .replace(/\s+/g, "") === newTextArray[newStart]
                        .replace(/\s+/g, "")) {
                        change = "equal";
                    }
                    else if (change !== "equal") {
                        diffline = diffline + 1;
                        if (a > 0 && opcodes[a - 1][0] === "equal") {
                            foldcount = options.diff_context;
                            if ((ntest === true || change === "insert") && (options.diff_space_ignore === false || (/^(\s+)$/g).test(newTextArray[newStart]) === false)) {
                                foldstart = foldstart + 1;
                                if (options.api === "dom") {
                                    clidata.push("</li><li><h3>Line: ");
                                    clidata.push(String(opcodes[a - 1][2] + 1));
                                    clidata.push("</h3>");
                                }
                                else {
                                    clidata.push("");
                                    clidata.push(`${text.cyan}Line: ${(opcodes[a - 1][2] + 1) + text.none}`);
                                }
                                if (foldcount > 0) {
                                    do {
                                        if (newStart - foldcount > -1) {
                                            if (options.api === "dom") {
                                                clidata.push("<p>");
                                                clidata.push(htmlfix(newTextArray[newStart - foldcount]));
                                                clidata.push("</p>");
                                            }
                                            else {
                                                clidata.push(newTextArray[newStart - foldcount]);
                                            }
                                        }
                                        foldcount = foldcount - 1;
                                    } while (foldcount > 0);
                                }
                            }
                            else {
                                foldstart = foldstart + 1;
                                if (options.api === "dom") {
                                    clidata.push("</li><li><h3>Line: ");
                                    clidata.push(String(baseStart + 1));
                                    clidata.push("</h3>");
                                }
                                else {
                                    clidata.push("");
                                    clidata.push(`${text.cyan}Line: ${(baseStart + 1) + text.none}`);
                                }
                                if (foldcount > 0) {
                                    do {
                                        if (baseStart - foldcount > -1) {
                                            if (options.api === "dom") {
                                                clidata.push("<p>");
                                                clidata.push(htmlfix(baseTextArray[baseStart - foldcount]));
                                                clidata.push("</p>");
                                            }
                                            else {
                                                clidata.push(baseTextArray[baseStart - foldcount]);
                                            }
                                        }
                                        foldcount = foldcount - 1;
                                    } while (foldcount > 0);
                                }
                            }
                        }
                        else if (a < 1) {
                            if (options.api === "dom") {
                                clidata.push("</li><li><h3>Line: 1</h3>");
                            }
                            else {
                                clidata.push("");
                                clidata.push(`${text.cyan}Line: 1${text.none}`);
                            }
                            foldstart = foldstart + 1;
                        }
                        foldcount = 0;
                        if ((ntest === true || change === "insert") && (options.diff_space_ignore === false || (/^(\s+)$/g).test(newTextArray[newStart]) === false)) {
                            do {
                                if (options.api === "dom") {
                                    clidata.push("<ins>");
                                    clidata.push(htmlfix(newTextArray[newStart + foldcount]));
                                    clidata.push("</ins>");
                                }
                                else {
                                    if (newTextArray[newStart + foldcount] === "") {
                                        clidata.push(`${text.green}(empty line)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text.green + newTextArray[newStart + foldcount] + text.none);
                                    }
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < 7 && foldcount + newStart < newEnd);
                        }
                        else if (change === "delete" && (options.diff_space_ignore === false || (/^(\s+)$/g).test(baseTextArray[baseStart]) === false)) {
                            do {
                                if (options.api === "dom") {
                                    clidata.push("<del>");
                                    clidata.push(htmlfix(baseTextArray[baseStart + foldcount]));
                                    clidata.push("</del>");
                                }
                                else {
                                    if (baseTextArray[baseStart + foldcount] === "") {
                                        clidata.push(`${text.red}(empty line)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text.red + baseTextArray[baseStart + foldcount] + text.none);
                                    }
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);
                        }
                        else if (change === "replace" && (options
                            .diff_space_ignore === false || baseTextArray[baseStart]
                            .replace(/\s+/g, "") !== newTextArray[newStart]
                            .replace(/\s+/g, ""))) {
                            do {
                                charcompOutput = charcomp(baseTextArray[baseStart + foldcount], newTextArray[newStart + foldcount]);
                                if (options.api === "dom") {
                                    clidata.push("<del>");
                                    clidata.push(htmlfix(charcompOutput[0]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\/pd&gt;/g, "</em>"));
                                    clidata.push("</del><ins>");
                                    clidata.push(htmlfix(charcompOutput[1]).replace(/&lt;pd&gt;/g, "<em>").replace(/&lt;\/pd&gt;/g, "</em>"));
                                    clidata.push("</ins>");
                                }
                                else {
                                    if (charcompOutput[0] === "") {
                                        clidata.push(`${text.red}(empty line)${text.none}`);
                                    }
                                    else if ((/^\s+$/).test(charcompOutput[0]) === true) {
                                        clidata.push(`${text.red}(white space)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text
                                            .red + charcompOutput[0]
                                            .replace(/<pd><\/pd>/g, "")
                                            .replace(/<pd>/g, text.angry)
                                            .replace(/<\/pd>/g, text.clear)
                                            .replace(/\s+$/, "") + text
                                            .none);
                                    }
                                    if (charcompOutput[1] === "") {
                                        clidata.push(`${text.green}(empty line)${text.none}`);
                                    }
                                    else if ((/^\s+$/).test(charcompOutput[1]) === true) {
                                        clidata.push(`${text.green}(white space)${text.none}`);
                                    }
                                    else {
                                        clidata.push(text
                                            .green + charcompOutput[1]
                                            .replace(/<pd><\/pd>/g, "")
                                            .replace(/<pd>/g, text.angry)
                                            .replace(/<\/pd>/g, text.clear)
                                            .replace(/\s+$/, "") + text
                                            .none);
                                    }
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < 7 && foldcount + baseStart < baseEnd);
                        }
                        if (((change === "insert" && foldcount + newStart === newEnd) || (change !== "insert" && foldcount + baseStart === baseEnd)) && baseTextArray[baseStart + foldcount] !== undefined && options.diff_context > 0 && a < opcodesLength - 1 && opcodes[a + 1][0] === "equal") {
                            foldcount = 0;
                            baseStart = opcodes[a + 1][1];
                            baseEnd = opcodes[a + 1][2] - baseStart;
                            do {
                                if (options.api === "dom") {
                                    clidata.push("<p>");
                                    clidata.push(htmlfix(baseTextArray[baseStart + foldcount]));
                                    clidata.push("</p>");
                                }
                                else {
                                    clidata.push(baseTextArray[baseStart + foldcount]);
                                }
                                foldcount = foldcount + 1;
                            } while (foldcount < options.diff_context && foldcount < baseEnd);
                        }
                        if (btest === true) {
                            baseStart = baseStart + 1;
                            btest = false;
                        }
                        else if (ntest === true) {
                            newStart = newStart + 1;
                            ntest = false;
                        }
                        else {
                            baseStart = baseStart + 1;
                            newStart = newStart + 1;
                        }
                    }
                }
                else {
                    if (foldstart > -1) {
                        data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount));
                    }
                    i = 0;
                    do { // apply options.diff_context collapsing for the output, if needed
                        if (options.diff_context > -1 && opcodes.length > 1 && ((a > 0 && i === options.diff_context) || (a === 0 && i === 0)) && change === "equal") {
                            ctest = false;
                            jump = rowcnt - ((a === 0
                                ? 1
                                : 2) * options.diff_context);
                            if (jump > 1) {
                                baseStart = baseStart + jump;
                                newStart = newStart + jump;
                                i = i + (jump - 1);
                                data[0].push("<li>...</li>");
                                if (options.diff_view !== "inline") {
                                    data[1].push("<li class=\"skip\">&#10;</li>");
                                }
                                data[2].push("<li>...</li>");
                                data[3].push("<li class=\"skip\">&#10;</li>");
                                if (a + 1 === opcodes.length) {
                                    break;
                                }
                            }
                        }
                        else if (change !== "equal") {
                            diffline = diffline + 1;
                        }
                        if (options.api === "dom" && baseTextArray[baseStart] !== undefined) {
                            baseItem = baseTextArray[baseStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        }
                        else {
                            baseItem = baseTextArray[baseStart];
                        }
                        if (options.api === "dom" && newTextArray[newStart] !== undefined) {
                            newItem = newTextArray[newStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        }
                        else {
                            newItem = newTextArray[newStart];
                        }
                        // this is a check against false positives incurred by increasing or reducing of
                        // nesting.  At this time it only checks one level deep.
                        if (tab !== "") {
                            if (btest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof baseTextArray[baseStart + 1] === "string" && typeof newItem === "string" && baseTab[baseStart + 1] === newTab[newStart] && baseTab[baseStart] !== newTab[newStart] && (typeof newTextArray[newStart - 1] !== "string" || baseTab[baseStart] !== newTab[newStart - 1])) {
                                btest = true;
                            }
                            else if (ntest === false && baseTextArray[baseEnd] !== newTextArray[newEnd] && typeof newTextArray[newStart + 1] === "string" && typeof baseItem === "string" && newTab[newStart + 1] === baseTab[baseStart] && newTab[newStart] !== baseTab[baseStart] && (typeof baseTextArray[baseStart - 1] !== "string" || newTab[newStart] !== baseTab[baseStart - 1])) {
                                ntest = true;
                            }
                        }
                        foldcount = foldcount + 1;
                        if (options.diff_view === "inline") {
                            if (options
                                .diff_space_ignore === true && change === "replace" && baseItem
                                .replace(/\s+/g, "") === newItem
                                .replace(/\s+/g, "")) {
                                change = "equal";
                                errorout = errorout - 1;
                            }
                            if (options.diff_context < 0 && rowItem < a) {
                                rowItem = a;
                                if (foldstart > -1) {
                                    if (data[0][foldstart + 1] === String(foldcount - 1)) {
                                        data[0][foldstart] = `<li class="${data[0][foldstart].slice(data[0][foldstart].indexOf("line xxx\">- ") + 12)}`;
                                    }
                                    else {
                                        data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount - 1 + rcount));
                                    }
                                }
                                if (change !== "replace") {
                                    if (baseEnd - baseStart > 1 || newEnd - newStart > 1) {
                                        data[0].push(`<li class="fold" title="folds from line ${foldcount + rcount} to line xxx">- `);
                                        foldstart = data[0].length - 1;
                                    }
                                    else {
                                        data[0].push("<li>");
                                    }
                                    if (ntest === true || change === "insert") {
                                        data[0].push("&#10;");
                                    }
                                    else {
                                        data[0].push(String(baseStart + 1));
                                    }
                                    data[0].push("</li>");
                                }
                                else {
                                    rcount = rcount + 1;
                                }
                            }
                            else if (change !== "replace") {
                                data[0].push("<li>");
                                if (ntest === true || change === "insert") {
                                    data[0].push("&#10;");
                                }
                                else {
                                    data[0].push(String(baseStart + 1));
                                }
                                data[0].push("</li>");
                            }
                            else if (change === "replace") {
                                rcount = rcount + 1;
                            }
                            if (ntest === true || change === "insert") {
                                data[2].push("<li>");
                                data[2].push(String(newStart + 1));
                                data[2].push("&#10;</li>");
                                if (options.diff_space_ignore === true && newItem.replace(/\s+/g, "") === "") {
                                    data[3].push("<li class=\"equal\">");
                                    diffline = diffline - 1;
                                }
                                else {
                                    data[3].push("<li class=\"insert\">");
                                }
                                data[3].push(newItem);
                                data[3].push("&#10;</li>");
                            }
                            else if (btest === true || change === "delete") {
                                data[2].push("<li class=\"empty\">&#10;</li>");
                                if (options.diff_space_ignore === true && baseItem.replace(/\s+/g, "") === "") {
                                    data[3].push("<li class=\"equal\">");
                                    diffline = diffline - 1;
                                }
                                else {
                                    data[3].push("<li class=\"delete\">");
                                }
                                data[3].push(baseItem);
                                data[3].push("&#10;</li>");
                            }
                            else if (change === "replace") {
                                if (baseItem !== newItem) {
                                    if (baseItem === "") {
                                        charcompOutput = [
                                            "", newItem
                                        ];
                                    }
                                    else if (newItem === "") {
                                        charcompOutput = [baseItem, ""];
                                    }
                                    else if (baseStart < baseEnd && newStart < newEnd) {
                                        charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);
                                    }
                                }
                                if (baseStart < baseEnd) {
                                    data[0].push(`<li>${baseStart + 1}</li>`);
                                    data[2].push("<li class=\"empty\">&#10;</li>");
                                    if (options.diff_space_ignore === true && baseItem.replace(/\s+/g, "") === "") {
                                        data[3].push("<li class=\"equal\">");
                                        diffline = diffline - 1;
                                    }
                                    else {
                                        data[3].push("<li class=\"delete\">");
                                    }
                                    if (newStart < newEnd) {
                                        data[3].push(charcompOutput[0]);
                                    }
                                    else {
                                        data[3].push(baseItem);
                                    }
                                    data[3].push("&#10;</li>");
                                }
                                if (newStart < newEnd) {
                                    data[0].push("<li class=\"empty\">&#10;</li>");
                                    data[2].push("<li>");
                                    data[2].push(String(newStart + 1));
                                    data[2].push("</li>");
                                    if (options.diff_space_ignore === true && newItem.replace(/\s+/g, "") === "") {
                                        data[3].push("<li class=\"equal\">");
                                        diffline = diffline - 1;
                                    }
                                    else {
                                        data[3].push("<li class=\"insert\">");
                                    }
                                    if (baseStart < baseEnd) {
                                        data[3].push(charcompOutput[1]);
                                    }
                                    else {
                                        data[3].push(newItem);
                                    }
                                    data[3].push("&#10;</li>");
                                }
                            }
                            else if (baseStart < baseEnd || newStart < newEnd) {
                                data[2].push("<li>");
                                data[2].push(String(newStart + 1));
                                data[2].push("</li>");
                                data[3].push("<li class=\"");
                                data[3].push(change);
                                data[3].push("\">");
                                data[3].push(baseItem);
                                data[3].push("&#10;</li>");
                            }
                            if (btest === true) {
                                baseStart = baseStart + 1;
                                btest = false;
                            }
                            else if (ntest === true) {
                                newStart = newStart + 1;
                                ntest = false;
                            }
                            else {
                                baseStart = baseStart + 1;
                                newStart = newStart + 1;
                            }
                        }
                        else {
                            if (btest === false && ntest === false && typeof baseItem === "string" && typeof newItem === "string") {
                                if (change === "replace" && baseStart < baseEnd && newStart < newEnd && baseItem !== newItem) {
                                    charcompOutput = charcomp(baseTextArray[baseStart], newTextArray[newStart]);
                                }
                                else if (options.api === "dom") {
                                    charcompOutput = [
                                        baseTextArray[baseStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"),
                                        newTextArray[newStart].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                                    ];
                                }
                                else {
                                    charcompOutput = [
                                        baseTextArray[baseStart], newTextArray[newStart]
                                    ];
                                }
                                if ((data[0].length > 0 && baseStart === Number(data[0][data[0].length - 1].slice(data[0][data[0].length - 1].indexOf(">") + 1, data[0][data[0].length - 1].lastIndexOf("<"))) - 1) || (data[2].length > 0 && newStart === Number(data[2][data[2].length - 1].slice(data[2][data[2].length - 1].indexOf(">") + 1, data[2][data[2].length - 1].lastIndexOf("<"))) - 1)) {
                                    repeat = true;
                                }
                                if (repeat === false) {
                                    if (baseStart < baseEnd) {
                                        if (options.diff_context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3] > 1)) {
                                            rowItem = a;
                                            data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">- ${baseStart + 1}</li>`);
                                            foldstart = data[0].length - 1;
                                        }
                                        else {
                                            data[0].push(`<li>${baseStart + 1}</li>`);
                                        }
                                        data[1].push("<li class=\"");
                                        if (newStart >= newEnd) {
                                            if (options.diff_space_ignore === true && baseItem.replace(/\s+/g, "") === "") {
                                                data[1].push("equal");
                                                diffline = diffline - 1;
                                            }
                                            else {
                                                data[1].push("delete");
                                            }
                                        }
                                        else if (baseItem === "" && newItem !== "" && (options.diff_space_ignore === false || (baseItem.replace(/\s+/g, "") !== "" && newItem.replace(/\s+/g, "") !== ""))) {
                                            data[1].push("empty");
                                        }
                                        else {
                                            data[1].push(change);
                                        }
                                        data[1].push("\">");
                                        data[1].push(charcompOutput[0]);
                                        data[1].push("&#10;</li>");
                                    }
                                    else if (ctest === true) {
                                        if (options.diff_context < 0 && rowItem < a && (opcodes[a][2] - opcodes[a][1] > 1 || opcodes[a][4] - opcodes[a][3])) {
                                            rowItem = a;
                                            if (foldstart > -1) {
                                                data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount - 1));
                                            }
                                            data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">- &#10;</li>`);
                                            foldstart = data[0].length - 1;
                                        }
                                        else {
                                            data[0].push("<li class=\"empty\">&#10;</li>");
                                        }
                                        data[1].push("<li class=\"empty\"></li>");
                                    }
                                    if (newStart < newEnd) {
                                        data[2].push(`<li>${newStart + 1}</li>`);
                                        data[3].push("<li class=\"");
                                        if (baseStart >= baseEnd) {
                                            if (options.diff_space_ignore === true && newItem.replace(/\s+/g, "") === "") {
                                                data[3].push("equal");
                                                diffline = diffline - 1;
                                            }
                                            else {
                                                data[3].push("insert");
                                            }
                                        }
                                        else if (newItem === "" && baseItem !== "" && (options.diff_space_ignore === false || (baseItem.replace(/\s+/g, "") !== "" && newItem.replace(/\s+/g, "") !== ""))) {
                                            data[3].push("empty");
                                        }
                                        else {
                                            data[3].push(change);
                                        }
                                        data[3].push("\">");
                                        data[3].push(charcompOutput[1]);
                                        data[3].push("&#10;</li>");
                                    }
                                    else if (ctest === true) {
                                        data[2].push("<li class=\"empty\">&#10;</li>");
                                        data[3].push("<li class=\"empty\"></li>");
                                    }
                                }
                                else {
                                    repeat = false;
                                }
                                if (baseStart < baseEnd) {
                                    baseStart = baseStart + 1;
                                }
                                if (newStart < newEnd) {
                                    newStart = newStart + 1;
                                }
                            }
                            else if (btest === true || (typeof baseItem === "string" && typeof newItem !== "string")) {
                                if (baseStart !== -1 && data[0].length > 0 && baseStart !== Number(data[0][data[0].length - 1].slice(data[0][data[0].length - 1].indexOf(">") + 1, data[0][data[0].length - 1].lastIndexOf("<"))) - 1) {
                                    if (options.diff_context < 0 && rowItem < a && opcodes[a][2] - opcodes[a][1] > 1) {
                                        rowItem = a;
                                        data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">- ${baseStart + 1}</li>`);
                                        foldstart = data[0].length - 1;
                                    }
                                    else {
                                        data[0].push(`<li>${baseStart + 1}</li>`);
                                    }
                                    data[1].push("<li class=\"delete\">");
                                    data[1].push(baseItem);
                                    data[1].push("&#10;</li>");
                                    data[2].push("<li class=\"empty\">&#10;</li>");
                                    data[3].push("<li class=\"empty\"></li>");
                                }
                                btest = false;
                                baseStart = baseStart + 1;
                            }
                            else if (ntest === true || (typeof baseItem !== "string" && typeof newItem === "string")) {
                                if (newStart !== -1 && data[2].length > 0 && newStart !== Number(data[2][data[2].length - 1].slice(data[2][data[2].length - 1].indexOf(">") + 1, data[2][data[2].length - 1].lastIndexOf("<"))) - 1) {
                                    if (options.diff_context < 0 && rowItem < a && opcodes[a][4] - opcodes[a][3] > 1) {
                                        rowItem = a;
                                        data[0].push(`<li class="fold" title="folds from line ${foldcount} to line xxx">-</li>`);
                                        foldstart = data[0].length - 1;
                                    }
                                    else {
                                        data[0].push("<li class=\"empty\">&#10;</li>");
                                    }
                                    data[1].push("<li class=\"empty\"></li>");
                                    data[2].push(`<li>${newStart + 1}</li>`);
                                    data[3].push("<li class=\"insert\">");
                                    data[3].push(newItem);
                                    data[3].push("&#10;</li>");
                                }
                                ntest = false;
                                newStart = newStart + 1;
                            }
                        }
                        i = i + 1;
                    } while (i < rowcnt);
                }
                a = a + 1;
            } while (a < opcodesLength);
            if (options.diff_format === "json") {
                return [
                    JSON.stringify({ diff: json })
                        .replace(/\$#gt;/g, "&gt;")
                        .replace(/\$#lt;/g, "&lt;")
                        .replace(/%#lt;/g, "$#lt;")
                        .replace(/%#gt;/g, "$#gt;"),
                    errorout,
                    0
                ];
            }
            if (options.diff_format === "text") {
                if (options.api === "dom") {
                    clidata.push("</li></ol>");
                    return [
                        clidata.join("").replace("</li>", "<ol class=\"diffcli\">"),
                        foldstart,
                        diffline
                    ];
                }
                if (options.crlf === true) {
                    return [clidata.join("\r\n"), foldstart, diffline];
                }
                return [clidata.join("\n"), foldstart, diffline];
            }
            if (foldstart > -1) {
                data[0][foldstart] = data[0][foldstart].replace("xxx", String(foldcount + rcount));
            }
            node.push(data[0].join(""));
            node.push("</ol><ol class=");
            if (options.diff_view === "inline") {
                node.push("\"count\">");
            }
            else {
                node.push("\"data\" data-prettydiff-ignore=\"true\">");
                node.push(data[1].join(""));
                node.push("</ol></div>");
            }
            node.push(data[2].join(""));
            node.push("</ol><ol class=\"data\" data-prettydiff-ignore=\"true\">");
            node.push(data[3].join(""));
            if (options.diff_view === "inline") {
                node.push("</ol>");
            }
            else {
                node.push("</ol></div>");
            }
            node.push("<p class=\"author\">Diff view written by <a href=\"https://prettydiff.com/\">Pr" + "etty Diff</a>.</p></div>");
            if (errorout === 1) {
                diffplural = "";
            }
            if (diffline === 1) {
                linesplural = "";
            }
            finaldoc = `<p><strong>Number of differences:</strong> <em>${errorout + diffline}</em> difference${diffplural} from <em>${diffline}</em> line${linesplural} of code.</p>${node.join("")}`;
            return [
                finaldoc
                    .replace(/li\u0020class="equal"><\/li/g, "li class=\"equal\">&#10;</li")
                    .replace(/\$#gt;/g, "&gt;")
                    .replace(/\$#lt;/g, "&lt;")
                    .replace(/%#lt;/g, "$#lt;")
                    .replace(/%#gt;/g, "$#gt;"),
                errorout,
                diffline
            ];
        }());
    };
    prettydiff.api
        .diffview = diffview;
}());
(function finalFile_init() {
    const finalFile = {
        css: {
            color: {
                canvas: "#prettydiff.canvas{background:#986 url(\"data:image/png;base64,iVBORw0KGgoAAAANS" +
                    "UhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgS" +
                    "UNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG" +
                    "8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeE" +
                    "eCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0k" +
                    "ThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEA" +
                    "Gg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8" +
                    "lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg" +
                    "/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQ" +
                    "LUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0T" +
                    "KUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+A" +
                    "XuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAAR" +
                    "KCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uw" +
                    "lW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIH" +
                    "fI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2" +
                    "o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMW" +
                    "E7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxp" +
                    "FTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlE" +
                    "OU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol" +
                    "9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKC" +
                    "pVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/" +
                    "YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZ" +
                    "j8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx" +
                    "0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p" +
                    "/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJ" +
                    "gYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnut" +
                    "rxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw" +
                    "+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF" +
                    "2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ" +
                    "+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT" +
                    "8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoy" +
                    "OyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85r" +
                    "y1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFp" +
                    "xapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlL" +
                    "OW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQr" +
                    "AVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5s" +
                    "jxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1Y" +
                    "fqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9Wt" +
                    "O319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +
                    "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vd" +
                    "y0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R" +
                    "9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4d" +
                    "PKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b" +
                    "/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DB" +
                    "Y+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv2" +
                    "8bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEFdaVRYd" +
                    "FhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIe" +
                    "nJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrP" +
                    "SJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICAgI" +
                    "CAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZ" +
                    "GYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgI" +
                    "CAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sb" +
                    "nM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zO" +
                    "nN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgI" +
                    "CAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb" +
                    "3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzL" +
                    "zEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b" +
                    "3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmL" +
                    "zEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvI" +
                    "j4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b" +
                    "3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxM" +
                    "joyNDozOC0wNjowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwM" +
                    "TYtMDEtMTNUMTM6MTg6MDctMDY6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9ka" +
                    "WZ5RGF0ZT4yMDE2LTAxLTEzVDEzOjE4OjA3LTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgP" +
                    "HhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5OS1iYjM5NjA0MDVhO" +
                    "WQ8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkO" +
                    "nBob3Rvc2hvcDoxYzM3NjE4MS1mOWU4LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZ" +
                    "W50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZ" +
                    "jA3LTQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgI" +
                    "CAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmO" +
                    "mxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvb" +
                    "j5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEP" +
                    "nhtcC5paWQ6NmIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZ" +
                    "UlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwP" +
                    "C9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQa" +
                    "G90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgI" +
                    "CAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY" +
                    "2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +
                    "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ3L" +
                    "ThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFd" +
                    "nQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgI" +
                    "CAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoK" +
                    "Twvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc" +
                    "3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6b" +
                    "GkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uP" +
                    "mRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y" +
                    "29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3A8L" +
                    "3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8c" +
                    "mRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjd" +
                    "Glvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJR" +
                    "D54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWRmMzVhMTwvc3RFdnQ6aW5zdGFuY" +
                    "2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxMzoxMzoyMy0wNjowM" +
                    "Dwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgU" +
                    "GhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgI" +
                    "CAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvc" +
                    "mRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgI" +
                    "CAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5kZXJpdmVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgI" +
                    "CAgICAgICAgIDxzdEV2dDpwYXJhbWV0ZXJzPmNvbnZlcnRlZCBmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZ" +
                    "G9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nPC9zdEV2dDpwYXJhbWV0ZXJzPgogICAgICAgICAgICAgI" +
                    "CA8L3JkZjpsaT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+C" +
                    "iAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgI" +
                    "CAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDoxZGYzYjhkMy03NzgyLTQ0MGUtYjA5O" +
                    "S1iYjM5NjA0MDVhOWQ8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3a" +
                    "GVuPjIwMTYtMDEtMTNUMTM6MTg6MDctMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgI" +
                    "DxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zd" +
                    "EV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2d" +
                    "DpjaGFuZ2VkPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogI" +
                    "CAgICAgICA8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDx4bXBNTTpEZXJpdmVkRnJvbSByZGY6cGFyc" +
                    "2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgIDxzdFJlZjppbnN0YW5jZUlEPnhtcC5paWQ6ODNhN" +
                    "zkwYWQtYzBlZC00YjNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjppbnN0YW5jZUlEPgogICAgICAgI" +
                    "CAgICA8c3RSZWY6ZG9jdW1lbnRJRD54bXAuZGlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2M" +
                    "WRmMzVhMTwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgICAgPHN0UmVmOm9yaWdpbmFsRG9jdW1lb" +
                    "nRJRD54bXAuZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjBkLTY4MTMxMWQ3NDAzMTwvc3RSZWY6b3JpZ" +
                    "2luYWxEb2N1bWVudElEPgogICAgICAgICA8L3htcE1NOkRlcml2ZWRGcm9tPgogICAgICAgICA8ZGM6Z" +
                    "m9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zP" +
                    "C9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOklDQ1Byb2ZpbGU+c1JHQiBJR" +
                    "UM2MTk2Ni0yLjE8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvb" +
                    "j4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj4zMDAwMDAwLzEwM" +
                    "DAwPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpZUmVzb2x1dGlvbj4zMDAwMDAwLzEwM" +
                    "DAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmO" +
                    "lJlc29sdXRpb25Vbml0PgogICAgICAgICA8ZXhpZjpDb2xvclNwYWNlPjE8L2V4aWY6Q29sb3JTcGFjZ" +
                    "T4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjQ8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogI" +
                    "CAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgI" +
                    "DwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+bleIyQAAA" +
                    "CBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAANElEQVR42mJ89+4uAwMDA" +
                    "wPD6lkTGd69u/vu3d2ZHXnv3t1lgLPevbvLrCTIEJqWD1EJGADaTRll80WcLAAAAABJRU5ErkJggg==" +
                    "\");color:#420}#prettydiff.canvas *:focus{outline:0.1em dashed #f00}#prettydiff." +
                    "canvas a{color:#039}#prettydiff.canvas .contentarea,#prettydiff.canvas .data li," +
                    "#prettydiff.canvas .diff td,#prettydiff.canvas .diff-right,#prettydiff.canvas .r" +
                    "eport td,#prettydiff.canvas fieldset input,#prettydiff.canvas fieldset select,#p" +
                    "rettydiff.canvas legend{background:#eeeee8;border-color:#420}#prettydiff.canvas " +
                    "#report,#prettydiff.canvas #report .author,#prettydiff.canvas .beautify,#prettyd" +
                    "iff.canvas .beautify h3,#prettydiff.canvas .beautify h4,#prettydiff.canvas .diff" +
                    ",#prettydiff.canvas .diff h3,#prettydiff.canvas .diff h4,#prettydiff.canvas .rep" +
                    "ort,#prettydiff.canvas fieldset,#prettydiff.canvas input,#prettydiff.canvas sele" +
                    "ct{background:#ddddd8;border-color:#420}#prettydiff.canvas fieldset fieldset{bac" +
                    "kground:#eeeee8}#prettydiff.canvas fieldset fieldset input,#prettydiff.canvas fi" +
                    "eldset fieldset select{background:#ddddd8}#prettydiff.canvas h2,#prettydiff.canv" +
                    "as h2 button,#prettydiff.canvas h3,#prettydiff.canvas legend{color:#900}#prettyd" +
                    "iff.canvas #addOptions .disabled{background:#ccbbb8;color:#300}#prettydiff.canva" +
                    "s .contentarea{box-shadow:0 1em 1em #b8a899}#prettydiff.canvas .segment{backgrou" +
                    "nd:#fff}#prettydiff.canvas .options li,#prettydiff.canvas .segment,#prettydiff.c" +
                    "anvas h2 button,#prettydiff.canvas ol.segment li,#prettydiff.canvas th{border-co" +
                    "lor:#420}#prettydiff.canvas th{background:#e8ddcc}#prettydiff.canvas li h4{color" +
                    ":#06f}#prettydiff.canvas code{background:#eee;border-color:#eee;color:#00f}#pret" +
                    "tydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff.canvas button{backgrou" +
                    "nd-color:#ddddd8;border-color:#420;box-shadow:0 0.25em 0.5em #b8a899;color:#900}" +
                    "#prettydiff.canvas button:hover{background-color:#ccb;border-color:#630;box-shad" +
                    "ow:0 0.25em 0.5em #b8a899;color:#630}#prettydiff.canvas td.nested{background:#cc" +
                    "ccc8}#prettydiff.canvas th,#prettydiff.canvas th.nested{background:#ddddd8}#pret" +
                    "tydiff.canvas tr:hover{background:#eee8ee}#prettydiff.canvas th.heading,#prettyd" +
                    "iff.canvas thead th,#prettydiff.canvas tr.header th{background:#ddc}#prettydiff." +
                    "canvas .diff h3{background:#ddd;border-color:#999}#prettydiff.canvas .count li,#" +
                    "prettydiff.canvas .data li,#prettydiff.canvas .data li span,#prettydiff.canvas ." +
                    "diff-right,#prettydiff.canvas .segment,#prettydiff.canvas td{border-color:#ccccc" +
                    "8}#prettydiff.canvas .count{background:#eed;border-color:#999}#prettydiff.canvas" +
                    " .count li.fold{color:#900}#prettydiff.canvas h2 button{background:#f8f8f8;box-s" +
                    "hadow:0.1em 0.1em 0.25em #ddd}#prettydiff.canvas li h4,#prettydiff.canvas li h5{" +
                    "color:#06c}#prettydiff.canvas code{background:#eee;border-color:#eee;color:#009}" +
                    "#prettydiff.canvas ol.segment h4 strong{color:#c00}#prettydiff.canvas .data .del" +
                    "ete{background:#ffd8d8}#prettydiff.canvas .data .delete em{background:#fff8f8;bo" +
                    "rder-color:#c44;color:#900}#prettydiff.canvas .data .insert{background:#d8ffd8}#" +
                    "prettydiff.canvas .data .insert em{background:#f8fff8;border-color:#090;color:#3" +
                    "63}#prettydiff.canvas .data .replace{background:#fec}#prettydiff.canvas .data .r" +
                    "eplace em{background:#ffe;border-color:#a86;color:#852}#prettydiff.canvas .data " +
                    ".empty{background:#ddd}#prettydiff.canvas .data em.s0{border-color:#000;color:#0" +
                    "00}#prettydiff.canvas .data em.s1{border-color:#f66;color:#f66}#prettydiff.canva" +
                    "s .data em.s2{border-color:#12f;color:#12f}#prettydiff.canvas .data em.s3{border" +
                    "-color:#090;color:#090}#prettydiff.canvas .data em.s4{border-color:#d6d;color:#d" +
                    "6d}#prettydiff.canvas .data em.s5{border-color:#7cc;color:#7cc}#prettydiff.canva" +
                    "s .data em.s6{border-color:#c85;color:#c85}#prettydiff.canvas .data em.s7{border" +
                    "-color:#737;color:#737}#prettydiff.canvas .data em.s8{border-color:#6d0;color:#6" +
                    "d0}#prettydiff.canvas .data em.s9{border-color:#dd0;color:#dd0}#prettydiff.canva" +
                    "s .data em.s10{border-color:#893;color:#893}#prettydiff.canvas .data em.s11{bord" +
                    "er-color:#b97;color:#b97}#prettydiff.canvas .data em.s12{border-color:#bbb;color" +
                    ":#bbb}#prettydiff.canvas .data em.s13{border-color:#cc3;color:#cc3}#prettydiff.c" +
                    "anvas .data em.s14{border-color:#333;color:#333}#prettydiff.canvas .data em.s15{" +
                    "border-color:#9d9;color:#9d9}#prettydiff.canvas .data em.s16{border-color:#880;c" +
                    "olor:#880}#prettydiff.canvas .data .l0{background:#eeeee8}#prettydiff.canvas .da" +
                    "ta .l1{background:#fed}#prettydiff.canvas .data .l2{background:#def}#prettydiff." +
                    "canvas .data .l3{background:#efe}#prettydiff.canvas .data .l4{background:#fef}#p" +
                    "rettydiff.canvas .data .l5{background:#eef}#prettydiff.canvas .data .l6{backgrou" +
                    "nd:#fff8cc}#prettydiff.canvas .data .l7{background:#ede}#prettydiff.canvas .data" +
                    " .l8{background:#efc}#prettydiff.canvas .data .l9{background:#ffd}#prettydiff.ca" +
                    "nvas .data .l10{background:#edc}#prettydiff.canvas .data .l11{background:#fdb}#p" +
                    "rettydiff.canvas .data .l12{background:#f8f8f8}#prettydiff.canvas .data .l13{bac" +
                    "kground:#ffb}#prettydiff.canvas .data .l14{background:#eec}#prettydiff.canvas .d" +
                    "ata .l15{background:#cfc}#prettydiff.canvas .data .l16{background:#eea}#prettydi" +
                    "ff.canvas .data .c0{background:inherit}#prettydiff.canvas #report p em{color:#06" +
                    "0}#prettydiff.canvas #report p strong{color:#009}#prettydiff.canvas .diffcli h3{" +
                    "color:#009}#prettydiff.canvas .diffcli del{background:#e8dddd;color:#a00}#pretty" +
                    "diff.canvas .diffcli ins{background:#dde8dd;color:#060}#prettydiff.canvas .diffc" +
                    "li p{color:#555}#prettydiff.canvas .diffcli li{border-bottom-color:#aaa}",
                shadow: "#prettydiff.shadow{background:#333 url(\"data:image/png;base64,iVBORw0KGgoAAAANS" +
                    "UhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3AgS" +
                    "UNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG" +
                    "8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeE" +
                    "eCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0k" +
                    "ThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEA" +
                    "Gg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8" +
                    "lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg" +
                    "/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQ" +
                    "LUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0T" +
                    "KUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+A" +
                    "XuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAAR" +
                    "KCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uw" +
                    "lW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIH" +
                    "fI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2" +
                    "o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMW" +
                    "E7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxp" +
                    "FTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlE" +
                    "OU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol" +
                    "9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKC" +
                    "pVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/" +
                    "YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZ" +
                    "j8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx" +
                    "0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p" +
                    "/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJ" +
                    "gYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnut" +
                    "rxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw" +
                    "+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF" +
                    "2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ" +
                    "+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT" +
                    "8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoy" +
                    "OyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85r" +
                    "y1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFp" +
                    "xapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlL" +
                    "OW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQr" +
                    "AVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5s" +
                    "jxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1Y" +
                    "fqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9Wt" +
                    "O319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7Jv" +
                    "ttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vd" +
                    "y0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R" +
                    "9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4d" +
                    "PKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b" +
                    "/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DB" +
                    "Y+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv2" +
                    "8bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAEQFaVRYd" +
                    "FhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIe" +
                    "nJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrP" +
                    "SJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICAgI" +
                    "CAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZ" +
                    "GYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgI" +
                    "CAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1sb" +
                    "nM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zO" +
                    "nN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgI" +
                    "CAgICAgICAgIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb" +
                    "3VyY2VSZWYjIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzL" +
                    "zEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b" +
                    "3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmL" +
                    "zEuMC8iCiAgICAgICAgICAgIHhtbG5zOmV4aWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vZXhpZi8xLjAvI" +
                    "j4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b" +
                    "3NoKTwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNi0wMS0xMlQxM" +
                    "joyNDozOC0wNjowMDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwM" +
                    "TYtMDEtMTNUMTU6MTE6MzMtMDY6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDx4bXA6TW9ka" +
                    "WZ5RGF0ZT4yMDE2LTAxLTEzVDE1OjExOjMzLTA2OjAwPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgICAgP" +
                    "HhtcE1NOkluc3RhbmNlSUQ+eG1wLmlpZDo4MDAwYTE3Zi1jZTY1LTQ5NTUtYjFmMS05YjVkODIwNDIyN" +
                    "jU8L3htcE1NOkluc3RhbmNlSUQ+CiAgICAgICAgIDx4bXBNTTpEb2N1bWVudElEPmFkb2JlOmRvY2lkO" +
                    "nBob3Rvc2hvcDoxZmZhNDk1Yy1mYTU2LTExNzgtOWE5Yy1kODI1ZGZiMGE0NzA8L3htcE1NOkRvY3VtZ" +
                    "W50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo2YjI0ZTI3YS1jZ" +
                    "jA3LTQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgI" +
                    "CAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmO" +
                    "mxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvb" +
                    "j5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEP" +
                    "nhtcC5paWQ6NmIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxMzExZDc0MDMxPC9zdEV2dDppbnN0YW5jZ" +
                    "UlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwP" +
                    "C9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQa" +
                    "G90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgI" +
                    "CAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY" +
                    "2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPnNhdmVkPC9zdEV2dDphY3Rpb24+CiAgI" +
                    "CAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6ZDUzYzc4NDMtYTVmMi00ODQ3L" +
                    "ThjNDMtNmUyYzBhNDY4YmViPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFd" +
                    "nQ6d2hlbj4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgI" +
                    "CAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoK" +
                    "Twvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc" +
                    "3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6b" +
                    "GkgcmRmOnBhcnNlVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uP" +
                    "mRlcml2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y" +
                    "29udmVydGVkIGZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3A8L" +
                    "3N0RXZ0OnBhcmFtZXRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8c" +
                    "mRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjd" +
                    "Glvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJR" +
                    "D54bXAuaWlkOjgzYTc5MGFkLWMwZWQtNGIzYS05ZDJhLWE5YzQ2MWRmMzVhMTwvc3RFdnQ6aW5zdGFuY" +
                    "2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxMzoxMzoyMy0wNjowM" +
                    "Dwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgU" +
                    "GhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgI" +
                    "CAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvc" +
                    "mRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgI" +
                    "CAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc3RFdnQ6YWN0aW9uPgogICAgICAgICAgI" +
                    "CAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjA0ZGYyNDk5LWE1NTktNDE4MC1iNjA1LWI2M" +
                    "Tk3MWMxNWEwMzwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OndoZW4+M" +
                    "jAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc3RFdnQ6d2hlbj4KICAgICAgICAgICAgICAgICAgPHN0R" +
                    "XZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0O" +
                    "nNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoY" +
                    "W5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwY" +
                    "XJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jb252ZXJ0Z" +
                    "WQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+ZnJvbSBhc" +
                    "HBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZzwvc3RFdnQ6cGFyYW1ldGVyc" +
                    "z4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnNlV" +
                    "HlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmRlcml2ZWQ8L3N0R" +
                    "XZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnBhcmFtZXRlcnM+Y29udmVydGVkIGZyb" +
                    "20gYXBwbGljYXRpb24vdm5kLmFkb2JlLnBob3Rvc2hvcCB0byBpbWFnZS9wbmc8L3N0RXZ0OnBhcmFtZ" +
                    "XRlcnM+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwY" +
                    "XJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5zYXZlZDwvc" +
                    "3RFdnQ6YWN0aW9uPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6aW5zdGFuY2VJRD54bXAuaWlkOjgwM" +
                    "DBhMTdmLWNlNjUtNDk1NS1iMWYxLTliNWQ4MjA0MjI2NTwvc3RFdnQ6aW5zdGFuY2VJRD4KICAgICAgI" +
                    "CAgICAgICAgICAgPHN0RXZ0OndoZW4+MjAxNi0wMS0xM1QxNToxMTozMy0wNjowMDwvc3RFdnQ6d2hlb" +
                    "j4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OnNvZnR3YXJlQWdlbnQ+QWRvYmUgUGhvdG9zaG9wIENDI" +
                    "DIwMTQgKE1hY2ludG9zaCk8L3N0RXZ0OnNvZnR3YXJlQWdlbnQ+CiAgICAgICAgICAgICAgICAgIDxzd" +
                    "EV2dDpjaGFuZ2VkPi88L3N0RXZ0OmNoYW5nZWQ+CiAgICAgICAgICAgICAgIDwvcmRmOmxpPgogICAgI" +
                    "CAgICAgICA8L3JkZjpTZXE+CiAgICAgICAgIDwveG1wTU06SGlzdG9yeT4KICAgICAgICAgPHhtcE1NO" +
                    "kRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc" +
                    "3RhbmNlSUQ+eG1wLmlpZDowNGRmMjQ5OS1hNTU5LTQxODAtYjYwNS1iNjE5NzFjMTVhMDM8L3N0UmVmO" +
                    "mluc3RhbmNlSUQ+CiAgICAgICAgICAgIDxzdFJlZjpkb2N1bWVudElEPnhtcC5kaWQ6ODNhNzkwYWQtY" +
                    "zBlZC00YjNhLTlkMmEtYTljNDYxZGYzNWExPC9zdFJlZjpkb2N1bWVudElEPgogICAgICAgICAgICA8c" +
                    "3RSZWY6b3JpZ2luYWxEb2N1bWVudElEPnhtcC5kaWQ6NmIyNGUyN2EtY2YwNy00OWQxLTliMGQtNjgxM" +
                    "zExZDc0MDMxPC9zdFJlZjpvcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDwveG1wTU06RGVyaXZlZ" +
                    "EZyb20+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwa" +
                    "G90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob" +
                    "3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2ZpbGU+CiAgICAgI" +
                    "CAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZ" +
                    "XNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZ" +
                    "XNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOlJlc" +
                    "29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY" +
                    "2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NDwvZXhpZ" +
                    "jpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj40PC9leGlmOlBpe" +
                    "GVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94Onhtc" +
                    "G1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "AogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgC" +
                    "iAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI" +
                    "CAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY" +
                    "2tldCBlbmQ9InciPz5hSvvCAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5Jfx" +
                    "UYAAAAlSURBVHjaPMYxAQAwDAMgVkv1VFFRuy9cvN0F7m66JNNhOvwBAPyqCtNeO5K2AAAAAElFTkSuQ" +
                    "mCC\");color:#fff}#prettydiff.shadow *:focus{outline:0.1em dashed #ff0}#prettydi" +
                    "ff.shadow a:visited{color:#f93}#prettydiff.shadow a{color:#cf3}#prettydiff.shado" +
                    "w .contentarea,#prettydiff.shadow .data li,#prettydiff.shadow .diff td,#prettydi" +
                    "ff.shadow .diff-right,#prettydiff.shadow .report td,#prettydiff.shadow fieldset " +
                    "input,#prettydiff.shadow fieldset select,#prettydiff.shadow legend{background:#3" +
                    "33;border-color:#666}#prettydiff.shadow #report,#prettydiff.shadow #report .auth" +
                    "or,#prettydiff.shadow .beautify,#prettydiff.shadow .beautify h3,#prettydiff.shad" +
                    "ow .beautify h4,#prettydiff.shadow .diff,#prettydiff.shadow .diff h3,#prettydiff" +
                    ".shadow .diff h4,#prettydiff.shadow .report,#prettydiff.shadow fieldset,#prettyd" +
                    "iff.shadow input,#prettydiff.shadow select{background:#222;border-color:#666}#pr" +
                    "ettydiff.shadow fieldset fieldset{background:#333}#prettydiff.shadow .nested td," +
                    "#prettydiff.shadow .segment,#prettydiff.shadow fieldset fieldset input,#prettydi" +
                    "ff.shadow fieldset fieldset select{background:#222}#prettydiff.shadow h2,#pretty" +
                    "diff.shadow h2 button,#prettydiff.shadow h3,#prettydiff.shadow input,#prettydiff" +
                    ".shadow legend,#prettydiff.shadow option,#prettydiff.shadow select{color:#ccc}#p" +
                    "rettydiff.shadow .contentarea{box-shadow:0 1em 1em #000}#prettydiff.shadow .opti" +
                    "ons li,#prettydiff.shadow .segment,#prettydiff.shadow h2 button,#prettydiff.shad" +
                    "ow ol.segment li,#prettydiff.shadow td,#prettydiff.shadow th{border-color:#666}#" +
                    "prettydiff.shadow .count li.fold{color:#cf3}#prettydiff.shadow th{background:#00" +
                    "0}#prettydiff.shadow h2 button{background:#585858;box-shadow:0.1em 0.1em 0.25em " +
                    "#000}#prettydiff.shadow li h4{color:#ff0}#prettydiff.shadow code{background:#585" +
                    "858;border-color:#585858;color:#ccf}#prettydiff.shadow ol.segment h4 strong{colo" +
                    "r:#f30}#prettydiff.shadow button{background-color:#333;border-color:#666;box-sha" +
                    "dow:0 0.25em 0.5em #000;color:#ccc}#prettydiff.shadow button:hover{background-co" +
                    "lor:#777;border-color:#aaa;box-shadow:0 0.25em 0.5em #222;color:#fff}#prettydiff" +
                    ".shadow tr:hover{background:#353}#prettydiff.shadow th,#prettydiff.shadow th.hea" +
                    "ding,#prettydiff.shadow thead th{background:#666;border-color:#999}#prettydiff.s" +
                    "hadow .nested td.nested,#prettydiff.shadow td.nested,#prettydiff.shadow th.neste" +
                    "d{background:#444}#prettydiff.shadow .diff h3{background:#000;border-color:#666}" +
                    "#prettydiff.shadow .beautify li span,#prettydiff.shadow .data li,#prettydiff.sha" +
                    "dow .diff-right,#prettydiff.shadow .segment{border-color:#888}#prettydiff.shadow" +
                    " .count li{border-color:#333}#prettydiff.shadow .count{background:#555;border-co" +
                    "lor:#333}#prettydiff.shadow li h4,#prettydiff.shadow li h5{color:#ff0}#prettydif" +
                    "f.shadow code{background:#000;border-color:#000;color:#ddd}#prettydiff.shadow #a" +
                    "ddOptions .disabled{background:#300;color:#fdd}#prettydiff.shadow ol.segment h4 " +
                    "strong{color:#c00}#prettydiff.shadow .data .delete{background:#300}#prettydiff.s" +
                    "hadow .data .delete em{background:#200;border-color:#c63;color:#c66}#prettydiff." +
                    "shadow .data .insert{background:#030}#prettydiff.shadow .data .insert em{backgro" +
                    "und:#010;border-color:#090;color:#6c0}#prettydiff.shadow .data .replace{backgrou" +
                    "nd:#345}#prettydiff.shadow .data .replace em{background:#023;border-color:#09c;c" +
                    "olor:#7cf}#prettydiff.shadow .data .empty{background:#111}#prettydiff.shadow .di" +
                    "ff .author{border-color:#666}#prettydiff.shadow .data em.s0{border-color:#fff;co" +
                    "lor:#fff}#prettydiff.shadow .data em.s1{border-color:#d60;color:#d60}#prettydiff" +
                    ".shadow .data em.s2{border-color:#aaf;color:#aaf}#prettydiff.shadow .data em.s3{" +
                    "border-color:#0c0;color:#0c0}#prettydiff.shadow .data em.s4{border-color:#f6f;co" +
                    "lor:#f6f}#prettydiff.shadow .data em.s5{border-color:#0cc;color:#0cc}#prettydiff" +
                    ".shadow .data em.s6{border-color:#dc3;color:#dc3}#prettydiff.shadow .data em.s7{" +
                    "border-color:#a7a;color:#a7a}#prettydiff.shadow .data em.s8{border-color:#7a7;co" +
                    "lor:#7a7}#prettydiff.shadow .data em.s9{border-color:#ff6;color:#ff6}#prettydiff" +
                    ".shadow .data em.s10{border-color:#33f;color:#33f}#prettydiff.shadow .data em.s1" +
                    "1{border-color:#933;color:#933}#prettydiff.shadow .data em.s12{border-color:#990" +
                    ";color:#990}#prettydiff.shadow .data em.s13{border-color:#987;color:#987}#pretty" +
                    "diff.shadow .data em.s14{border-color:#fc3;color:#fc3}#prettydiff.shadow .data e" +
                    "m.s15{border-color:#897;color:#897}#prettydiff.shadow .data em.s16{border-color:" +
                    "#f30;color:#f30}#prettydiff.shadow .data .l0{background:#333}#prettydiff.shadow " +
                    ".data .l1{background:#633}#prettydiff.shadow .data .l2{background:#335}#prettydi" +
                    "ff.shadow .data .l3{background:#353}#prettydiff.shadow .data .l4{background:#636" +
                    "}#prettydiff.shadow .data .l5{background:#366}#prettydiff.shadow .data .l6{backg" +
                    "round:#640}#prettydiff.shadow .data .l7{background:#303}#prettydiff.shadow .data" +
                    " .l8{background:#030}#prettydiff.shadow .data .l9{background:#660}#prettydiff.sh" +
                    "adow .data .l10{background:#003}#prettydiff.shadow .data .l11{background:#300}#p" +
                    "rettydiff.shadow .data .l12{background:#553}#prettydiff.shadow .data .l13{backgr" +
                    "ound:#432}#prettydiff.shadow .data .l14{background:#640}#prettydiff.shadow .data" +
                    " .l15{background:#562}#prettydiff.shadow .data .l16{background:#600}#prettydiff." +
                    "shadow .data .c0{background:inherit}#prettydiff.shadow .diffcli h3{color:#9cf}#p" +
                    "rettydiff.shadow .diffcli del{background:#382222;color:#f63}#prettydiff.shadow ." +
                    "diffcli ins{background:#223822;color:#cf3}#prettydiff.shadow .diffcli p{color:#a" +
                    "aa}#prettydiff.shadow .diffcli li{border-bottom-color:#666}",
                white: "#prettydiff.white{background:#f8f8f8 url(\"data:image/png;base64,iVBORw0KGgoAAAA" +
                    "NSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKT2lDQ1BQaG90b3Nob3A" +
                    "gSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUU" +
                    "EG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUI" +
                    "eEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB" +
                    "0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYh" +
                    "EAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABR" +
                    "G8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRH" +
                    "gg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrI" +
                    "PQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz" +
                    "0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo" +
                    "+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAA" +
                    "ARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4" +
                    "uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFV" +
                    "IHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2g" +
                    "P2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFh" +
                    "MWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkm" +
                    "xpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShn" +
                    "lEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5" +
                    "Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZH" +
                    "KCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5" +
                    "Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvO" +
                    "UZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5" +
                    "Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W3" +
                    "6p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423Gbca" +
                    "jJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRapln" +
                    "utrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8W" +
                    "uw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00d" +
                    "nF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MP" +
                    "IQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLf" +
                    "LT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSF" +
                    "oyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU8" +
                    "5ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvS" +
                    "FpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTO" +
                    "lLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7O" +
                    "QrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo" +
                    "5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+" +
                    "1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9" +
                    "WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7" +
                    "JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3" +
                    "vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr" +
                    "8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK" +
                    "4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN" +
                    "6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9" +
                    "DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xm" +
                    "v28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAADo2aVR" +
                    "YdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGl" +
                    "IenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHR" +
                    "rPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzAxNCA3OS4xNTY3OTcsIDIwMTQvMDgvMjAtMDk6NTM6MDIgICA" +
                    "gICAgICI+CiAgIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1" +
                    "yZGYtc3ludGF4LW5zIyI+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICA" +
                    "gICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgICAgICAgICAgeG1" +
                    "sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5" +
                    "zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiA" +
                    "gICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgICA" +
                    "gICAgICAgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIgo" +
                    "gICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICA" +
                    "gICAgICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iPgogICAgICAgICA" +
                    "8eG1wOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC94bXA6Q3J" +
                    "lYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDE2LTAxLTEyVDEyOjI0OjM4LTA2OjA" +
                    "wPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNZXRhZGF0YURhdGU+MjAxNi0wMS0xMlQxMjo" +
                    "yNDozOC0wNjowMDwveG1wOk1ldGFkYXRhRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTY" +
                    "tMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGF" +
                    "uY2VJRD54bXAuaWlkOmQ1M2M3ODQzLWE1ZjItNDg0Ny04YzQzLTZlMmMwYTQ2OGJlYjwveG1wTU06SW5" +
                    "zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+YWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjF" +
                    "jMzc2MTgxLWY5ZTgtMTE3OC05YTljLWQ4MjVkZmIwYTQ3MDwveG1wTU06RG9jdW1lbnRJRD4KICAgICA" +
                    "gICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjZiMjRlMjdhLWNmMDctNDlkMS05YjB" +
                    "kLTY4MTMxMWQ3NDAzMTwveG1wTU06T3JpZ2luYWxEb2N1bWVudElEPgogICAgICAgICA8eG1wTU06SGl" +
                    "zdG9yeT4KICAgICAgICAgICAgPHJkZjpTZXE+CiAgICAgICAgICAgICAgIDxyZGY6bGkgcmRmOnBhcnN" +
                    "lVHlwZT0iUmVzb3VyY2UiPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6YWN0aW9uPmNyZWF0ZWQ8L3N" +
                    "0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDo2YjI" +
                    "0ZTI3YS1jZjA3LTQ5ZDEtOWIwZC02ODEzMTFkNzQwMzE8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICA" +
                    "gICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTYtMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4" +
                    "+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyA" +
                    "yMDE0IChNYWNpbnRvc2gpPC9zdEV2dDpzb2Z0d2FyZUFnZW50PgogICAgICAgICAgICAgICA8L3JkZjp" +
                    "saT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICA" +
                    "gICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICA" +
                    "gICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDpkNTNjNzg0My1hNWYyLTQ4NDctOGM0My02ZTJjMGE" +
                    "0NjhiZWI8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMTY" +
                    "tMDEtMTJUMTI6MjQ6MzgtMDY6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp" +
                    "zb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE0IChNYWNpbnRvc2gpPC9zdEV2dDpzb2Z" +
                    "0d2FyZUFnZW50PgogICAgICAgICAgICAgICAgICA8c3RFdnQ6Y2hhbmdlZD4vPC9zdEV2dDpjaGFuZ2V" +
                    "kPgogICAgICAgICAgICAgICA8L3JkZjpsaT4KICAgICAgICAgICAgPC9yZGY6U2VxPgogICAgICAgICA" +
                    "8L3htcE1NOkhpc3Rvcnk+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiA" +
                    "gICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjM8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICA" +
                    "gIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5zUkdCIElFQzYxOTY2LTIuMTwvcGhvdG9zaG9wOklDQ1Byb2Z" +
                    "pbGU+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICA" +
                    "gIDx0aWZmOlhSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICA" +
                    "gIDx0aWZmOllSZXNvbHV0aW9uPjMwMDAwMDAvMTAwMDA8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICA" +
                    "gIDx0aWZmOlJlc29sdXRpb25Vbml0PjI8L3RpZmY6UmVzb2x1dGlvblVuaXQ+CiAgICAgICAgIDxleGl" +
                    "mOkNvbG9yU3BhY2U+MTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnN" +
                    "pb24+NDwvZXhpZjpQaXhlbFhEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOlBpeGVsWURpbWVuc2lvbj4" +
                    "0PC9leGlmOlBpeGVsWURpbWVuc2lvbj4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJ" +
                    "ERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICA" +
                    "gICAgCjw/eHBhY2tldCBlbmQ9InciPz5cKgaXAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mA" +
                    "AADqYAAAXb5JfxUYAAAAkSURBVHjaPMahAQAwDMCg7P+/KnsPcq4oHqpqdwNmBt3QDX8AeAUmcrZLnM4" +
                    "AAAAASUVORK5CYII=\");}#prettydiff.white *:focus{outline:0.1em dashed #06f}#prett" +
                    "ydiff.white .contentarea,#prettydiff.white .data li,#prettydiff.white .diff td,#" +
                    "prettydiff.white .diff-right,#prettydiff.white .report td,#prettydiff.white fiel" +
                    "dset input,#prettydiff.white fieldset select,#prettydiff.white legend{background" +
                    ":#fff;border-color:#999}#prettydiff.white #pdsamples li div,#prettydiff.white #r" +
                    "eport,#prettydiff.white #report .author,#prettydiff.white .author,#prettydiff.wh" +
                    "ite .beautify,#prettydiff.white .beautify h3,#prettydiff.white .beautify h4,#pre" +
                    "ttydiff.white .diff,#prettydiff.white .diff h3,#prettydiff.white .diff h4,#prett" +
                    "ydiff.white .report,#prettydiff.white fieldset,#prettydiff.white input,#prettydi" +
                    "ff.white select{background:#eee;border-color:#999}#prettydiff.white .diff h3{bac" +
                    "kground:#ddd;border-color:#999}#prettydiff.white fieldset fieldset,#prettydiff.w" +
                    "hite th.nested{background:#ddd}#prettydiff.white .contentarea{box-shadow:0 1em 1" +
                    "em #999}#prettydiff.white button{background-color:#eee;border-color:#999;box-sha" +
                    "dow:0 0.25em 0.5em #ccc;color:#666}#prettydiff.white button:hover{background-col" +
                    "or:#def;border-color:#03c;box-shadow:0 0.25em 0.5em #ccf;color:#03c}#prettydiff." +
                    "white h2,#prettydiff.white h2 button,#prettydiff.white h3{color:#b00}#prettydiff" +
                    ".white th{background:#eee;color:#333}#prettydiff.white tr:hover{background:#efe}" +
                    "#prettydiff.white thead th,#prettydiff.white tr.header th{background:#eef}#prett" +
                    "ydiff.white .report strong{color:#009}#prettydiff.white .report em{color:#080}#p" +
                    "rettydiff.white .count li,#prettydiff.white .data li,#prettydiff.white .data li " +
                    "span,#prettydiff.white .diff-right,#prettydiff.white .options li,#prettydiff.whi" +
                    "te .segment,#prettydiff.white h2 button,#prettydiff.white ol.segment li,#prettyd" +
                    "iff.white td{border-color:#ccc}#prettydiff.white tbody th{border-color:#999}#pre" +
                    "ttydiff.white td.nested{background:#d8d8d8}#prettydiff.white th.nested{backgroun" +
                    "d:#eee}#prettydiff.white .count li.fold{color:#900}#prettydiff.white .count{back" +
                    "ground:#eed;border-color:#999}#prettydiff.white #addOptions .disabled{background" +
                    ":#fee;color:#300}#prettydiff.white h2 button{background:#f8f8f8;box-shadow:0.1em" +
                    " 0.1em 0.25em #ddd}#prettydiff.white li h4,#prettydiff.white li h5{color:#33c}#p" +
                    "rettydiff.white code{background:#eee;border-color:#eee;color:#009}#prettydiff.wh" +
                    "ite ol.segment h4 strong{color:#c00}#prettydiff.white .data .delete{background:#" +
                    "ffd8d8}#prettydiff.white .data .delete em{background:#fff8f8;border-color:#c44;c" +
                    "olor:#900}#prettydiff.white .data .insert{background:#d8ffd8}#prettydiff.white ." +
                    "data .insert em{background:#f8fff8;border-color:#090;color:#363}#prettydiff.whit" +
                    "e .data .replace{background:#fec}#prettydiff.white .data .replace em{background:" +
                    "#ffe;border-color:#a86;color:#852}#prettydiff.white .data .empty{background:#ddd" +
                    "}#prettydiff.white .data em.s0{border-color:#000;color:#000}#prettydiff.white .d" +
                    "ata em.s1{border-color:#f66;color:#f66}#prettydiff.white .data em.s2{border-colo" +
                    "r:#12f;color:#12f}#prettydiff.white .data em.s3{border-color:#090;color:#090}#pr" +
                    "ettydiff.white .data em.s4{border-color:#d6d;color:#d6d}#prettydiff.white .data " +
                    "em.s5{border-color:#7cc;color:#7cc}#prettydiff.white .data em.s6{border-color:#c" +
                    "85;color:#c85}#prettydiff.white .data em.s7{border-color:#737;color:#737}#pretty" +
                    "diff.white .data em.s8{border-color:#6d0;color:#6d0}#prettydiff.white .data em.s" +
                    "9{border-color:#dd0;color:#dd0}#prettydiff.white .data em.s10{border-color:#893;" +
                    "color:#893}#prettydiff.white .data em.s11{border-color:#b97;color:#b97}#prettydi" +
                    "ff.white .data em.s12{border-color:#bbb;color:#bbb}#prettydiff.white .data em.s1" +
                    "3{border-color:#cc3;color:#cc3}#prettydiff.white .data em.s14{border-color:#333;" +
                    "color:#333}#prettydiff.white .data em.s15{border-color:#9d9;color:#9d9}#prettydi" +
                    "ff.white .data em.s16{border-color:#880;color:#880}#prettydiff.white .data .l0{b" +
                    "ackground:#fff}#prettydiff.white .data .l1{background:#fed}#prettydiff.white .da" +
                    "ta .l2{background:#def}#prettydiff.white .data .l3{background:#efe}#prettydiff.w" +
                    "hite .data .l4{background:#fef}#prettydiff.white .data .l5{background:#eef}#pret" +
                    "tydiff.white .data .l6{background:#fff8cc}#prettydiff.white .data .l7{background" +
                    ":#ede}#prettydiff.white .data .l8{background:#efc}#prettydiff.white .data .l9{ba" +
                    "ckground:#ffd}#prettydiff.white .data .l10{background:#edc}#prettydiff.white .da" +
                    "ta .l11{background:#fdb}#prettydiff.white .data .l12{background:#f8f8f8}#prettyd" +
                    "iff.white .data .l13{background:#ffb}#prettydiff.white .data .l14{background:#ee" +
                    "c}#prettydiff.white .data .l15{background:#cfc}#prettydiff.white .data .l16{back" +
                    "ground:#eea}#prettydiff.white .data .c0{background:inherit}#prettydiff.white #re" +
                    "port p em{color:#080}#prettydiff.white #report p strong{color:#009}#prettydiff.w" +
                    "hite .diffcli h3{color:#009}#prettydiff.white .diffcli del{background:#f8eeee;co" +
                    "lor:#c00}#prettydiff.white .diffcli ins{background:#eef8ee;color:#070}#prettydif" +
                    "f.white .diffcli p{color:#666}#prettydiff.white .diffcli li{border-bottom-color:" +
                    "#ccc}"
            },
            global: "#prettydiff{text-align:center;font-size:10px;overflow-y:scroll}#prettydiff .cont" +
                "entarea{border-style:solid;border-width:0.1em;font-family:\"Century Gothic\",\"T" +
                "rebuchet MS\";margin:0 auto;max-width:93em;padding:1em;text-align:left}#prettydi" +
                "ff dd,#prettydiff dt,#prettydiff p,#prettydiff li,#prettydiff td,#prettydiff blo" +
                "ckquote,#prettydiff th{clear:both;font-family:\"Palatino Linotype\",\"Book Antiq" +
                "ua\",Palatino,serif;font-size:1.6em;line-height:1.6em;text-align:left}#prettydif" +
                "f blockquote{font-style:italic}#prettydiff dt{font-size:1.4em;font-weight:bold;l" +
                "ine-height:inherit}#prettydiff li li,#prettydiff li p{font-size:1em}#prettydiff " +
                "th,#prettydiff td{border-style:solid;border-width:0.1em;padding:0.1em 0.2em}#pre" +
                "ttydiff td span{display:block}#prettydiff code,#prettydiff textarea{font-family:" +
                "\"Courier New\",Courier,\"Lucida Console\",monospace}#prettydiff code,#prettydif" +
                "f textarea{display:block;font-size:0.8em;width:100%}#prettydiff code span{displa" +
                "y:block;white-space:pre}#prettydiff code{border-style:solid;border-width:0.2em;l" +
                "ine-height:1em}#prettydiff textarea{line-height:1.4em}#prettydiff label{display:" +
                "inline;font-size:1.4em}#prettydiff legend{border-radius:1em;border-style:solid;b" +
                "order-width:0.1em;font-size:1.4em;font-weight:bold;margin-left:-0.25em;padding:0" +
                " 0.5em}#prettydiff fieldset fieldset legend{font-size:1.2em}#prettydiff table{bo" +
                "rder-collapse:collapse}#prettydiff div.report{border-style:none}#prettydiff h2,#" +
                "prettydiff h3,#prettydiff h4{clear:both}#prettydiff table{margin:0 0 1em}#pretty" +
                "diff .analysis .bad,#prettydiff .analysis .good{font-weight:bold}#prettydiff h1{" +
                "font-size:3em;font-weight:normal;margin-top:0}#prettydiff h1 span{font-size:0.5e" +
                "m}#prettydiff h1 svg{border-style:solid;border-width:0.05em;float:left;height:1." +
                "5em;margin-right:0.5em;width:1.5em}#prettydiff h2{border-style:none;background:t" +
                "ransparent;font-size:1em;box-shadow:none;margin:0}#prettydiff h2 button{backgrou" +
                "nd:transparent;border-style:solid;cursor:pointer;display:block;font-size:2.5em;f" +
                "ont-weight:normal;text-align:left;width:100%;border-width:0.05em;font-weight:nor" +
                "mal;margin:1em 0 0;padding:0.1em}#prettydiff h2 span{display:block;float:right;f" +
                "ont-size:0.5em}#prettydiff h3{font-size:2em;margin:0;background:transparent;box-" +
                "shadow:none;border-style:none}#prettydiff h4{font-size:1.6em;font-family:\"Centu" +
                "ry Gothic\",\"Trebuchet MS\";margin:0}#prettydiff li h4{font-size:1em}#prettydif" +
                "f button,#prettydiff fieldset,#prettydiff div input,#prettydiff textarea{border-" +
                "style:solid;border-width:0.1em}#prettydiff section{border-style:none}#prettydiff" +
                " h2 button,#prettydiff select,#prettydiff option{font-family:inherit}#prettydiff" +
                " select{border-style:inset;border-width:0.1em;width:13.5em}#prettydiff #dcolorSc" +
                "heme{float:right;margin:-3em 0 0}#prettydiff #dcolorScheme label,#prettydiff #dc" +
                "olorScheme label{display:inline-block;font-size:1em}#prettydiff .clear{clear:bot" +
                "h;display:block}#prettydiff caption,#prettydiff .content-hide{height:1em;left:-1" +
                "000em;overflow:hidden;position:absolute;top:-1000em;width:1em}",
            reports: "#prettydiff #report.contentarea{font-family:\"Lucida Sans Unicode\",\"Helvetica" +
                "\",\"Arial\",sans-serif;max-width:none;overflow:scroll}#prettydiff .diff .delete" +
                " em,#prettydiff .diff .insert em,#prettydiff .diff .replace em{border-style:soli" +
                "d;border-width:0.1em}#prettydiff #report blockquote,#prettydiff #report dd,#pret" +
                "tydiff #report dt,#prettydiff #report li,#prettydiff #report p,#prettydiff #repo" +
                "rt td,#prettydiff #report th{font-family:\"Lucida Sans Unicode\",\"Helvetica\"," +
                "\"Arial\",sans-serif;font-size:1.2em}#prettydiff div#webtool{background:transpar" +
                "ent;font-size:inherit;margin:0;padding:0}#prettydiff #jserror span{display:block" +
                "}#prettydiff #a11y{background:transparent;clear:both;padding:0}#prettydiff #a11y" +
                " div{margin:0.5em 0;border-style:solid;border-width:0.1em}#prettydiff #a11y h4{m" +
                "argin:0.25em 0}#prettydiff #a11y ol{border-style:solid;border-width:0.1em}#prett" +
                "ydiff #cssreport.doc table{clear:none;float:left;margin-left:1em}#prettydiff #cs" +
                "s-size{left:24em}#prettydiff #css-uri{left:40em}#prettydiff #css-uri td{text-ali" +
                "gn:left}#prettydiff .report .analysis th{text-align:left}#prettydiff table.code " +
                "td,#prettydiff table.code th{font-size:0.9em}#prettydiff .report .analysis .pars" +
                "eData td,#prettydiff table.code td,#prettydiff table.code th{font-family:'Courie" +
                "r New',Courier,'Lucida Console',monospace;text-align:left;white-space:pre}#prett" +
                "ydiff .report .analysis td{text-align:right}#prettydiff .analysis{float:left;mar" +
                "gin:0 1em 1em 0}#prettydiff .analysis td,#prettydiff .analysis th{padding:0.5em}" +
                "#prettydiff .diffcli{font-size:Courier,'Courier New','Lucida Console',monospace;" +
                "margin:0;padding:0;text-align:left;white-space:pre;}#prettydiff .diffcli li{bord" +
                "er-bottom-style:solid;border-bottom-width:0.1em;list-style:none;padding-bottom:1" +
                "em}#prettydiff #webtool .diffcli h3{font-size:1.4em;font-weight:normal;margin-to" +
                "p:2em}#prettydiff #webtool .diffcli p,#prettydiff .diffcli del,#prettydiff .diff" +
                "cli ins{display:block;font-family:Courier,'Courier New','Lucida Console',monospa" +
                "ce;font-size:1.2em;font-style:normal;margin:0;text-decoration:none}#prettydiff ." +
                "diffcli em{color:inherit;font-style:normal;font-weight:bold}#prettydiff .diffcli" +
                " del em,#prettydiff .diffcli ins em{text-decoration:underline}#prettydiff #statr" +
                "eport div{border-style:none}#prettydiff .beautify,#prettydiff .diff{border-style" +
                ":solid;border-width:0.1em;display:inline-block;margin:0 1em 1em 0;position:relat" +
                "ive}#prettydiff .beautify,#prettydiff .beautify h3,#prettydiff .beautify h4,#pre" +
                "ttydiff .beautify li,#prettydiff .diff,#prettydiff .diff h4,#prettydiff .diff li" +
                " #prettydiff .diff h3{font-family:'Courier New',Courier,'Lucida Console',monospa" +
                "ce}#prettydiff .beautify h3,#prettydiff .beautify h4,#prettydiff .beautify li,#p" +
                "rettydiff .diff h3,#prettydiff .diff h4,#prettydiff .diff li{border-style:none n" +
                "one solid none;border-width:0 0 0.1em 0;box-shadow:none;display:block;font-size:" +
                "1.2em;margin:0 0 0 -.1em;padding:0.2em 2em;text-align:left}#prettydiff .diff .sk" +
                "ip{border-style:none none solid;border-width:0 0 0.1em}#prettydiff .diff .diff-l" +
                "eft{border-style:none;display:table-cell}#prettydiff .diff .diff-right{border-st" +
                "yle:none none none solid;border-width:0 0 0 0.1em;display:table-cell;margin-left" +
                ":-.1em;min-width:16.5em;right:0;top:0}#prettydiff .diff-right .data{width:100%}#" +
                "prettydiff .beautify .data li,#prettydiff .diff .data li{min-width:16.5em;paddin" +
                "g:0.5em}#prettydiff .beautify h3,#prettydiff .beautify li,#prettydiff .beautify " +
                "p,#prettydiff .diff h3,#prettydiff .diff li,#prettydiff .diff p{font-size:1.2em}" +
                "#prettydiff .beautify li em,#prettydiff .diff li em{font-style:normal;font-weigh" +
                "t:bold;margin:-0.5em -0.09em}#prettydiff .diff p.author{border-style:solid;borde" +
                "r-width:0.2em 0.1em 0.1em;margin:0;overflow:hidden;padding:0.4em;text-align:righ" +
                "t}#prettydiff .difflabel{display:block;height:0}#prettydiff .count{border-style:" +
                "solid;border-width:0 0.1em 0 0;font-weight:normal;padding:0;text-align:right}#pr" +
                "ettydiff .count li{padding:0.5em 1em;text-align:right}#prettydiff .count li.fold" +
                "{cursor:pointer;font-weight:bold;padding-left:0.5em}#prettydiff .data{text-align" +
                ":left;white-space:pre}#prettydiff .beautify .data span{display:inline-block;font" +
                "-style:normal;font-weight:bold}#prettydiff .beautify li,#prettydiff .diff li{bor" +
                "der-style:none none solid;border-width:0 0 0.1em;display:block;height:1em;line-h" +
                "eight:1.2;list-style-type:none;margin:0;white-space:pre}#prettydiff .beautify ol" +
                ",#prettydiff .diff ol{display:table-cell;margin:0;padding:0}#prettydiff .beautif" +
                "y li em{border-style:none none solid;border-width:0 0 0.1em;padding:0 0 0.2em;po" +
                "sition:relative;z-index:5}#prettydiff .beautify li .line{border-style:none}#pret" +
                "tydiff .beautify li span{border-style:none none solid;border-width:0 0 0.1em;hei" +
                "ght:2em;margin:0 0 -1em;position:relative;top:-0.5em}#prettydiff .beautify span." +
                "l0{margin-left:-0.5em;padding-left:0.5em}#prettydiff #webtool table table{margin" +
                ":0 -0.1em -0.1em;width:100%}#prettydiff #webtool table table td,#prettydiff #web" +
                "tool table table th{font-size:1em}#prettydiff #webtool table td.nested{padding:0" +
                ".5em}#prettydiff #report .beautify,#prettydiff #report .beautify li,#prettydiff " +
                "#report .diff,#prettydiff #report .diff li{font-family:\"Courier New\",Courier," +
                "\"Lucida Console\",monospace}#prettydiff #report .beautify{border-style:solid}#p" +
                "rettydiff #report .beautify h3,#prettydiff #report .diff h3{border-top-style:sol" +
                "id;border-top-width:0.1em;margin:0}#prettydiff #webtool #a11y,#prettydiff #webto" +
                "ol #a11y div,#prettydiff #webtool #a11y ol,#prettydiff #webtool #a11y ul{border-" +
                "style:none}"
        },
        html: {
            body: "/\u002a]]>\u002a/</style></head><body id=\"prettydiff\" class=\"",
            color: "white",
            htmlEnd: "</script></body></html>",
            head: "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><!DOCTYPE html PUBLIC \"-//W3C//DTD X" +
                "HTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"><html xmlns=\"ht" +
                "tp://www.w3.org/1999/xhtml\" xml:lang=\"en\"><head><title>Pretty Diff - The diff" +
                "erence tool</title><meta name=\"robots\" content=\"index, follow\"/> <meta name=" +
                "\"DC.title\" content=\"Pretty Diff - The difference tool\"/> <link rel=\"canonic" +
                "al\" href=\"https://prettydiff.com/\" type=\"application/xhtml+xml\"/><meta http-" +
                "equiv=\"Content-Type\" content=\"application/xhtml+xml;charset=UTF-8\"/><meta ht" +
                "tp-equiv=\"Content-Style-Type\" content=\"text/css\"/><style type=\"text/css\">/" +
                "\u002a<![CDATA[\u002a/",
            intro: "\"><div class=\"contentarea\" id=\"report\"><section role=\"heading\"><h1><svg h" +
                "eight=\"2000.000000pt\" id=\"pdlogo\" preserveAspectRatio=\"xMidYMid meet\" vers" +
                "ion=\"1.0\" viewBox=\"0 0 2000.000000 2000.000000\" width=\"2000.000000pt\" xmln" +
                "s=\"http://www.w3.org/2000/svg\"><g fill=\"#999\" stroke=\"none\" transform=\"tr" +
                "anslate(0.000000,2000.000000) scale(0.100000,-0.100000)\"> <path d=\"M14871 1852" +
                "3 c-16 -64 -611 -2317 -946 -3588 -175 -660 -319 -1202 -320 -1204 -2 -2 -50 39 -1" +
                "07 91 -961 876 -2202 1358 -3498 1358 -1255 0 -2456 -451 -3409 -1279 -161 -140 -4" +
                "24 -408 -560 -571 -507 -607 -870 -1320 -1062 -2090 -58 -232 -386 -1479 -2309 -87" +
                "59 -148 -563 -270 -1028 -270 -1033 0 -4 614 -8 1365 -8 l1364 0 10 38 c16 63 611 " +
                "2316 946 3587 175 660 319 1202 320 1204 2 2 50 -39 107 -91 543 -495 1169 -862 18" +
                "63 -1093 1707 -568 3581 -211 4965 946 252 210 554 524 767 796 111 143 312 445 40" +
                "8 613 229 406 408 854 525 1320 57 225 380 1451 2310 8759 148 563 270 1028 270 10" +
                "33 0 4 -614 8 -1365 8 l-1364 0 -10 -37z m-4498 -5957 c477 -77 889 -256 1245 -542" +
                " 523 -419 850 -998 954 -1689 18 -121 18 -549 0 -670 -80 -529 -279 -972 -612 -135" +
                "9 -412 -480 -967 -779 -1625 -878 -121 -18 -549 -18 -670 0 -494 74 -918 255 -1283" +
                " 548 -523 419 -850 998 -954 1689 -18 121 -18 549 0 670 104 691 431 1270 954 1689" +
                " 365 293 828 490 1283 545 50 6 104 13 120 15 72 10 495 -3 588 -18z\"/></g></svg>" +
                "<a href=\"prettydiff.com.xhtml\">Pretty Diff</a></h1><p id=\"dcolorScheme\"><lab" +
                "el class=\"label\" for=\"colorScheme\">Color Scheme</label><select id=\"colorSch" +
                "eme\"><option>Canvas</option><option>Shadow</option><option selected=\"selected" +
                "\">White</option></select></p><p>Find <a href=\"https://github.com/prettydiff/pr" +
                "ettydiff\">Pretty Diff on GitHub</a>.</p></section><section role=\"main\" class=" +
                "\"report\">",
            scriptEnd: "//]]>",
            scriptStart: "</section></div><script type=\"application/javascript\">//<![CDATA["
        },
        order: [],
        script: {
            beautify: "(function doc(){\"use strict\";let inca=0,incb=0,ol,li,lilen=0;const div=documen" +
                "t.getElementsByTagName(\"div\"),len=div.length,body=document.getElementsByTagNam" +
                "e(\"body\")[0],color=document.getElementById(\"colorScheme\"),change=function do" +
                "c_colorChange(){const name=color[color.selectedIndex].innerHTML.toLowerCase();bo" +
                "dy.setAttribute(\"class\",name" + ")},beaufold=function doc_beaufold(event){let a=0,b=\"\";const el=event.srcElemen" +
                "t||event.target,title=el.getAttribute(\"title\").split(\"line \"),parent=[el.par" +
                "entNode,el.parentNode.nextSibling],min=Number(title[1].substr(0,title[1].indexOf" +
                "(\" \"))),max=Number(title[2]),list=[parent[0].getElementsByTagName(\"li\"),pare" +
                "nt[1].getElementsByTagName(\"li\")];a=min;if(el.innerHTML.charAt(0)===\"-\"){do{" +
                "list[0][a].style.display=\"none\";list[1][a].style.display=\"none\";a=a+1}while(" +
                "a<max);el.innerHTML=\"+\"+el.innerHTML.substr(1)}else{do{list[0][a].style.displa" +
                "y" + "=\"block\";list[1][a].style.display=\"block\";if(list[0][a].getAttribute(\"class" +
                "\")===\"fold\"&&list[0][a].innerHTML.charAt(0)===\"+\"){b=list[0][a].getAttribut" +
                "e(\"title\");b=b.substring(b.indexOf(\"to line \")+1);a=Number(b)-1}a=a+1}while(" +
                "a<max);el.innerHTML=\"-\"+el.innerHTML.substr(1)}};inca=0;do{if(div[inca].getAtt" +
                "r" + "ibute(\"class\")===\"beautify\"){ol=div[inca].getElementsByTagName(\"ol\");if(ol" +
                "[0].getAttribute(\"class\")===\"count\"){li=ol[0].getElementsByTagName(\"li\");l" +
                "ilen=li.length;incb=0;do{if(li[incb].getAttribute(\"class\")===\"fold\"){li[incb" +
                "].onclick=beaufold}incb=incb+1}while(incb<lilen)}}inca=inca+1}while(inca<len);co" +
                "lo" + "r.onchange=change}());",
            diff: "(function doc(){\"use strict\";let diffList=[];const body=document.getElementsBy" +
                "TagName(\"body\")[0],color=document.getElementById(\"colorScheme\"),change=funct" +
                "ion doc_colorChange(){const name=color[color.selectedIndex].innerHTML.toLowerCas" +
                "e();body.setAttribute(\"class\",name)},colSliderGrab=function doc_colSliderGrab(" +
                "event){let subOffset=0,withinRange=false,offset=0,status=\"ew\",diffLeft,node=ev" +
                "ent.srcElement||event.target;const touch=(event!==null&&event.type===\"touchstar" +
                "t\"),diffRight=(function doc_colSliderGrab_nodeFix(){if(node.nodeName===\"li\"){" +
                "node=node.parentNode}return node.parentNode}()),diff=diffRight.parentNode,lists=" +
                "diff.getElementsByTagName(\"ol\"),par1=lists[2].parentNode,par2=lists[2].parentN" +
                "ode.parentNode,counter=lists[0].clientWidth,data=lists[1].clientWidth,width=par1" +
                ".clientWidth,total=par2.clientWidth,min=((total-counter-data-2)-width),max=(tota" +
                "l-width-counter),minAdjust=min+15,maxAdjust=max-20;diffLeft=diffRight.previousSi" +
                "bling;offset=par1.offsetLeft-par2.offsetLeft;event.preventDefault();subOffset=(p" +
                "ar1.scrollLeft>document.body.scrollLeft)?par1.scrollLeft:document.body.scrollLef" +
                "t;offset=offset-subOffset;offset=offset+node.clientWidth;node.style.cursor=\"ew-" +
                "resize\";diff.style.width=(total/10)+\"em\";diff.style.display=\"inline-block\";" +
                "if(diffLeft.nodeType!==1){do{diffLeft=diffLeft.previousSibling}while(diffLeft.no" +
                "deType!==1)}diffLeft.style.display=\"block\";diffRight.style.width=(diffRight.cl" +
                "ientWidth/10)+\"em\";diffRight.style.position=\"absolute\";if(touch===true){docu" +
                "ment.ontouchmove=function doc_colSliderGrab_Touchboxmove(f){f.preventDefault();s" +
                "ubOffset=offset-f.touches[0].clientX;if(subOffset>minAdjust&&subOffset<maxAdjust" +
                "){withinRange=true}if(withinRange===true&&subOffset>maxAdjust){diffRight.style.w" +
                "idth=((total-counter-2)/10)+\"em\";status=\"e\"}else if(withinRange===true&&subO" +
                "ffset<minAdjust){diffRight.style.width=((total-counter-data-2)/10)+\"em\";status" +
                "=\"w\"}else if(subOffset<max&&subOffset>min){diffRight.style.width=((width+subOf" +
                "fset)/10)+\"em\";status=\"ew\"}document.ontouchend=function doc_colSliderGrab_To" +
                "uchboxmove_drop(f){f.preventDefault();node.style.cursor=status+\"-resize\";docum" +
                "ent.ontouchmove=null;document.ontouchend=null}};document.ontouchstart=null}else{" +
                "document.onmousemove=function doc_colSliderGrab_Mouseboxmove(f){f.preventDefault" +
                "();subOffset=offset-f.clientX;if(subOffset>minAdjust&&subOffset<maxAdjust){withi" +
                "nRange=true}if(withinRange===true&&subOffset>maxAdjust){diffRight.style.width=((" +
                "total-counter-2)/10)+\"em\";status=\"e\"}else if(withinRange===true&&subOffset<m" +
                "inAdjust){diffRight.style.width=((total-counter-data-2)/10)+\"em\";status=\"w\"}" +
                "else if(subOffset<max&&subOffset>min){diffRight.style.width=((width+subOffset)/1" +
                "0)+\"em\";status=\"ew\"}document.onmouseup=function doc_colSliderGrab_Mouseboxmo" +
                "ve_drop(f){f.preventDefault();node.style.cursor=status+\"-resize\";document.onmo" +
                "usemove=null;document.onmouseup=null}};document.onmousedown=null}return false},d" +
                "ifffold=function doc_difffold(event){let a=0,b=0,max,lists=[];const node=event.s" +
                "rcElement||event.target,title=node.getAttribute(\"title\").split(\"line \"),min=" +
                "Number(title[1].substr(0,title[1].indexOf(\" \"))),inner=node.innerHTML,parent=n" +
                "ode.parentNode.parentNode,par1=parent.parentNode,listnodes=(parent.getAttribute(" +
                "\"class\")===\"diff\")?parent.getElementsByTagName(\"ol\"):par1.getElementsByTag" +
                "Name(\"ol\"),listLen=listnodes.length;do{lists.push(listnodes[a].getElementsByTa" +
                "gName(\"li\"));a=a+1}while(a<listLen);max=(max>=lists[0].length)?lists[0].length" +
                ":Number(title[2]);if(inner.charAt(0)===\"-\"){node.innerHTML=\"+\"+inner.substr(" +
                "1);a=min;if(min<max){do{b=0;do{lists[b][a].style.display=\"none\";b=b+1}while(b<l" +
                "istLen);a=a+1}while(a<max)}}else{node.innerHTML=\"-\"+inner.substr(1);a=min;if(m" +
                "in<max){do{b=0;do{lists[b][a].style.display=\"block\";b=b+1}while(b<listLen);a=a+" +
                "1}while(a<max)}}};diffList=document.getElementsByTagName(\"ol\");if(diffList.len" +
                "gth>0){const cells=diffList[0].getElementsByTagName(\"li\"),len=cells.length;let" +
                " a=0;do{if(cells[a].getAttribute(\"class\")===\"fold\"){cells[a].onclick=difffol" +
                "d}a=a+1}while(a<len)}if(diffList.length>3){diffList[2].onmousedown=colSliderGrab" +
                ";diffList[2].ontouchstart=colSliderGrab}color.onchange=change}());",
            minimal: "(function doc(){\"use strict\";const body=document.getElementsByTagName(\"body\"" +
                ")[0],color" + "=document.getElementById(\"colorScheme\"),change=function doc_colorChange(){cons" +
                "t name=color[color.selectedIndex].innerHTML.toLowerCase();body.setAttribute(\"cl" +
                "ass\",name)};color.onchange=change}());"
        }
    };
    finalFile.order = [
        finalFile.html.head,
        finalFile
            .css
            .color
            .canvas,
        finalFile
            .css
            .color
            .shadow,
        finalFile
            .css
            .color
            .white,
        finalFile.css.reports,
        finalFile.css.global,
        finalFile.html.body,
        finalFile.html.color,
        finalFile.html.intro,
        "",
        "",
        finalFile.html.scriptStart,
        "\n",
        finalFile.script.minimal,
        finalFile.html.scriptEnd,
        "\n",
        finalFile.html.htmlEnd // 16
    ];
    prettydiff.api
        .finalFile = finalFile;
}());

(function beautify_script_init() {
    const script = function beautify_script(options) {
        let scolon = 0, news = 0;
        const data = options.parsed, lexer = "script", scopes = prettydiff.scopes, b = (prettydiff.end < 1 || prettydiff.end > data.token.length)
            ? data.token.length
            : prettydiff.end + 1, externalIndex = {}, 
        // levels sets the white space value between the current token and the next token
        // * -20 value means no white space
        // * -10 means to separate with a space
        // * 0 and above is the number of indentation to insert
        levels = (function beautify_script_level() {
            let a = prettydiff.start, //will store the current level of indentation
            indent = (isNaN(options.indent_level) === true)
                ? 0
                : Number(options.indent_level), notcomment = false, // if in comments before any code
            lastlist = false, //remembers the list status of the most recently closed block
            ctype = "", //ctype stands for "current type"
            ctoke = "", //ctoke standa for "current token"
            ltype = data.types[0], //ltype stands for "last type"
            ltoke = data.token[0]; //ltype stands for "last token"
            const varindex = [-1], //index in current scope of last var, let, or const keyword
            list = [], //stores comma status of current block
            level = (prettydiff.start > 0)
                ? Array(prettydiff.start).fill(0, 0, prettydiff.start)
                : [], ternary = [], //used to identify ternary statments
            extraindent = [
                []
            ], //stores token indexes where extra indentation occurs from ternaries and broken method chains
            arrbreak = [], //array where a method break has occurred
            destruct = [], //attempt to identify object destructuring
            itemcount = [], //counts items in destructured lists
            assignlist = [false], //are you in a list right now?
            wordlist = [], count = [], comment = function beautify_script_level_comment() {
                destructfix(false, false);
                let ind = (options.comments === true)
                    ? 0
                    : indent;
                if (notcomment === false && (/\/\u002a\s*global\s/).test(data.token[a]) === true) {
                    let globallist = data.token[a].replace(/\/\u002a\s*global\s+/, "").replace(/\s*\u002a\/$/, "").split(","), aa = globallist.length;
                    do {
                        aa = aa - 1;
                        globallist[aa] = globallist[aa].replace(/\s+/g, "");
                        if (globallist[aa] !== "") {
                            scopes.push([globallist[aa], -1]);
                        }
                    } while (aa > 0);
                }
                if (data.types[a - 1] === "comment" || data.types[a + 1] === "comment") {
                    level[a - 1] = ind;
                }
                else if (data.lines[a] < 2) {
                    let aa = a + 1;
                    if (data.types[aa] === "comment") {
                        do {
                            aa = aa + 1;
                        } while (aa < b && data.types[aa] === "comment");
                    }
                    if (a < b - 1 && data.stack[aa] !== "block" && (data.token[aa] === "{" || data.token[aa] === "x{")) {
                        let bb = scopes.length;
                        data.begin.splice(a, 0, data.begin[aa]);
                        data.ender.splice(a, 0, data.ender[aa]);
                        data.lexer.splice(a, 0, data.lexer[aa]);
                        data.lines.splice(a, 0, data.lines[aa]);
                        data.stack.splice(a, 0, data.stack[aa]);
                        data.token.splice(a, 0, data.token[aa]);
                        data.types.splice(a, 0, data.types[aa]);
                        if (bb > 0) {
                            do {
                                bb = bb - 1;
                                if (scopes[bb][1] === aa) {
                                    scopes[bb][1] = a;
                                }
                                else if (scopes[bb][1] < a) {
                                    break;
                                }
                            } while (bb > 0);
                        }
                        aa = aa + 1;
                        data.begin.splice(aa, 1);
                        data.ender.splice(aa, 1);
                        data.lexer.splice(aa, 1);
                        data.lines.splice(aa, 1);
                        data.stack.splice(aa, 1);
                        data.token.splice(aa, 1);
                        data.types.splice(aa, 1);
                        bb = a + 1;
                        do {
                            data.begin[bb] = a;
                            data.stack[bb] = data.stack[aa];
                            bb = bb + 1;
                        } while (bb < aa);
                        bb = bb + 1;
                        do {
                            if (data.begin[bb] === data.begin[aa]) {
                                data.begin[bb] = a;
                                if (data.types[bb] === "end") {
                                    break;
                                }
                            }
                            bb = bb + 1;
                        } while (bb < b - 1);
                        data.begin[aa] = a;
                        a = a - 1;
                    }
                    else {
                        level[a - 1] = -10;
                        if (data.stack[a] === "paren" || data.stack[a] === "method") {
                            level.push(indent + 2);
                        }
                        else {
                            level.push(indent);
                        }
                        if (options.comment_line === true && level[a] > -1 && data.lines[a] < 3) {
                            data.lines[a] = 3;
                        }
                    }
                    if (data.types[a + 1] !== "comment") {
                        notcomment = true;
                    }
                    return;
                }
                else if (data.token[a - 1] === ",") {
                    level[a - 1] = ind;
                }
                else if (ltoke === "=" && data.types[a - 1] !== "comment" && (/^(\/\*\*\s*@[a-z_]+\s)/).test(ctoke) === true) {
                    level[a - 1] = -10;
                }
                else if (ltoke === "{" && data.types[a - 1] !== "comment" && data.lines[0] < 2) {
                    level[a - 1] = -10;
                }
                else {
                    level[a - 1] = ind;
                }
                if (data.types[a + 1] !== "comment") {
                    notcomment = true;
                }
                if (data.token[data.begin[a]] === "(") {
                    level.push(indent + 1);
                }
                else {
                    level.push(indent);
                }
                if (options.comment_line === true && level[a] > -1 && data.lines[a] < 3) {
                    data.lines[a] = 3;
                }
            }, destructfix = function beautify_script_level_destructFix(listFix, override) {
                // listfix  - at the end of a list correct the containing list override - to
                // break arrays with more than 4 items into a vertical list
                let c = a - 1, d = (listFix === true)
                    ? 0
                    : 1;
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], arrayCheck = (override === false && data.stack[a] === "array" && listFix === true && ctoke !== "[");
                if (destruct[destruct.length - 1] === false || (data.stack[a] === "array" && options.formatArray === "inline") || (data.stack[a] === "object" && options.format_object === "inline")) {
                    return;
                }
                destruct[destruct.length - 1] = false;
                do {
                    if (data.types[c] === "end") {
                        d = d + 1;
                    }
                    else if (data.types[c] === "start") {
                        d = d - 1;
                    }
                    if (data.stack[c] === "global") {
                        break;
                    }
                    if (d === 0) {
                        if (data.stack[a] === "class" || data.stack[a] === "map" || (arrayCheck === false && ((listFix === false && data.token[c] !== "(" && data.token[c] !== "x(") || (listFix === true && data.token[c] === ",")))) {
                            if (data.types[c + 1] === "template_start") {
                                if (data.lines[c] < 1) {
                                    level[c] = -20;
                                }
                                else {
                                    level[c] = indent - 1;
                                }
                            }
                            else if (ei.length > 0 && ei[ei.length - 1] > -1) {
                                level[c] = indent - 1;
                            }
                            else {
                                level[c] = indent;
                            }
                        }
                        else if (data.stack[a] === "array" && data.types[a] === "operator") {
                            if (data.token[c] === ",") {
                                level[c] = indent;
                            }
                            if (c === data.begin[a]) {
                                break;
                            }
                        }
                        if (listFix === false) {
                            break;
                        }
                    }
                    if (d < 0) {
                        if (data.types[c + 1] === "template_start" || data.types[c + 1] === "template_string_start") {
                            if (data.lines[c] < 1) {
                                level[c] = -20;
                            }
                            else {
                                level[c] = indent - 1;
                            }
                        }
                        else if (ei.length > 0 && ei[ei.length - 1] > -1) {
                            level[c] = indent - 1;
                        }
                        else {
                            level[c] = indent;
                        }
                        break;
                    }
                    c = c - 1;
                } while (c > -1);
            }, end = function beautify_script_level_end() {
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], markupList = function beautify_script_level_end_markupList() {
                    let aa = a, markup = false;
                    const begin = data.begin[aa];
                    do {
                        aa = aa - 1;
                        if (data.lexer[aa] === "markup") {
                            markup = true;
                            break;
                        }
                        if (data.begin[aa] !== begin) {
                            aa = data.begin[aa];
                        }
                    } while (aa > begin);
                    if (markup === true) {
                        aa = a;
                        do {
                            aa = aa - 1;
                            if (data.begin[aa] !== begin) {
                                aa = data.begin[aa];
                            }
                            else if (data.token[aa] === ",") {
                                level[aa] = indent + 1;
                            }
                        } while (aa > begin);
                        level[begin] = indent + 1;
                        level[a - 1] = indent;
                    }
                    else {
                        level[a - 1] = -20;
                    }
                };
                if (ctoke === ")" && data.token[a + 1] === "." && ei[ei.length - 1] > -1 && data.token[ei[0]] !== ":") {
                    let c = data.begin[a], d = false, e = false;
                    do {
                        c = c - 1;
                    } while (c > 0 && level[c] < -9);
                    d = (level[c] === indent);
                    c = a + 1;
                    do {
                        c = c + 1;
                        if (data.token[c] === "{") {
                            e = true;
                            break;
                        }
                        if (data.begin[c] === data.begin[a + 1] && (data.types[c] === "separator" || data.types[c] === "end")) {
                            break;
                        }
                    } while (c < b);
                    if (d === false && e === true && extraindent.length > 1) {
                        extraindent[extraindent.length - 2].push(data.begin[a]);
                        indent = indent + 1;
                    }
                }
                if (ltype !== "separator") {
                    fixchain();
                }
                if (data.token[a + 1] === "," && (data.stack[a] === "object" || data.stack[a] === "array")) {
                    destructfix(true, false);
                }
                if ((data.token[a + 1] === "}" || data.token[a + 1] === "]") && (data.stack[a] === "object" || data.stack[a] === "array") && data.token[data.begin[a] - 1] === ",") {
                    destructfix(true, false);
                }
                if (data.stack[a] !== "attribute") {
                    if (ctoke !== ")" && ctoke !== "x)" && (data.lexer[a - 1] !== "markup" || (data.lexer[a - 1] === "markup" && data.token[a - 2] !== "return"))) {
                        indent = indent - 1;
                    }
                    if (ctoke === "}" && data.stack[a] === "switch" && options.no_case_indent === false) {
                        indent = indent - 1;
                    }
                }
                if (ctoke === "}" || ctoke === "x}") {
                    if (data.types[a - 1] !== "comment" &&
                        ltoke !== "{" &&
                        ltoke !== "x{" &&
                        ltype !== "end" &&
                        ltype !== "string" &&
                        ltype !== "number" &&
                        ltype !== "separator" &&
                        ltoke !== "++" &&
                        ltoke !== "--" &&
                        (a < 2 || data.token[a - 2] !== ";" || data.token[a - 2] !== "x;" || ltoke === "break" || ltoke === "return")) {
                        let c = a - 1, begin = data.begin[a], assign = false, listlen = list.length;
                        do {
                            if (data.begin[c] === begin) {
                                if (data.token[c] === "=" || data.token[c] === ";" || data.token[c] === "x;") {
                                    assign = true;
                                }
                                if (data.token[c] === "." && level[c - 1] > -1) {
                                    // setting destruct is necessary to prevent a rule below
                                    destruct[destruct.length - 1] = false;
                                    level[begin] = indent + 1;
                                    level[a - 1] = indent;
                                    break;
                                }
                                if (c > 0 && data.token[c] === "return" && (data.token[c - 1] === ")" || data.token[c - 1] === "x)" || data.token[c - 1] === "{" || data.token[c - 1] === "x{" || data.token[c - 1] === "}" || data.token[c - 1] === "x}" || data.token[c - 1] === ";" || data.token[c - 1] === "x;")) {
                                    indent = indent - 1;
                                    level[a - 1] = indent;
                                    break;
                                }
                                if ((data.token[c] === ":" && ternary.length === 0) ||
                                    (data.token[c] === "," && assign === false)) {
                                    break;
                                }
                                if ((c === 0 || data.token[c - 1] === "{" || data.token[c - 1] === "x{") || data.token[c] === "for" || data.token[c] === "if" || data.token[c] === "do" || data.token[c] === "function" || data.token[c] === "while" || data.token[c] === "var" || data.token[c] === "let" || data.token[c] === "const" || data.token[c] === "with") {
                                    if (list[listlen - 1] === false && listlen > 1 && (a === b - 1 || (data.token[a + 1] !== ")" && data.token[a + 1] !== "x)")) && data.stack[a] !== "object") {
                                        indent = indent - 1;
                                    }
                                    break;
                                }
                            }
                            else {
                                c = data.begin[c];
                            }
                            c = c - 1;
                        } while (c > begin);
                    }
                    varindex.pop();
                }
                if (options.brace_padding === false && ctoke !== "}" && ltype !== "markup") {
                    level[a - 1] = -20;
                }
                if (options.brace_padding === true && ltype !== "start" && ltoke !== ";" && (level[data.begin[a]] < -9 || destruct[destruct.length - 1] === true)) {
                    level[data.begin[a]] = -10;
                    level[a - 1] = -10;
                    level.push(-20);
                }
                else if (options.language === "qml") {
                    if (ltype === "start" || ctoke === ")" || ctoke === "x)") {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = indent;
                    }
                    level.push(indent);
                }
                else if (data.stack[a] === "attribute") {
                    level[a - 1] = -20;
                    level.push(indent);
                }
                else if (data.stack[a] === "array" && (ei.length > 0 || arrbreak[arrbreak.length - 1] === true)) {
                    endExtraInd();
                    destruct[destruct.length - 1] = false;
                    level[data.begin[a]] = indent + 1;
                    level[a - 1] = indent;
                    level.push(-20);
                }
                else if ((data.stack[a] === "object" || (data.begin[a] === 0 && ctoke === "}")) && ei.length > 0) {
                    endExtraInd();
                    destruct[destruct.length - 1] = false;
                    level[data.begin[a]] = indent + 1;
                    level[a - 1] = indent;
                    level.push(-20);
                }
                else if (ctoke === ")" || ctoke === "x)") {
                    const countx = (ctoke === ")" && ltoke !== "(" && count.length > 0)
                        ? count.pop() + 1
                        : 0, countIf = (data.token[data.begin[a] - 1] === "if")
                        ? (function beautify_script_level_end_countIf() {
                            let bb = a;
                            do {
                                bb = bb - 1;
                                if (data.token[bb] === ")" && level[bb - 1] > -1) {
                                    return countx;
                                }
                            } while (bb > data.begin[a]);
                            return countx + 5;
                        }())
                        : countx;
                    if (countx > 0 && (options.language !== "jsx" || (options.language === "jsx" && data.token[data.begin[a] - 1] !== "render"))) {
                        const wrap = options.wrap, begin = data.begin[a], len = count.length;
                        let aa = a - 2;
                        if (countIf > wrap) {
                            level[data.begin[a]] = indent + 1;
                            level[a - 1] = indent;
                            do {
                                if (data.begin[aa] === begin) {
                                    if (data.token[aa] === "&&" || data.token[aa] === "||") {
                                        level[aa] = indent + 1;
                                    }
                                    else if (level[aa] > -1 && data.types[aa] !== "comment" && data.token[aa + 1] !== ".") {
                                        level[aa] = level[aa] + 1;
                                    }
                                }
                                else if (level[aa] > -1 && data.token[aa + 1] !== ".") {
                                    level[aa] = level[aa] + 1;
                                }
                                aa = aa - 1;
                            } while (aa > begin);
                        }
                        else if (len > 0) {
                            count[len - 1] = count[len - 1] + countx;
                        }
                    }
                    else if (ctoke === ")" && a > data.begin[a] + 2 && data.lexer[data.begin[a] + 1] === lexer && data.token[data.begin[a] + 1] !== "function") {
                        const open = (data.begin[a] < 0)
                            ? 0
                            : data.begin[a];
                        let len = 0, aa = 0, short = 0, first = 0, inc = 0, comma = false, array = false, wrap = options.wrap, ind = (indent + 1), exl = ei.length, ready = false, mark = false, tern = false;
                        if (level[open] < -9) {
                            aa = open;
                            do {
                                aa = aa + 1;
                            } while (aa < a && level[aa] < -9);
                            first = aa;
                            do {
                                len = len + data.token[aa].length;
                                if (level[aa] === -10) {
                                    len = len + 1;
                                }
                                if (data.token[aa] === "(" && short > 0 && short < wrap - 1 && first === a) {
                                    short = -1;
                                }
                                if (data.token[aa] === ")") {
                                    inc = inc - 1;
                                }
                                else if (data.token[aa] === "(") {
                                    inc = inc + 1;
                                }
                                if (aa === open && inc > 0) {
                                    short = len;
                                }
                                aa = aa - 1;
                            } while (aa > open && level[aa] < -9);
                            if (data.token[aa + 1] === ".") {
                                ind = level[aa] + 1;
                            }
                            if (len > wrap - 1 && wrap > 0 && ltoke !== "(" && short !== -1 && destruct[destruct.length - 2] === false) {
                                if ((data.token[open - 1] === "if" && list[list.length - 1] === true) || data.token[open - 1] !== "if") {
                                    level[open] = ind;
                                    if (data.token[open - 1] === "for") {
                                        aa = open;
                                        do {
                                            aa = aa + 1;
                                            if (data.token[aa] === ";" && data.begin[aa] === open) {
                                                level[aa] = ind;
                                            }
                                        } while (aa < a);
                                    }
                                }
                            }
                        }
                        aa = a;
                        len = 0;
                        do {
                            aa = aa - 1;
                            if (data.stack[aa] === "function") {
                                aa = data.begin[aa];
                            }
                            else if (data.begin[aa] === open) {
                                if (data.token[aa] === "?") {
                                    tern = true;
                                }
                                else if (data.token[aa] === "," && comma === false) {
                                    comma = true;
                                    if (len >= wrap && wrap > 0) {
                                        ready = true;
                                    }
                                }
                                else if (data.types[aa] === "markup" && mark === false) {
                                    mark = true;
                                }
                                if (level[aa] > -9 && data.token[aa] !== "," && data.types[aa] !== "markup") {
                                    len = 0;
                                }
                                else {
                                    if (level[aa] === -10) {
                                        len = len + 1;
                                    }
                                    len = len + data.token[aa].length;
                                    if (len >= wrap && wrap > 0 && (comma === true || mark === true)) {
                                        ready = true;
                                    }
                                }
                            }
                            else {
                                if (level[aa] > -9) {
                                    len = 0;
                                }
                                else {
                                    len = len + data.token[aa].length;
                                    if (len >= wrap && wrap > 0 && (comma === true || mark === true)) {
                                        ready = true;
                                    }
                                }
                            }
                        } while (aa > open && ready === false);
                        if (comma === false && data.token[data.begin[a] + 1].charAt(0) === "`") {
                            level[data.begin[a]] = -20;
                            level[a - 1] = -20;
                        }
                        else if (((comma === true || mark === true) && len >= wrap && wrap > 0) || level[open] > -9) {
                            if (tern === true) {
                                ind = level[open];
                                if (data.token[open - 1] === "[") {
                                    aa = a;
                                    do {
                                        aa = aa + 1;
                                        if (data.types[aa] === "end" || data.token[aa] === "," || data.token[aa] === ";") {
                                            break;
                                        }
                                    } while (aa < b);
                                    if (data.token[aa] === "]") {
                                        ind = ind - 1;
                                        array = true;
                                    }
                                }
                            }
                            else if (exl > 0 && ei[exl - 1] > aa) {
                                ind = ind - exl;
                            }
                            destruct[destruct.length - 1] = false;
                            aa = a;
                            do {
                                aa = aa - 1;
                                if (data.begin[aa] === open) {
                                    if (data.token[aa].indexOf("=") > -1 && data.types[aa] === "operator" && data.token[aa].indexOf("!") < 0 && data.token[aa].indexOf("==") < 0 && data.token[aa] !== "<=" && data.token[aa].indexOf(">") < 0) {
                                        len = aa;
                                        do {
                                            len = len - 1;
                                            if (data.begin[len] === open && (data.token[len] === ";" || data.token[len] === "," || len === open)) {
                                                break;
                                            }
                                        } while (len > open);
                                    }
                                    else if (data.token[aa] === ",") {
                                        level[aa] = ind;
                                    }
                                    else if (level[aa] > -9 && array === false && (data.token[open - 1] !== "for" || data.token[aa + 1] === "?" || data.token[aa + 1] === ":") && (data.token[data.begin[a]] !== "(" || data.token[aa] !== "+")) {
                                        level[aa] = level[aa] + 1;
                                    }
                                }
                                else if (level[aa] > -9 && array === false) {
                                    level[aa] = level[aa] + 1;
                                }
                            } while (aa > open);
                            level[open] = ind;
                            level[a - 1] = ind - 1;
                        }
                        else {
                            level[a - 1] = -20;
                        }
                        if (data.token[data.begin[a] - 1] === "+" && level[data.begin[a]] > -9) {
                            level[data.begin[a] - 1] = -10;
                        }
                    }
                    else if (options.language === "jsx") {
                        markupList();
                    }
                    else {
                        level[a - 1] = -20;
                    }
                    level.push(-20);
                }
                else if (destruct[destruct.length - 1] === true) {
                    if (ctoke === "]" && data.begin[a] - 1 > 0 && data.token[data.begin[data.begin[a] - 1]] === "[") {
                        destruct[destruct.length - 2] = false;
                    }
                    if (data.begin[a] < level.length) {
                        level[data.begin[a]] = -20;
                    }
                    if (options.language === "jsx") {
                        markupList();
                    }
                    else if (ctoke === "]" && level[data.begin[a]] > -1) {
                        level[a - 1] = level[data.begin[a]] - 1;
                    }
                    else {
                        level[a - 1] = -20;
                    }
                    level.push(-20);
                }
                else if (data.types[a - 1] === "comment" && data.token[a - 1].substr(0, 2) === "//") {
                    if (data.token[a - 2] === "x}") {
                        level[a - 3] = indent + 1;
                    }
                    level[a - 1] = indent;
                    level.push(-20);
                }
                else if (data.types[a - 1] !== "comment" && ((ltoke === "{" && ctoke === "}") || (ltoke === "[" && ctoke === "]"))) {
                    level[a - 1] = -20;
                    if (ctoke === "}" && options.language === "titanium") {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
                else if (ctoke === "]") {
                    if ((list[list.length - 1] === true && destruct[destruct.length - 1] === false && options.format_array !== "inline") || (ltoke === "]" && level[a - 2] === indent + 1)) {
                        level[a - 1] = indent;
                        level[data.begin[a]] = indent + 1;
                    }
                    else if (level[a - 1] === -10) {
                        level[a - 1] = -20;
                    }
                    if (data.token[data.begin[a] + 1] === "function") {
                        level[a - 1] = indent;
                    }
                    else if (list[list.length - 1] === false) {
                        if (ltoke === "}" || ltoke === "x}") {
                            level[a - 1] = indent;
                        }
                        let c = a - 1, d = 1;
                        do {
                            if (data.token[c] === "]") {
                                d = d + 1;
                            }
                            if (data.token[c] === "[") {
                                d = d - 1;
                                if (d === 0) {
                                    if (c > 0 && (data.token[c + 1] === "{" || data.token[c + 1] === "x{" || data.token[c + 1] === "[")) {
                                        level[c] = indent + 1;
                                        break;
                                    }
                                    if (data.token[c + 1] !== "[" || lastlist === false) {
                                        level[c] = -20;
                                        break;
                                    }
                                    break;
                                }
                            }
                            if (d === 1 && data.token[c] === "+" && level[c] > 1) {
                                level[c] = level[c] - 1;
                            }
                            c = c - 1;
                        } while (c > -1);
                    }
                    else if (options.language === "jsx") {
                        markupList();
                    }
                    if (options.format_array === "inline") {
                        let c = a, begin = data.begin[a];
                        do {
                            c = c - 1;
                            if (data.types[c] === "end") {
                                break;
                            }
                        } while (c > begin);
                        if (c > begin) {
                            level[data.begin[a]] = indent + 1;
                            level[a - 1] = indent;
                        }
                        else {
                            level[data.begin[a]] = -20;
                            level[a - 1] = -20;
                        }
                    }
                    else if (level[data.begin[a]] > -1) {
                        level[a - 1] = level[data.begin[a]] - 1;
                    }
                    level.push(-20);
                }
                else if (ctoke === "}" || ctoke === "x}" || list[list.length - 1] === true) {
                    if (ctoke === "}" && ltoke === "x}" && data.token[a + 1] === "else") {
                        level[a - 2] = indent + 2;
                        level.push(-20);
                    }
                    else {
                        level.push(indent);
                    }
                    level[a - 1] = indent;
                }
                else {
                    level.push(-20);
                }
                if (data.types[a - 1] === "comment") {
                    level[a - 1] = indent;
                }
                endExtraInd();
                lastlist = list[list.length - 1];
                list.pop();
                extraindent.pop();
                arrbreak.pop();
                itemcount.pop();
                wordlist.pop();
                destruct.pop();
                assignlist.pop();
            }, endExtraInd = function beautify_script_level_endExtraInd() {
                const ei = extraindent[extraindent.length - 1];
                let c = 0;
                if (ei === undefined) {
                    return;
                }
                c = ei.length - 1;
                if (c < 1 && ei[c] < 0 && (ctoke === ";" || ctoke === "x;" || ctoke === ")" || ctoke === "x)" || ctoke === "}" || ctoke === "x}")) {
                    ei.pop();
                    return;
                }
                if (c < 0 || ei[c] < 0) {
                    return;
                }
                if (ctoke === ":") {
                    if (data.token[ei[c]] !== "?") {
                        do {
                            ei.pop();
                            c = c - 1;
                            indent = indent - 1;
                        } while (c > -1 && ei[c] > -1 && data.token[ei[c]] !== "?");
                    }
                    ei[c] = a;
                    level[a - 1] = indent;
                }
                else {
                    do {
                        ei.pop();
                        c = c - 1;
                        indent = indent - 1;
                    } while (c > -1 && ei[c] > -1);
                }
                if ((data.stack[a] === "array" || ctoke === ",") && ei.length < 1) {
                    ei.push(-1);
                }
            }, external = function beautify_script_level_external() {
                let skip = a;
                do {
                    if (data.lexer[a + 1] === lexer && data.begin[a + 1] < skip) {
                        break;
                    }
                    if (data.token[skip - 1] === "return" && data.types[a] === "end" && data.begin[a] === skip) {
                        break;
                    }
                    level.push(0);
                    a = a + 1;
                } while (a < b);
                externalIndex[skip] = a;
                level.push(indent - 1);
            }, fixchain = function beautify_script_level_fixchain() {
                let bb = a - 1, cc = data.begin[a];
                if (indent < 1) {
                    return;
                }
                do {
                    if (cc !== data.begin[bb]) {
                        bb = data.begin[bb];
                    }
                    else {
                        if (data.types[bb] === "separator" || data.types[bb] === "operator") {
                            if (data.token[bb] === "." && level[bb - 1] > 0) {
                                if (data.token[cc - 1] === "if") {
                                    indent = indent - 2;
                                }
                                else {
                                    indent = indent - 1;
                                }
                            }
                            break;
                        }
                    }
                    bb = bb - 1;
                } while (bb > 0 && bb > cc);
            }, markup = function beautify_script_level_markup() {
                if ((data.token[a + 1] !== "," && ctoke.indexOf("/>") !== ctoke.length - 2) || (data.token[a + 1] === "," && data.token[data.begin[a] - 3] !== "React")) {
                    destructfix(false, false);
                }
                if (ltoke === "return" || ltoke === "?" || ltoke === ":") {
                    level[a - 1] = -10;
                    level.push(-20);
                }
                else if (ltype === "start" || (data.token[a - 2] === "return" && data.stack[a - 1] === "method")) {
                    level.push(indent);
                }
                else {
                    level.push(-20);
                }
            }, operator = function beautify_script_level_operator() {
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], opWrap = function beautify_script_level_operator_opWrap() {
                    const aa = data.token[a + 1];
                    let line = 0, next = 0, c = a, ind = (ctoke === "+")
                        ? indent + 2
                        : indent, meth = 0;
                    if (options.wrap < 1) {
                        level.push(-10);
                        return;
                    }
                    do {
                        c = c - 1;
                        if (data.token[data.begin[a]] === "(") {
                            if (c === data.begin[a]) {
                                meth = line;
                            }
                            if (data.token[c] === "," && data.begin[c] === data.begin[a] && list[list.length - 1] === true) {
                                break;
                            }
                        }
                        if (line > options.wrap - 1) {
                            break;
                        }
                        if (level[c] > -9) {
                            break;
                        }
                        if (data.types[c] === "operator" && data.token[c] !== "=" && data.token[c] !== "+" && data.begin[c] === data.begin[a]) {
                            break;
                        }
                        line = line + data.token[c].length;
                        if (c === data.begin[a] && data.token[c] === "[" && line < options.wrap - 1) {
                            break;
                        }
                        if (data.token[c] === "." && level[c] > -9) {
                            break;
                        }
                        if (level[c] === -10) {
                            line = line + 1;
                        }
                    } while (c > 0);
                    if (meth > 0) {
                        meth = meth + aa.length;
                    }
                    line = line + aa.length;
                    next = c;
                    if (line > options.wrap - 1 && level[c] < -9) {
                        do {
                            next = next - 1;
                        } while (next > 0 && level[next] < -9);
                    }
                    if (data.token[next + 1] === "." && data.begin[a] <= data.begin[next]) {
                        ind = ind + 1;
                    }
                    else if (data.types[next] === "operator") {
                        ind = level[next];
                    }
                    next = aa.length;
                    if (line + next < options.wrap) {
                        level.push(-10);
                        return;
                    }
                    if (data.token[data.begin[a]] === "(" && (data.token[ei[0]] === ":" || data.token[ei[0]] === "?")) {
                        ind = indent + 3;
                    }
                    else if (data.stack[a] === "method") {
                        level[data.begin[a]] = indent;
                        if (list[list.length - 1] === true) {
                            ind = indent + 3;
                        }
                        else {
                            ind = indent + 1;
                        }
                    }
                    else if (data.stack[a] === "object" || data.stack[a] === "array") {
                        destructfix(true, false);
                    }
                    if (data.token[c] === "var" || data.token[c] === "let" || data.token[c] === "const") {
                        line = line - (options.indent_size * options.indent_char.length * 2);
                    }
                    if (meth > 0) {
                        c = options.wrap - meth;
                    }
                    else {
                        c = options.wrap - line;
                    }
                    if (c > 0 && c < 5) {
                        level.push(ind);
                        if (data.token[a].charAt(0) === "\"" || data.token[a].charAt(0) === "'") {
                            a = a + 1;
                            level.push(-10);
                        }
                        return;
                    }
                    if (data.token[data.begin[a]] !== "(" || meth > options.wrap - 1 || meth === 0) {
                        if (meth > 0) {
                            line = meth;
                        }
                        if (line - aa.length < options.wrap - 1 && (aa.charAt(0) === "\"" || aa.charAt(0) === "'")) {
                            a = a + 1;
                            line = line + 3;
                            if (line - aa.length > options.wrap - 4) {
                                level.push(ind);
                                return;
                            }
                            level.push(-10);
                            return;
                        }
                        level.push(ind);
                        return;
                    }
                    level.push(-10);
                };
                fixchain();
                if (ei.length > 0 && ei[ei.length - 1] > -1 && data.stack[a] === "array") {
                    arrbreak[arrbreak.length - 1] = true;
                }
                if (ctoke !== ":") {
                    if (data.token[data.begin[a]] !== "(" && data.token[data.begin[a]] !== "x(" && destruct.length > 0) {
                        destructfix(true, false);
                    }
                    if (ctoke !== "?" && data.token[ei[ei.length - 1]] === ".") {
                        let c = a, d = data.begin[c], e = 0;
                        do {
                            if (data.begin[c] === d) {
                                if (data.token[c + 1] === "{" || data.token[c + 1] === "[" || data.token[c] === "function") {
                                    break;
                                }
                                if (data.token[c] === "," || data.token[c] === ";" || data.types[c] === "end" || data.token[c] === ":") {
                                    ei.pop();
                                    indent = indent - 1;
                                    break;
                                }
                                if (data.token[c] === "?" || data.token[c] === ":") {
                                    if (data.token[ei[ei.length - 1]] === "." && e < 2) {
                                        ei[ei.length - 1] = d + 1;
                                    }
                                    break;
                                }
                                if (data.token[c] === ".") {
                                    e = e + 1;
                                }
                            }
                            c = c + 1;
                        } while (c < b);
                    }
                }
                if (ctoke === "!" || ctoke === "...") {
                    if (ltoke === "}" || ltoke === "x}") {
                        level[a - 1] = indent;
                    }
                    level.push(-20);
                    return;
                }
                if (ltoke === ";" || ltoke === "x;") {
                    if (data.token[data.begin[a] - 1] !== "for") {
                        level[a - 1] = indent;
                    }
                    level.push(-20);
                    return;
                }
                if (ctoke === "*") {
                    if (ltoke === "function" || ltoke === "yield") {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = -10;
                    }
                    level.push(-10);
                    return;
                }
                if (ctoke === "?") {
                    if (data.lines[a] === 0 && data.types[a - 2] === "word" && data.token[a - 2] !== "return" && data.token[a - 2] !== "in" && data.token[a - 2] !== "instanceof" && data.token[a - 2] !== "typeof" && (ltype === "reference" || ltype === "word")) {
                        if (data.types[a + 1] === "word" || data.types[a + 1] === "reference" || ((data.token[a + 1] === "(" || data.token[a + 1] === "x(") && data.token[a - 2] === "new")) {
                            level[a - 1] = -20;
                            if (data.types[a + 1] === "word" || data.types[a + 1] === "reference") {
                                level.push(-10);
                                return;
                            }
                            level.push(-20);
                            return;
                        }
                    }
                    if (data.token[a + 1] === ":") {
                        level[a - 1] = -20;
                        level.push(-20);
                        return;
                    }
                    ternary.push(a);
                    if (options.ternary_line === true) {
                        level[a - 1] = -10;
                    }
                    else {
                        let c = a - 1;
                        do {
                            c = c - 1;
                        } while (c > -1 && level[c] < -9);
                        ei.push(a);
                        indent = indent + 1;
                        if (level[c] === indent && data.token[c + 1] !== ":") {
                            indent = indent + 1;
                            ei.push(a);
                        }
                        level[a - 1] = indent;
                        if (data.token[data.begin[a]] === "(" && (ei.length < 2 || ei[0] === ei[1])) {
                            destruct[destruct.length - 1] = false;
                            if (a - 2 === data.begin[a]) {
                                level[data.begin[a]] = indent - 1;
                            }
                            else {
                                level[data.begin[a]] = indent;
                            }
                            c = a - 2;
                            do {
                                if (data.types[c] === "end" && level[c - 1] > -1) {
                                    break;
                                }
                                if (level[c] > -1) {
                                    level[c] = level[c] + 1;
                                }
                                c = c - 1;
                            } while (c > data.begin[a]);
                        }
                    }
                    level.push(-10);
                    return;
                }
                if (ctoke === ":") {
                    if (data.stack[a] === "map" || data.types[a + 1] === "type" || data.types[a + 1] === "type_start") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (ternary.length > 0 && data.begin[ternary[ternary.length - 1]] === data.begin[a]) {
                        let c = a, d = data.begin[a];
                        do {
                            c = c - 1;
                            if (data.begin[c] === d) {
                                if (data.token[c] === "," || data.token[c] === ";") {
                                    level[a - 1] = -20;
                                    break;
                                }
                                if (data.token[c] === "?") {
                                    ternary.pop();
                                    endExtraInd();
                                    if (options.ternary_line === true) {
                                        level[a - 1] = -10;
                                    }
                                    level.push(-10);
                                    return;
                                }
                            }
                            else if (data.types[c] === "end") {
                                c = data.begin[c];
                            }
                        } while (c > d);
                    }
                    if (data.token[a - 2] === "where" && data.stack[a - 2] === data.stack[a]) {
                        level[a - 1] = -10;
                        level.push(-10);
                        return;
                    }
                    if (ltype === "reference" && data.token[data.begin[a]] !== "(" && data.token[data.begin[a]] !== "x(") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if ((ltoke === ")" || ltoke === "x)") && data.token[data.begin[a - 1] - 2] === "function") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.stack[a] === "attribute") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.token[data.begin[a]] !== "(" &&
                        data.token[data.begin[a]] !== "x(" &&
                        (ltype === "reference" || ltoke === ")" || ltoke === "]" || ltoke === "?") &&
                        (data.stack[a] === "map" || data.stack[a] === "class" || data.types[a + 1] === "reference") &&
                        (ternary.length === 0 || ternary[ternary.length - 1] < data.begin[a]) &&
                        ("mapclassexpressionmethodglobalparen".indexOf(data.stack[a]) > -1 || (data.types[a - 2] === "word" && data.stack[a] !== "switch"))) {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.stack[a] === "switch" && (ternary.length < 1 || ternary[ternary.length - 1] < data.begin[a])) {
                        level[a - 1] = -20;
                        if (options.case_space === true) {
                            level.push(-10);
                        }
                        else {
                            level.push(indent);
                        }
                        return;
                    }
                    if (data.stack[a] === "object") {
                        level[a - 1] = -20;
                    }
                    else if (ternary.length > 0) {
                        level[a - 1] = indent;
                    }
                    else {
                        level[a - 1] = -10;
                    }
                    level.push(-10);
                    return;
                }
                if (ctoke === "++" || ctoke === "--") {
                    if (ltype === "number" || ltype === "reference") {
                        level[a - 1] = -20;
                        level.push(-10);
                    }
                    else if (a < b - 1 && (data.types[a + 1] === "number" || data.types[a + 1] === "reference")) {
                        level.push(-20);
                    }
                    else {
                        level.push(-10);
                    }
                    return;
                }
                if (ctoke === "+") {
                    if (ltype === "start") {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = -10;
                    }
                    if (options.wrap < 1 || data.token[data.begin[a]] === "x(") {
                        level.push(-10);
                        return;
                    }
                    let aa = data.token[a + 1];
                    if (aa === undefined) {
                        level.push(-10);
                        return;
                    }
                    if (data.types[a - 1] === "operator" || data.types[a - 1] === "start") {
                        if (data.types[a + 1] === "reference" || aa === "(" || aa === "[") {
                            level.push(-20);
                            return;
                        }
                        if (Number(aa.slice(1, -1)) > -1 && ((/\d/).test(aa.charAt(1)) === true || aa.charAt(1) === "." || aa.charAt(1) === "-" || aa.charAt(1) === "+")) {
                            level.push(-20);
                            return;
                        }
                    }
                    return opWrap();
                }
                if (data.types[a - 1] !== "comment") {
                    if (ltoke === "(") {
                        level[a - 1] = -20;
                    }
                    else if (ctoke === "*" && data.stack[a] === "object" && data.types[a + 1] === "reference" && (ltoke === "{" || ltoke === ",")) {
                        level[a - 1] = indent;
                    }
                    else if (ctoke !== "?" || ternary.length === 0) {
                        level[a - 1] = -10;
                    }
                }
                if (ctoke.indexOf("=") > -1 && ctoke !== "==" && ctoke !== "===" && ctoke !== "!=" && ctoke !== "!==" && ctoke !== ">=" && ctoke !== "<=" && ctoke !== "=>" && data.stack[a] !== "method" && data.stack[a] !== "object") {
                    let c = a + 1, d = 0, e = false, f = "";
                    if ((data.token[data.begin[a]] === "(" || data.token[data.begin[a]] === "x(") && data.token[a + 1] !== "function") {
                        return;
                    }
                    do {
                        if (data.types[c] === "start") {
                            if (e === true && data.token[c] !== "[") {
                                if (assignlist[assignlist.length - 1] === true) {
                                    assignlist[assignlist.length - 1] = false;
                                }
                                break;
                            }
                            d = d + 1;
                        }
                        if (data.types[c] === "end") {
                            d = d - 1;
                        }
                        if (d < 0) {
                            if (assignlist[assignlist.length - 1] === true) {
                                assignlist[assignlist.length - 1] = false;
                            }
                            break;
                        }
                        if (d === 0) {
                            f = data.token[c];
                            if (e === true) {
                                if (data.types[c] === "operator" || data.token[c] === ";" || data.token[c] === "x;" || data.token[c] === "?" || data.token[c] === "var" || data.token[c] === "let" || data.token[c] === "const") {
                                    if (f !== undefined && (f === "?" || (f.indexOf("=") > -1 && f !== "==" && f !== "===" && f !== "!=" && f !== "!==" && f !== ">=" && f !== "<="))) {
                                        if (assignlist[assignlist.length - 1] === false) {
                                            assignlist[assignlist.length - 1] = true;
                                        }
                                    }
                                    if ((f === ";" || f === "x;" || f === "var" || f === "let" || f === "const") && assignlist[assignlist.length - 1] === true) {
                                        assignlist[assignlist.length - 1] = false;
                                    }
                                    break;
                                }
                                if (assignlist[assignlist.length - 1] === true && (f === "return" || f === "break" || f === "continue" || f === "throw")) {
                                    assignlist[assignlist.length - 1] = false;
                                }
                            }
                            if (f === ";" || f === "x;" || f === ",") {
                                e = true;
                            }
                        }
                        c = c + 1;
                    } while (c < b);
                    level.push(-10);
                    return;
                }
                if ((ctoke === "-" && ltoke === "return") || ltoke === "=") {
                    level.push(-20);
                    return;
                }
                if (ltype === "operator" && data.types[a + 1] === "reference" && ltoke !== "--" && ltoke !== "++" && ctoke !== "&&" && ctoke !== "||") {
                    level.push(-20);
                    return;
                }
                return opWrap();
            }, reference = function beautify_script_level_reference() {
                const hoist = function beautify_script_level_reference_hoist() {
                    let func = data.begin[a];
                    if (func < 0) {
                        scopes.push([data.token[a], -1]);
                    }
                    else {
                        if (data.stack[func + 1] !== "function") {
                            do {
                                func = data.begin[func];
                            } while (func > -1 && data.stack[func + 1] !== "function");
                        }
                        scopes.push([data.token[a], func]);
                    }
                };
                if (data.types[a - 1] === "comment") {
                    level[a - 1] = indent;
                }
                else if (ltype === "end" && ltoke !== ")" && data.token[data.begin[a - 1] - 1] !== ")") {
                    level[a - 1] = -10;
                }
                else if (ltype !== "separator" && ltype !== "start" && ltype !== "end" && ltype.indexOf("template_string") < 0) {
                    if (ltype === "word" || ltype === "operator" || ltype === "property" || ltype === "type" || ltype === "reference") {
                        level[a - 1] = -10;
                    }
                    else {
                        level[a - 1] = -20;
                    }
                }
                if (ltoke === "var" && data.lexer[a - 1] === lexer) {
                    // hoisted references following declaration keyword
                    hoist();
                }
                else if (ltoke === "function") {
                    scopes.push([data.token[a], a]);
                }
                else if (ltoke === "let" || ltoke === "const") {
                    // not hoisted references following declaration keyword
                    scopes.push([data.token[a], a]);
                }
                else if (data.stack[a] === "arguments") {
                    scopes.push([data.token[a], a]);
                }
                else if (ltoke === ",") {
                    // references following a comma, must be tested to see if a declaration list
                    let index = a;
                    do {
                        index = index - 1;
                    } while (index > data.begin[a] && data.token[index] !== "var" && data.token[index] !== "let" && data.token[index] !== "const");
                    if (data.token[index] === "var") {
                        hoist();
                    }
                    else if (data.token[index] === "let" || data.token[index] === "const") {
                        scopes.push([data.token[a], a]);
                    }
                }
                level.push(-10);
            }, separator = function beautify_script_level_separator() {
                const ei = (extraindent[extraindent.length - 1] === undefined)
                    ? []
                    : extraindent[extraindent.length - 1], propertybreak = function beautify_script_level_separator_propertybreak() {
                    if (options.method_chain > 0) {
                        let x = a, y = data.begin[a], z = [a], ify = (data.token[y - 1] === "if");
                        do {
                            x = x - 1;
                            if (data.types[x] === "end") {
                                x = data.begin[x];
                            }
                            if (data.begin[x] === y) {
                                if (data.types[x] === "string" && data.token[x].indexOf("${") === data.token[x].length - 2) {
                                    break;
                                }
                                if (data.token[x] === ".") {
                                    if (level[x - 1] > 0) {
                                        level[a - 1] = (ify === true)
                                            ? indent + 1
                                            : indent;
                                        return;
                                    }
                                    z.push(x);
                                }
                                else if (data.token[x] === ";" ||
                                    data.token[x] === "," ||
                                    data.types[x] === "operator" ||
                                    ((data.types[x] === "word" || data.types[x] === "reference") &&
                                        (data.types[x - 1] === "word" || data.types[x - 1] === "reference"))) {
                                    break;
                                }
                            }
                        } while (x > y);
                        if (z.length < options.method_chain) {
                            level[a - 1] = -20;
                            return;
                        }
                        x = 0;
                        y = z.length;
                        do {
                            level[z[x] - 1] = (ify === true)
                                ? indent + 1
                                : indent;
                            x = x + 1;
                        } while (x < y);
                        x = z[z.length - 1] - 1;
                        do {
                            if (level[x] > -1) {
                                level[x] = level[x] + 1;
                            }
                            x = x + 1;
                        } while (x < a);
                        indent = (ify === true)
                            ? indent + 2
                            : indent + 1;
                    }
                    level[a - 1] = indent;
                };
                if (ctoke === "::") {
                    level[a - 1] = -20;
                    level.push(-20);
                    return;
                }
                if (ctoke === ".") {
                    if (data.token[data.begin[a]] !== "(" && data.token[data.begin[a]] !== "x(" && ei.length > 0) {
                        if (data.stack[a] === "object" || data.stack[a] === "array") {
                            destructfix(true, false);
                        }
                        else {
                            destructfix(false, false);
                        }
                    }
                    if (options.method_chain === 0) {
                        // methodchain is 0 so methods and properties should be chained together
                        level[a - 1] = -20;
                    }
                    else if (options.method_chain < 0) {
                        if (data.lines[a] > 0) {
                            propertybreak();
                        }
                        else {
                            level[a - 1] = -20;
                        }
                    }
                    else {
                        // methodchain is greater than 0 and should break methods if the chain reaches this value
                        propertybreak();
                    }
                    level.push(-20);
                    return;
                }
                if (ctoke === ",") {
                    fixchain();
                    if (list[list.length - 1] === false && (data.stack[a] === "object" || data.stack[a] === "array" || data.stack[a] === "paren" || data.stack[a] === "expression" || data.stack[a] === "method")) {
                        list[list.length - 1] = true;
                        if (data.token[data.begin[a]] === "(") {
                            let aa = a;
                            do {
                                aa = aa - 1;
                                if (data.begin[aa] === data.begin[a] && data.token[aa] === "+" && level[aa] > -9) {
                                    level[aa] = level[aa] + 2;
                                }
                            } while (aa > data.begin[a]);
                        }
                    }
                    if (data.stack[a] === "array" && options.format_array === "indent") {
                        level[a - 1] = -20;
                        level.push(indent);
                        return;
                    }
                    if (data.stack[a] === "array" && options.format_array === "inline") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (data.stack[a] === "object" && options.format_object === "indent") {
                        level[a - 1] = -20;
                        level.push(indent);
                        return;
                    }
                    if (data.stack[a] === "object" && options.format_object === "inline") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    if (ei.length > 0) {
                        if (ei[ei.length - 1] > -1) {
                            endExtraInd();
                        }
                        level[a - 1] = -20;
                        level.push(indent);
                        return;
                    }
                    if (data.token[a - 2] === ":" && data.token[a - 4] === "where") {
                        level[a - 1] = -20;
                        level.push(-10);
                        return;
                    }
                    level[a - 1] = -20;
                    if (data.types[a + 1] !== "end") {
                        itemcount[itemcount.length - 1] = itemcount[itemcount.length - 1] + 1;
                    }
                    if ((data.token[data.begin[a]] === "(" || data.token[data.begin[a]] === "x(") && options.language !== "jsx" && data.stack[a] !== "global" && ((data.types[a - 1] !== "string" && data.types[a - 1] !== "number") || data.token[a - 2] !== "+" || (data.types[a - 1] === "string" && data.types[a - 1] !== "number" && data.token[a - 2] === "+" && data.types[a - 3] !== "string" && data.types[a - 3] !== "number"))) {
                        level.push(-10);
                        return;
                    }
                    if (ltype === "reference" && data.types[a - 2] === "word" && "var-let-const-from".indexOf(data.token[a - 2]) < 0 && (data.types[a - 3] === "end" || data.token[a - 3] === ";")) {
                        wordlist[wordlist.length - 1] = true;
                        level.push(-10);
                        return;
                    }
                    if (wordlist[wordlist.length - 1] === true || data.stack[a] === "notation") {
                        level.push(-10);
                        return;
                    }
                    if (itemcount[itemcount.length - 1] > 3 && (data.stack[a] === "array" || data.stack[a] === "object")) {
                        if (destruct[destruct.length - 1] === true) {
                            destructfix(true, true);
                        }
                        level[a - 1] = -20;
                        if (arrbreak[arrbreak.length - 1] === true) {
                            level.push(indent);
                            return;
                        }
                        let begin = data.begin[a], c = a;
                        do {
                            if (data.types[c] === "end") {
                                c = data.begin[c];
                            }
                            else {
                                if (data.token[c] === "," && data.types[c + 1] !== "comment") {
                                    level[c] = indent;
                                }
                            }
                            c = c - 1;
                        } while (c > begin);
                        level[begin] = indent;
                        arrbreak[arrbreak.length - 1] = true;
                        return;
                    }
                    if (data.stack[a] === "object") {
                        if (destruct[destruct.length - 1] === true && data.types[data.begin[a] - 1] !== "word" && data.types[data.begin[a] - 1] !== "reference" && data.token[data.begin[a] - 1] !== "(" && data.token[data.begin[a] - 1] !== "x(") {
                            const bb = data.begin[a];
                            let aa = a - 1;
                            do {
                                if (data.begin[aa] === bb) {
                                    if (data.token[aa] === ",") {
                                        break;
                                    }
                                    if (data.token[aa] === ":") {
                                        destructfix(true, false);
                                        break;
                                    }
                                }
                                aa = aa - 1;
                            } while (aa > bb);
                        }
                    }
                    if ((data.types[a - 1] === "word" || data.types[a - 1] === "reference") && data.token[a - 2] === "for") {
                        //This is for Volt templates
                        level.push(-10);
                        return;
                    }
                    if (destruct[destruct.length - 1] === false || (data.token[a - 2] === "+" && (ltype === "string" || ltype === "number") && level[a - 2] > 0 && (ltoke.charAt(0) === "\"" || ltoke.charAt(0) === "'"))) {
                        if (data.stack[a] === "method") {
                            if (data.token[a - 2] === "+" && (ltoke.charAt(0) === "\"" || ltoke.charAt(0) === "'") && (data.token[a - 3].charAt(0) === "\"" || data.token[a - 3].charAt(0) === "'")) {
                                level.push(indent + 2);
                                return;
                            }
                            if (data.token[a - 2] !== "+") {
                                level.push(-10);
                                return;
                            }
                        }
                        level.push(indent);
                        return;
                    }
                    if (destruct[destruct.length - 1] === true && data.stack[a] !== "object") {
                        level.push(-10);
                        return;
                    }
                    if (itemcount[itemcount.length - 1] < 4 && (data.stack[a] === "array" || data.stack[a] === "object")) {
                        level.push(-10);
                        return;
                    }
                    level.push(indent);
                    return;
                }
                if (ctoke === ";" || ctoke === "x;") {
                    fixchain();
                    if (data.token[a + 1] !== undefined && data.types[a + 1].indexOf("attribute") > 0 && data.types[a + 1].indexOf("end") > 0) {
                        level[a - 1] = -20;
                        level.push(indent - 1);
                        return;
                    }
                    if (varindex[varindex.length - 1] > -1 && data.stack[varindex[varindex.length - 1]] !== "expression") {
                        let aa = a;
                        do {
                            aa = aa - 1;
                            if (data.token[aa] === ";") {
                                break;
                            }
                            if (data.token[aa] === ",") {
                                indent = indent - 1;
                                break;
                            }
                            if (data.types[aa] === "end") {
                                aa = data.begin[aa];
                            }
                        } while (aa > 0 && aa > data.begin[a]);
                    }
                    varindex[varindex.length - 1] = -1;
                    endExtraInd();
                    if (data.token[data.begin[a] - 1] !== "for") {
                        destructfix(false, false);
                    }
                    if (ctoke === "x;") {
                        scolon = scolon + 1;
                    }
                    wordlist[wordlist.length - 1] = false;
                    level[a - 1] = -20;
                    if (data.begin[a] > 0 && data.token[data.begin[a] - 1] === "for" && data.stack[a] !== "for") {
                        level.push(-10);
                        return;
                    }
                    level.push(indent);
                    return;
                }
                level.push(-20);
            }, start = function beautify_script_level_start() {
                const deep = data.stack[a + 1], deeper = (a === 0)
                    ? data.stack[a]
                    : data.stack[a - 1];
                if (ltoke === ")" || ((deeper === "object" || deeper === "array") && ltoke !== "]")) {
                    if (deep !== "method" || (deep === "method" && data.token[a + 1] !== ")" && data.token[a + 2] !== ")")) {
                        if (ltoke === ")" && (deep !== "function" || data.token[data.begin[data.begin[a - 1] - 1]] === "(" || data.token[data.begin[data.begin[a - 1] - 1]] === "x(")) {
                            destructfix(false, false);
                        }
                        else if (data.types[a + 1] !== "end" && data.types[a + 2] !== "end") {
                            destructfix(true, false);
                        }
                    }
                }
                list.push(false);
                extraindent.push([]);
                assignlist.push(false);
                arrbreak.push(false);
                wordlist.push(false);
                itemcount.push(0);
                if (options.never_flatten === true || (deep === "array" && options.format_array === "indent") || options.language === "qml" || deep === "attribute" || ltype === "generic" || (deep === "class" && ltoke !== "(" && ltoke !== "x(") || (ctoke === "[" && data.token[a + 1] === "function")) {
                    destruct.push(false);
                }
                else {
                    if (deep === "expression" || deep === "method") {
                        destruct.push(true);
                    }
                    else if ((deep === "object" || deep === "class") && (ltoke === "(" || ltoke === "x(" || ltype === "word" || ltype === "reference")) {
                        //array or object literal following `return` or `(`
                        destruct.push(true);
                    }
                    else if (deep === "array" || ctoke === "(" || ctoke === "x(") {
                        //array, method, paren
                        destruct.push(true);
                    }
                    else if (ctoke === "{" && deep === "object" && ltype !== "operator" && ltype !== "start" && ltype !== "string" && ltype !== "number" && deeper !== "object" && deeper !== "array" && a > 0) {
                        //curly brace not in a list and not assigned
                        destruct.push(true);
                    }
                    else {
                        //not destructured (multiline)
                        destruct.push(false);
                    }
                }
                if (ctoke !== "(" && ctoke !== "x(" && data.stack[a + 1] !== "attribute") {
                    indent = indent + 1;
                }
                if (ctoke === "{" || ctoke === "x{") {
                    varindex.push(-1);
                    if (data.types[a - 1] !== "comment") {
                        if (ltype === "markup") {
                            level[a - 1] = indent;
                        }
                        else if (options.braces === true && ltype !== "operator" && ltoke !== "return") {
                            level[a - 1] = indent - 1;
                        }
                        else if (data.stack[a + 1] !== "block" && (deep === "function" || ltoke === ")" || ltoke === "x)" || ltoke === "," || ltoke === "}" || ltype === "markup")) {
                            level[a - 1] = -10;
                        }
                        else if (ltoke === "{" || ltoke === "x{" || ltoke === "[" || ltoke === "}" || ltoke === "x}") {
                            level[a - 1] = indent - 1;
                        }
                    }
                    if (deep === "object") {
                        if (options.format_object === "indent") {
                            destruct[destruct.length - 1] = false;
                            level.push(indent);
                            return;
                        }
                        if (options.format_object === "inline") {
                            destruct[destruct.length - 1] = true;
                            level.push(-20);
                            return;
                        }
                    }
                    if (deep === "switch") {
                        if (options.no_case_indent === true) {
                            level.push(indent - 1);
                            return;
                        }
                        indent = indent + 1;
                        level.push(indent);
                        return;
                    }
                    if (destruct[destruct.length - 1] === true) {
                        if (ltype !== "word" && ltype !== "reference") {
                            level.push(-20);
                            return;
                        }
                    }
                    level.push(indent);
                    return;
                }
                if (ctoke === "(" || ctoke === "x(") {
                    if (options.wrap > 0 && ctoke === "(" && data.token[a + 1] !== ")") {
                        count.push(1);
                    }
                    if (ltoke === "-" && (data.token[a - 2] === "(" || data.token[a - 2] === "x(")) {
                        level[a - 2] = -20;
                    }
                    if (ltype === "end" && deeper !== "if" && deeper !== "for" && deeper !== "catch" && deeper !== "else" && deeper !== "do" && deeper !== "try" && deeper !== "finally" && deeper !== "catch") {
                        if (data.types[a - 1] === "comment") {
                            level[a - 1] = indent;
                        }
                        else {
                            level[a - 1] = -20;
                        }
                    }
                    if (ltoke === "async") {
                        level[a - 1] = -10;
                    }
                    else if (deep === "method" || (data.token[a - 2] === "function" && ltype === "reference")) {
                        if (ltoke === "import" || ltoke === "in" || options.function_name === true) {
                            level[a - 1] = -10;
                        }
                        else if ((ltoke === "}" && data.stack[a - 1] === "function") || ltype === "word" || ltype === "reference" || ltype === "property") {
                            level[a - 1] = -20;
                        }
                        else if (deeper !== "method" && deep !== "method") {
                            level[a - 1] = indent;
                        }
                    }
                    if (ltoke === "+" && (data.token[a - 2].charAt(0) === "\"" || data.token[a - 2].charAt(0) === "'")) {
                        level.push(indent);
                        return;
                    }
                    if (ltoke === "}" || ltoke === "x}") {
                        level.push(-20);
                        return;
                    }
                    if ((ltoke === "-" && (a < 2 || (data.token[a - 2] !== ")" && data.token[a - 2] !== "x)" && data.token[a - 2] !== "]" && data.types[a - 2] !== "reference" && data.types[a - 2] !== "string" && data.types[a - 2] !== "number"))) || (options.space === false && ltoke === "function")) {
                        level[a - 1] = -20;
                    }
                    level.push(-20);
                    return;
                }
                if (ctoke === "[") {
                    if (ltoke === "[") {
                        list[list.length - 2] = true;
                    }
                    if (ltoke === "return" || ltoke === "var" || ltoke === "let" || ltoke === "const") {
                        level[a - 1] = -10;
                    }
                    else if (data.types[a - 1] !== "comment" && data.stack[a - 1] !== "attribute" && (ltype === "end" || ltype === "word" || ltype === "reference")) {
                        level[a - 1] = -20;
                    }
                    else if (ltoke === "[" || ltoke === "{" || ltoke === "x{") {
                        level[a - 1] = indent - 1;
                    }
                    if (data.stack[a] === "attribute") {
                        level.push(-20);
                        return;
                    }
                    if (options.format_array === "indent") {
                        destruct[destruct.length - 1] = false;
                        level.push(indent);
                        return;
                    }
                    if (options.format_array === "inline") {
                        destruct[destruct.length - 1] = true;
                        level.push(-20);
                        return;
                    }
                    if (deep === "method" || destruct[destruct.length - 1] === true) {
                        level.push(-20);
                        return;
                    }
                    let c = a + 1;
                    do {
                        if (data.token[c] === "]") {
                            level.push(-20);
                            return;
                        }
                        if (data.token[c] === ",") {
                            level.push(indent);
                            return;
                        }
                        c = c + 1;
                    } while (c < b);
                    level.push(-20);
                    return;
                }
            }, string = function beautify_script_level_string() {
                if (ctoke.length === 1) {
                    level.push(-20);
                    if (data.lines[a] === 0) {
                        level[a - 1] = -20;
                    }
                }
                else if (ctoke.indexOf("#!/") === 0) {
                    level.push(indent);
                }
                else {
                    level.push(-10);
                }
                if ((ltoke === "," || ltype === "start") && (data.stack[a] === "object" || data.stack[a] === "array") && destruct[destruct.length - 1] === false && a > 0) {
                    level[a - 1] = indent;
                }
            }, template = function beautify_script_level_template() {
                if (ctype === "template_else") {
                    level[a - 1] = indent - 1;
                    level.push(indent);
                }
                else if (ctype === "template_start") {
                    indent = indent + 1;
                    if (data.lines[a - 1] < 1) {
                        level[a - 1] = -20;
                    }
                    if (data.lines[a] > 0 || ltoke.length === 1 && ltype === "string") {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
                else if (ctype === "template_end") {
                    indent = indent - 1;
                    if (ltype === "template_start" || data.lines[a - 1] < 1) {
                        level[a - 1] = -20;
                    }
                    else {
                        level[a - 1] = indent;
                    }
                    if (data.lines[a] > 0) {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
                else if (ctype === "template") {
                    if (data.lines[a] > 0) {
                        level.push(indent);
                    }
                    else {
                        level.push(-20);
                    }
                }
            }, templateString = function beautify_script_level_templateString() {
                if (ctype === "template_string_start") {
                    indent = indent + 1;
                    level.push(indent);
                }
                else if (ctype === "template_string_else") {
                    fixchain();
                    level[a - 1] = indent - 1;
                    level.push(indent);
                }
                else {
                    fixchain();
                    indent = indent - 1;
                    level[a - 1] = indent;
                    level.push(-10);
                }
                if (a > 2 && (data.types[a - 2] === "template_string_else" || data.types[a - 2] === "template_string_start")) {
                    if (options.brace_padding === true) {
                        level[a - 2] = -10;
                        level[a - 1] = -10;
                    }
                    else {
                        level[a - 2] = -20;
                        level[a - 1] = -20;
                    }
                }
            }, types = function beautify_script_level_types() {
                if (data.token[a - 1] === "," || (data.token[a - 1] === ":" && data.stack[a - 1] !== "data_type")) {
                    level[a - 1] = -10;
                }
                else {
                    level[a - 1] = -20;
                }
                if (data.types[a] === "type" || data.types[a] === "type_end") {
                    level.push(-10);
                }
                if (data.types[a] === "type_start") {
                    level.push(-20);
                }
            }, word = function beautify_script_level_word() {
                if ((ltoke === ")" || ltoke === "x)") && data.stack[a] === "class" && (data.token[data.begin[a - 1] - 1] === "static" || data.token[data.begin[a - 1] - 1] === "final" || data.token[data.begin[a - 1] - 1] === "void")) {
                    level[a - 1] = -10;
                    level[data.begin[a - 1] - 1] = -10;
                }
                if (ltoke === "]") {
                    level[a - 1] = -10;
                }
                if (ltoke === "}" || ltoke === "x}") {
                    level[a - 1] = indent;
                }
                if (ctoke === "else" && ltoke === "}") {
                    if (data.token[a - 2] === "x}") {
                        level[a - 3] = level[a - 3] - 1;
                    }
                    if (options.braces === true) {
                        level[a - 1] = indent;
                    }
                }
                if (ctoke === "new") {
                    let apiword = [
                        "ActiveXObject",
                        "ArrayBuffer",
                        "AudioContext",
                        "Canvas",
                        "CustomAnimation",
                        "DOMParser",
                        "DataView",
                        "Date",
                        "Error",
                        "EvalError",
                        "FadeAnimation",
                        "FileReader",
                        "Flash",
                        "Float32Array",
                        "Float64Array",
                        "FormField",
                        "Frame",
                        "Generator",
                        "HotKey",
                        "Image",
                        "Iterator",
                        "Intl",
                        "Int16Array",
                        "Int32Array",
                        "Int8Array",
                        "InternalError",
                        "Loader",
                        "Map",
                        "MenuItem",
                        "MoveAnimation",
                        "Notification",
                        "ParallelArray",
                        "Point",
                        "Promise",
                        "Proxy",
                        "RangeError",
                        "Rectangle",
                        "ReferenceError",
                        "Reflect",
                        "RegExp",
                        "ResizeAnimation",
                        "RotateAnimation",
                        "Set",
                        "SQLite",
                        "ScrollBar",
                        "Set",
                        "Shadow",
                        "StopIteration",
                        "Symbol",
                        "SyntaxError",
                        "Text",
                        "TextArea",
                        "Timer",
                        "TypeError",
                        "URL",
                        "Uint16Array",
                        "Uint32Array",
                        "Uint8Array",
                        "Uint8ClampedArray",
                        "URIError",
                        "WeakMap",
                        "WeakSet",
                        "Web",
                        "Window",
                        "XMLHttpRequest"
                    ];
                    if (apiword.indexOf(data.token[a + 1]) < 0) {
                        news = news + 1;
                    }
                    if (options.jsscope !== "none") {
                        data.token[a] = "<strong class='new'>new</strong>";
                    }
                }
                if (ctoke === "from" && ltype === "end" && a > 0 && (data.token[data.begin[a - 1] - 1] === "import" || data.token[data.begin[a - 1] - 1] === ",")) {
                    level[a - 1] = -10;
                }
                if (ctoke === "this" && options.jsscope !== "none") {
                    data.token[a] = "<strong class=\"new\">this</strong>";
                }
                if (ctoke === "function") {
                    if (options.space === false && a < b - 1 && (data.token[a + 1] === "(" || data.token[a + 1] === "x(")) {
                        level.push(-20);
                        return;
                    }
                    level.push(-10);
                    return;
                }
                if (ltoke === "-" && a > 1) {
                    if (data.types[a - 2] === "operator" || data.token[a - 2] === ",") {
                        level[a - 1] = -20;
                    }
                    else if (data.types[a - 2] === "start") {
                        level[a - 2] = -20;
                        level[a - 1] = -20;
                    }
                }
                else if (ctoke === "while" && (ltoke === "}" || ltoke === "x}")) {
                    //verify if this is a do/while block
                    let c = a - 1, d = 0;
                    do {
                        if (data.token[c] === "}" || data.token[c] === "x}") {
                            d = d + 1;
                        }
                        if (data.token[c] === "{" || data.token[c] === "x{") {
                            d = d - 1;
                        }
                        if (d === 0) {
                            if (data.token[c - 1] === "do") {
                                level[a - 1] = -10;
                                break;
                            }
                            level[a - 1] = indent;
                            break;
                        }
                        c = c - 1;
                    } while (c > -1);
                }
                else if (ctoke === "in" || (((ctoke === "else" && options.else_line === false && options.braces === false) || ctoke === "catch") && (ltoke === "}" || ltoke === "x}"))) {
                    level[a - 1] = -10;
                }
                else if (ctoke === "var" || ctoke === "let" || ctoke === "const") {
                    varindex[varindex.length - 1] = a;
                    if (ltype === "end") {
                        level[a - 1] = indent;
                    }
                    if (data.token[data.begin[a] - 1] !== "for") {
                        let c = a + 1, d = 0;
                        do {
                            if (data.types[c] === "end") {
                                d = d - 1;
                            }
                            if (data.types[c] === "start") {
                                d = d + 1;
                            }
                            if (d < 0 || (d === 0 && (data.token[c] === ";" || data.token[c] === ","))) {
                                break;
                            }
                            c = c + 1;
                        } while (c < b);
                        if (data.token[c] === ",") {
                            indent = indent + 1;
                        }
                    }
                    level.push(-10);
                    return;
                }
                if ((ctoke === "default" || ctoke === "case") && ltype !== "word" && data.stack[a] === "switch") {
                    level[a - 1] = indent - 1;
                    level.push(-10);
                    return;
                }
                if (ctoke === "catch" && ltoke === ".") {
                    level[a - 1] = -20;
                    level.push(-20);
                    return;
                }
                if (ctoke === "catch" || ctoke === "finally") {
                    level[a - 1] = -10;
                    level.push(-10);
                    return;
                }
                if (options.brace_padding === false && a < b - 1 && data.token[a + 1].charAt(0) === "}") {
                    level.push(-20);
                    return;
                }
                if (data.stack[a] === "object" && (ltoke === "{" || ltoke === ",") && (data.token[a + 1] === "(" || data.token[a + 1] === "x(")) {
                    level.push(-20);
                    return;
                }
                if (data.types[a - 1] === "comment" && data.token[data.begin[a]] === "(") {
                    level[a - 1] = indent + 1;
                }
                level.push(-10);
            };
            if (options.language === "titanium") {
                indent = indent - 1;
            }
            do {
                if (data.lexer[a] === lexer) {
                    ctype = data.types[a];
                    ctoke = data.token[a];
                    if (ctype === "comment") {
                        comment();
                    }
                    else if (ctype === "regex") {
                        level.push(-20);
                    }
                    else if (ctype === "string") {
                        string();
                    }
                    else if (ctype.indexOf("template_string") === 0) {
                        templateString();
                    }
                    else if (ctype === "separator") {
                        separator();
                    }
                    else if (ctype === "start") {
                        start();
                    }
                    else if (ctype === "end") {
                        end();
                    }
                    else if (ctype === "type" || ctype === "type_start" || ctype === "type_end") {
                        types();
                    }
                    else if (ctype === "operator") {
                        operator();
                    }
                    else if (ctype === "word") {
                        word();
                    }
                    else if (ctype === "reference") {
                        reference();
                    }
                    else if (ctype === "markup") {
                        markup();
                    }
                    else if (ctype.indexOf("template") === 0) {
                        template();
                    }
                    else if (ctype === "generic") {
                        if (ltoke !== "return" && ltoke.charAt(0) !== "#" && ltype !== "operator" && ltoke !== "public" && ltoke !== "private" && ltoke !== "static" && ltoke !== "final" && ltoke !== "implements" && ltoke !== "class" && ltoke !== "void") {
                            level[a - 1] = -20;
                        }
                        if (data.token[a + 1] === "(" || data.token[a + 1] === "x(") {
                            level.push(-20);
                        }
                        else {
                            level.push(-10);
                        }
                    }
                    else {
                        level.push(-10);
                    }
                    if (ctype !== "comment") {
                        ltype = ctype;
                        ltoke = ctoke;
                    }
                    if (count.length > 0 && data.token[a] !== ")") {
                        if (data.types[a] === "comment" && count[count.length - 1] > -1) {
                            count[count.length - 1] = options.wrap + 1;
                        }
                        else if (level[a] > -1 || (data.token[a].charAt(0) === "`" && data.token[a].indexOf("\n") > 0)) {
                            count[count.length - 1] = -1;
                        }
                        else if (count[count.length - 1] > -1) {
                            count[count.length - 1] = count[count.length - 1] + data.token[a].length;
                            if (level[a] === -10) {
                                count[count.length - 1] = count[count.length - 1] + 1;
                            }
                        }
                    }
                }
                else {
                    external();
                }
                a = a + 1;
            } while (a < b);
            return level;
        }()), output = (function beautify_script_output() {
            const build = [], tab = (function beautify_script_output_tab() {
                const ch = options.indent_char, tabby = [];
                let index = options.indent_size;
                if (typeof index !== "number" || index < 1) {
                    return "";
                }
                do {
                    tabby.push(ch);
                    index = index - 1;
                } while (index > 0);
                return tabby.join("");
            }()), lf = (options.crlf === true)
                ? "\r\n"
                : "\n", pres = options.preserve + 1, nl = function beautify_script_output_outnl(tabs) {
                const linesout = [], total = (function beautify_script_output_outnl_total() {
                    if (a === b - 1) {
                        return 1;
                    }
                    if (data.lines[a + 1] - 1 > pres) {
                        return pres;
                    }
                    if (data.lines[a + 1] > 1) {
                        return data.lines[a + 1] - 1;
                    }
                    return 1;
                }());
                let index = 0;
                if (tabs < 0) {
                    tabs = 0;
                }
                do {
                    linesout.push(lf);
                    index = index + 1;
                } while (index < total);
                if (tabs > 0) {
                    index = 0;
                    do {
                        linesout.push(tab);
                        index = index + 1;
                    } while (index < tabs);
                }
                return linesout.join("");
            }, reference = function beautify_script_output_reference() {
                let s = scopes.length, t = 0;
                const applyScope = function beautify_script_output_reference_applyScope() {
                    // applyScope function exists to prevent presenting spaces as part of reference names if option 'vertical' is set to true
                    let token = data.token[a], space = "";
                    const spaceIndex = token.indexOf(" "), scopeValue = (function beautify_script_output_reference_applyScope_scopeValue() {
                        let begin = data.begin[scopes[s][1]], value = "";
                        if (scopes[s][1] < 0 || begin < 0) {
                            return "0";
                        }
                        if (data.token[scopes[s][1]] !== undefined && data.token[scopes[s][1]].indexOf("<em") === 0) {
                            begin = scopes[s][1];
                        }
                        else if (data.token[begin] === undefined || data.token[begin].indexOf("<em") !== 0) {
                            do {
                                begin = data.begin[begin];
                            } while (begin > 0 && data.token[begin].indexOf("<em") !== 0);
                        }
                        if (begin < 0) {
                            value = "0";
                        }
                        else {
                            value = data.token[begin];
                            value = value.slice(value.indexOf("class=") + 8);
                            value = value.slice(0, value.indexOf(">") - 1);
                        }
                        if (data.stack[a] === "arguments" || data.stack[scopes[s][1]] === "arguments") {
                            return String(Number(value) + 1);
                        }
                        return value;
                    }());
                    if (spaceIndex > 0) {
                        space = token.slice(spaceIndex);
                        token = token.slice(0, spaceIndex);
                    }
                    data.token[a] = `prettydiffltem class="s${scopeValue}"prettydiffgt${token}prettydifflt/emprettydiffgt${space}`;
                    build.push(data.token[a]);
                };
                if (scopes.length < 1) {
                    return;
                }
                do {
                    s = s - 1;
                    if (data.token[a].replace(/\s+/, "") === scopes[s][0]) {
                        if (scopes[s][1] <= a) {
                            t = scopes[s][1];
                            if (t < 0 || data.stack[a] === "arguments" || t === a) {
                                applyScope();
                                return;
                            }
                            do {
                                t = t + 1;
                                if (data.types[t] === "end" && data.begin[t] === scopes[s][1]) {
                                    break;
                                }
                            } while (t < a);
                            if (t === a) {
                                applyScope();
                                return;
                            }
                        }
                        else if (data.begin[scopes[s][1]] < data.begin[a]) {
                            applyScope();
                            return;
                        }
                    }
                } while (s > 0);
                build.push(data.token[a]);
            }, invisibles = ["x;", "x}", "x{", "x(", "x)"];
            let a = prettydiff.start, external = "", lastLevel = options.indent_level;
            if (options.vertical === true) {
                const vertical = function beautify_script_output_vertical(end) {
                    let longest = 0, complex = 0, aa = end - 1, bb = 0, cc = 0;
                    const begin = data.begin[a], list = [];
                    do {
                        if ((data.begin[aa] === begin || data.token[aa] === "]" || data.token[aa] === ")") && ((data.token[aa + 1] === ":" && data.stack[aa] === "object") || data.token[aa + 1] === "=")) {
                            bb = aa;
                            complex = 0;
                            do {
                                if (data.begin[bb] === begin) {
                                    if (data.token[bb] === "," || data.token[bb] === ";" || data.token[bb] === "x;" || (levels[bb] > -1 && data.types[bb] !== "comment")) {
                                        if (data.token[bb + 1] === ".") {
                                            complex = complex + (options.indent_size * options.indent_char.length);
                                        }
                                        break;
                                    }
                                }
                                else if (levels[bb] > -1) {
                                    break;
                                }
                                if (data.types[bb] !== "comment") {
                                    if (levels[bb - 1] === -10) {
                                        complex = complex + 1;
                                    }
                                    complex = data.token[bb].length + complex;
                                }
                                bb = bb - 1;
                            } while (bb > begin);
                            cc = bb;
                            if (data.token[cc] === "," && data.token[aa + 1] === "=") {
                                do {
                                    if (data.types[cc] === "end") {
                                        cc = data.begin[cc];
                                    }
                                    if (data.begin[cc] === begin) {
                                        if (data.token[cc] === ";" || data.token[cc] === "x;") {
                                            break;
                                        }
                                        if (data.token[cc] === "var" || data.token[cc] === "const" || data.token[cc] === "let") {
                                            complex = complex + (options.indent_size * options.indent_char.length);
                                            break;
                                        }
                                    }
                                    cc = cc - 1;
                                } while (cc > begin);
                            }
                            if (complex > longest) {
                                longest = complex;
                            }
                            list.push([aa, complex]);
                            aa = bb;
                        }
                        else if (data.types[aa] === "end") {
                            aa = data.begin[aa];
                        }
                        aa = aa - 1;
                    } while (aa > begin);
                    aa = list.length;
                    if (aa > 0) {
                        do {
                            aa = aa - 1;
                            bb = list[aa][1];
                            if (bb < longest) {
                                do {
                                    data.token[list[aa][0]] = data.token[list[aa][0]] + " ";
                                    bb = bb + 1;
                                } while (bb < longest);
                            }
                        } while (aa > 0);
                    }
                };
                a = b;
                do {
                    a = a - 1;
                    if (data.lexer[a] === "script") {
                        if (data.token[a] === "}" && data.token[a - 1] !== "{" && levels[data.begin[a]] > 0) {
                            vertical(a);
                        }
                    }
                    else {
                        a = data.begin[a];
                    }
                } while (a > 0);
            }
            if (options.jsscope !== "none" && options.jsscope !== "interim") {
                let linecount = 1, last = "", scope = 0, scoped = [], indent = options.indent_level, foldindex = [], start = prettydiff.start, exlines = [], exlevel = 0, exline;
                const code = [], optionValue = options.jsscope, foldstart = function beautify_script_output_scope_foldstart() {
                    let index = code.length;
                    do {
                        index = index - 1;
                    } while (index > 0 && code[index] !== "<li>");
                    if (code[index] === "<li>") {
                        code[index] = `<li class="fold" title="folds from line ${linecount} to line xxx">`;
                        code[index + 1] = `-${code[index + 1]}`;
                        foldindex.push([index, a]);
                    }
                }, foldend = function beautify_script_output_scope_foldend() {
                    const lastfold = foldindex[foldindex.length - 1];
                    if (data.types[a] === "end" && lastfold[1] === data.begin[a]) {
                        code[lastfold[0]] = code[lastfold[0]].replace("xxx", String(linecount));
                        foldindex.pop();
                    }
                    else if (data.types[a - 1] === "comment") {
                        let endfold = (a === b - 1)
                            ? linecount
                            : linecount - 1;
                        code[lastfold[0]] = code[lastfold[0]].replace("xxx", String(endfold));
                        foldindex.pop();
                    }
                }, 
                // splits block comments, which are single tokens, into multiple lines of output
                blockline = function beautify_script_output_scope_blockline(x) {
                    const commentLines = x.split(lf), ii = commentLines.length;
                    let hh = 0;
                    if (levels[a] > 0) {
                        do {
                            commentLines[0] = tab + commentLines[0];
                            hh = hh + 1;
                        } while (hh < levels[a]);
                    }
                    hh = 1;
                    build.push(commentLines[0]);
                    if (hh < ii) {
                        do {
                            linecount = linecount + 1;
                            code.push("<li>");
                            code.push(String(linecount));
                            code.push("</li>");
                            build.push(`<em class="line">&#xA;</em></li><li class="c0">${commentLines[hh]}`);
                            hh = hh + 1;
                        } while (hh < ii);
                    }
                }, 
                //a function for calculating indentation after each new line
                nlscope = function beautify_script_output_scope_nlscope(x) {
                    let dd = 0;
                    const total = (function beautify_script_output_scope_nlscope_total() {
                        if (a === b - 1) {
                            return 0;
                        }
                        if (data.lines[a + 1] - 1 > pres) {
                            return pres - 1;
                        }
                        if (data.lines[a + 1] > 1) {
                            return data.lines[a + 1] - 2;
                        }
                        return 0;
                    }()), scopepush = function beautify_script_output_scope_nlscope_scopepush() {
                        let aa = 0, bb = 0;
                        if (x > 0) {
                            do {
                                build.push(`<span class="l${bb}">${tab}</span>`);
                                if (scoped[aa] === true) {
                                    bb = bb + 1;
                                }
                                aa = aa + 1;
                            } while (aa < x);
                        }
                    };
                    if (data.token[a] !== "x}" || (data.token[a] === "x}" && data.token[a + 1] !== "}")) {
                        let index = 0;
                        if (total > 0) {
                            do {
                                linecount = linecount + 1;
                                code.push("<li>");
                                code.push(String(linecount));
                                code.push("</li>");
                                build.push(`<em class="line">&#xA;</em></li><li class="s0">`);
                                index = index + 1;
                            } while (index < total);
                        }
                        linecount = linecount + 1;
                        code.push("<li>");
                        code.push(String(linecount));
                        code.push("</li>");
                        if (a < b - 1 && data.types[a + 1] === "comment") {
                            build.push(`<em class="line">&#xA;</em></li><li class="c0">`);
                            do {
                                build.push(tab);
                                dd = dd + 1;
                            } while (dd < levels[a]);
                        }
                        else {
                            if (data.token[a + 1] === "}" && data.stack[a + 1] !== "object" && data.stack[a + 1] !== "class") {
                                build.push(`<em class="line">&#xA;</em></li><li class="l${scope - 1}">`);
                            }
                            else {
                                build.push(`<em class="line">&#xA;</em></li><li class="l${scope}">`);
                            }
                            scopepush();
                        }
                    }
                    else {
                        scopepush();
                    }
                }, multiline = function beautify_script_output_scope_multiline(x) {
                    const temparray = x.split(lf), d = temparray.length;
                    let c = 1;
                    build.push(temparray[0]);
                    do {
                        nlscope(indent);
                        build.push(temparray[c]);
                        c = c + 1;
                    } while (c < d);
                };
                options.jsscope = "interim";
                code.push("<div class=\"beautify\" data-prettydiff-ignore=\"true\"><ol class=\"count\">");
                code.push("<li>");
                code.push("1");
                code.push("</li>");
                if (data.types[a] === "comment" && data.token[a].indexOf("/*") === 0) {
                    build.push(`<ol class="data"><li class="c0">${tab}`);
                }
                else {
                    build.push("<ol class=\"data\"><li>");
                }
                a = 0;
                if (indent > 0) {
                    do {
                        build.push(tab);
                        a = a + 1;
                    } while (a < indent);
                }
                scope = 0;
                // this loops combines the white space as determined from the algorithm with the
                // tokens to create the output
                a = prettydiff.start;
                do {
                    if (data.lexer[a] === lexer || prettydiff.beautify[data.lexer[a]] === undefined) {
                        if (levels[a] > -1 && a < b - 1) {
                            if (levels[a] < scoped.length) {
                                do {
                                    scoped.pop();
                                } while (levels[a] < scoped.length);
                            }
                        }
                        if (data.types[a] === "comment" && data.token[a].indexOf("/*") === 0) {
                            blockline(data.token[a]);
                        }
                        else if (invisibles.indexOf(data.token[a]) < 0) {
                            if (data.types[a] === "start" && (levels[a] > -1 || data.types[a + 1] === "comment")) {
                                foldstart();
                            }
                            else if (data.token[a].indexOf("//") === 0 && a < b - 1 && data.token[a + 1].indexOf("//") === 0 && data.token[a - 1].indexOf("//") !== 0 && levels[a - 1] > -1) {
                                foldstart();
                            }
                            else if (foldindex.length > 0) {
                                if (data.types[a] === "end") {
                                    foldend();
                                }
                                else if ((data.token[a].indexOf("//") !== 0 || a === b - 1) && data.token[foldindex[foldindex.length - 1][1]].indexOf("//") === 0) {
                                    foldend();
                                }
                            }
                            if (data.types[a] === "reference") {
                                reference();
                            }
                            else if (data.token[a] === "{") {
                                if (data.stack[a + 1] === "object" || data.stack[a + 1] === "class") {
                                    scoped.push(false);
                                    build.push("{");
                                }
                                else {
                                    if (scoped.length === levels[a]) {
                                        if (scoped[scoped.length - 1] === false) {
                                            scoped[scoped.length - 1] = true;
                                            scope = scope + 1;
                                        }
                                    }
                                    else {
                                        scoped.push(true);
                                        scope = scope + 1;
                                    }
                                    data.token[a] = `<em class="s${scope}">{</em>`;
                                    build.push(data.token[a]);
                                }
                                if (levels[a] > scoped.length) {
                                    do {
                                        scoped.push(false);
                                    } while (levels[a] > scoped.length);
                                }
                            }
                            else if (data.token[a] === "}") {
                                if (data.stack[a] === "object" || data.stack[a] === "class") {
                                    build.push("}");
                                }
                                else {
                                    build.push(`<em class="s${scope}">}</em>`);
                                    scope = scope - 1;
                                }
                            }
                            else {
                                if (data.types[a].indexOf("string") > -1 && data.token[a].indexOf("\n") > 0) {
                                    multiline(data.token[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                                }
                                else if (data.types[a] === "operator" || data.types[a] === "comment" || data.types[a].indexOf("string") > -1 || data.types[a] === "regex") {
                                    build.push(data.token[a].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"));
                                }
                                else {
                                    if (data.types[a] === "start" && levels[a] > -1) {
                                        scoped.push(false);
                                    }
                                    if (data.token[a] !== ";" || options.no_semicolon === false) {
                                        build.push(data.token[a]);
                                    }
                                    else if (levels[a] < 0 && data.types[a + 1] !== "comment") {
                                        build.push(";");
                                    }
                                }
                            }
                        }
                        if (a < b - 1 && data.lexer[a + 1] !== lexer && data.begin[a] === data.begin[a + 1] && data.types[a + 1].indexOf("end") < 0 && data.token[a] !== ",") {
                            build.push(" ");
                        }
                        else if (levels[a] > -1 && a < b - 1) {
                            lastLevel = levels[a];
                            nlscope(levels[a]);
                        }
                        else if (levels[a] === -10) {
                            build.push(" ");
                            if (data.lexer[a + 1] !== lexer) {
                                lastLevel = lastLevel + 1;
                            }
                        }
                    }
                    else {
                        if (externalIndex[a] === a) {
                            build.push(data.token[a]
                                .replace(/&/g, "&amp;")
                                .replace(/</g, "&lt;")
                                .replace(/>/g, "&gt;")
                                .replace(/&lt;strong class="new"&gt;this&lt;\/strong&gt;/g, "<strong class=\"new\">this</strong>")
                                .replace(/&lt;strong class="new"&gt;new&lt;\/strong&gt;/g, "<strong class=\"new\">new</strong>"));
                        }
                        else {
                            prettydiff.end = externalIndex[a];
                            options.indent_level = lastLevel;
                            prettydiff.start = a;
                            external = prettydiff.beautify[data.lexer[a]](options)
                                .replace(/\s+$/, "")
                                .replace(/&/g, "&amp;")
                                .replace(/</g, "&lt;")
                                .replace(/>/g, "&gt;")
                                .replace(/&lt;strong class="new"&gt;this&lt;\/strong&gt;/g, "<strong class=\"new\">this</strong>")
                                .replace(/&lt;strong class="new"&gt;new&lt;\/strong&gt;/g, "<strong class=\"new\">new</strong>");
                            if (external.indexOf(lf) > -1) {
                                if (start === 0) {
                                    exline = new RegExp(`\\r?\\n(${tab}){${lastLevel}}`, "g");
                                    external = external.replace(exline, lf);
                                }
                                exlines = external.split(lf);
                                exlevel = 0;
                                if (exlines.length > 1) {
                                    do {
                                        build.push(exlines[exlevel]);
                                        nlscope(lastLevel);
                                        exlevel = exlevel + 1;
                                    } while (exlevel < exlines.length - 1);
                                    build.push(exlines[exlevel]);
                                }
                            }
                            else {
                                build.push(external);
                            }
                            a = prettydiff.iterator;
                            if (levels[a] === -10) {
                                build.push(" ");
                            }
                            else if (levels[a] > -1) {
                                nlscope(levels[a]);
                            }
                        }
                    }
                    a = a + 1;
                } while (a < b);
                a = build.length - 1;
                do {
                    if (build[a] === tab) {
                        build.pop();
                    }
                    else {
                        break;
                    }
                    a = a - 1;
                } while (a > -1);
                //this logic is necessary to some line counting corrections to the HTML output
                last = build[build.length - 1];
                if (last.indexOf("<li") > 0) {
                    build[build.length - 1] = "<em class=\"line\">&#xA;</em></li>";
                }
                else if (last.indexOf("</li>") < 0) {
                    build.push("<em class=\"line\">&#xA;</em></li>");
                }
                build.push("</ol></div>");
                last = build.join("").replace(/prettydifflt/g, "<").replace(/prettydiffgt/g, ">");
                if (last.match(/<li/g) !== null) {
                    scope = last
                        .match(/<li/g)
                        .length;
                    if (linecount - 1 > scope) {
                        linecount = linecount - 1;
                        do {
                            code.pop();
                            code.pop();
                            code.pop();
                            linecount = linecount - 1;
                        } while (linecount > scope);
                    }
                }
                code.push("</ol>");
                code.push(lf);
                code.push(last);
                if (options.new_line === true) {
                    code.push(lf);
                }
                options.jsscope = optionValue;
                return [
                    "<p>Scope analysis does not provide support for undeclared variables.</p>",
                    "<p><em>",
                    scolon,
                    "</em> instances of <strong>missing semicolons</strong> counted.</p>",
                    "<p><em>",
                    news,
                    "</em> unnecessary instances of the keyword <strong>new</strong> counted.</p>",
                    code.join("")
                ].join("").replace(/(\s+)$/, "").replace(options.binary_check, "");
            }
            a = prettydiff.start;
            do {
                if (data.lexer[a] === lexer || prettydiff.beautify[data.lexer[a]] === undefined) {
                    if (invisibles.indexOf(data.token[a]) < 0) {
                        if (data.types[a] === "reference" && options.jsscope === "interim") {
                            reference();
                        }
                        else {
                            if (data.token[a] !== ";" || options.no_semicolon === false) {
                                build.push(data.token[a]);
                            }
                            else if (levels[a] < 0 && data.types[a + 1] !== "comment") {
                                build.push(";");
                            }
                        }
                    }
                    if (a < b - 1 && data.lexer[a + 1] !== lexer && data.begin[a] === data.begin[a + 1] && data.types[a + 1].indexOf("end") < 0 && data.token[a] !== ",") {
                        build.push(" ");
                    }
                    else if (levels[a] > -1) {
                        if (((levels[a] > -1 && data.token[a] === "{") || (levels[a] > -1 && data.token[a + 1] === "}")) && data.lines[a] < 3 && options.brace_line === true) {
                            build.push(nl(0));
                        }
                        lastLevel = levels[a];
                        build.push(nl(levels[a]));
                    }
                    else if (levels[a] === -10) {
                        build.push(" ");
                        if (data.lexer[a + 1] !== lexer) {
                            lastLevel = lastLevel + 1;
                        }
                    }
                }
                else {
                    if (externalIndex[a] === a) {
                        build.push(data.token[a]);
                    }
                    else {
                        prettydiff.end = externalIndex[a];
                        options.indent_level = lastLevel;
                        prettydiff.start = a;
                        external = prettydiff.beautify[data.lexer[a]](options).replace(/\s+$/, "");
                        build.push(external);
                        a = prettydiff.iterator;
                        if (levels[a] === -10) {
                            build.push(" ");
                        }
                        else if (levels[a] > -1) {
                            build.push(nl(levels[a]));
                        }
                    }
                }
                a = a + 1;
            } while (a < b);
            prettydiff.iterator = b - 1;
            return build.join("");
        }());
        return output;
    };
    prettydiff.beautify.script = script;
}());
prettydiff.sparser=sparser;prettydiff.version={"date":"18 Aug 2019","number":"101.2.6","parse":"1.4.12"};// eslint-disable-next-line
(function(){"use strict";function b(a,b){return"undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(b,c,d){var e=new XMLHttpRequest;e.open("GET",b),e.responseType="blob",e.onload=function(){a(e.response,c,d)},e.onerror=function(){console.error("could not download file")},e.send()}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"))}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,a=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i)})}}:function(a,b,d,e){if(e=e||open("","_blank"),e&&(e.document.title=e.document.body.innerText="downloading..."),"string"==typeof a)return c(a,b,d);var g="application/octet-stream"===a.type,h=/constructor/i.test(f.HTMLElement)||f.safari,i=/CriOS\/[\d]+/.test(navigator.userAgent);if((i||g&&h)&&"object"==typeof FileReader){var j=new FileReader;j.onloadend=function(){var a=j.result;a=i?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),e?e.location.href=a:location=a,e=null},j.readAsDataURL(a)}else{var k=f.URL||f.webkitURL,l=k.createObjectURL(a);e?e.location=l:location.href=l,e=null,setTimeout(function(){k.revokeObjectURL(l)},4E4)}});f.saveAs=a.saveAs=a;}());;

prettydiff.saveAs=window.saveAs;return prettydiff;}());
// prettydiff dom insertion end
meta = prettydiff.meta;
    options = prettydiff.options;
    options.api = "dom";
    load();
}());
